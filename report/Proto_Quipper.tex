\documentclass[twoside]{article}

\usepackage{times}
\usepackage{fancyhdr}

\input{Proto_Quipper.sty}

\oddsidemargin 1in
\evensidemargin 1in
\topmargin 1in
\textwidth 4.5in \textheight 6.6in
\headheight 0in
\headsep .1in
\voffset -.35in


% ----------------------------------------------------------------------
% General Information.
\title{Report on Proto-Quipper 0.1}
\author{Report authors: \\
  Henri Chataing (Dalhousie University)\\
  Neil J. Ross (Dalhousie University)\\
  Peter Selinger (Dalhousie University)
}
\date{Program PI:\\
  D. Scott Alexander (Applied Communication Sciences)}

\pagestyle{fancy}
\def\notice{\footnotesize FOR GOVERNMENT AND APPLIED COMMUNICATION SCIENCES
  (ACS) TEAM USE ONLY}
\fancyhead{}
\fancyhead[LO,RE]{\thepage}
\fancyfoot{}
\fancyfoot[LE]{\notice}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% ----------------------------------------------------------------------
\begin{document}
\maketitle
\thispagestyle{fancy}

This work was performed under U.S. Government contract D12PC00527.
\vspace{-1ex}

\tableofcontents

% ----------------------------------------------------------------------
\clearpage
\section{Introduction}

\subsection{Overview}

The PLATO team's primary quantum programming language, Quipper, is
currently implemented as an embedded language, within the host
language Haskell. This has many advantages, for example, the ability
to implement a large-scale system very rapidly. However, there are
also a few disadvantages. One of these is that the Haskell type
system, while providing many type-safety properties, is not in general
strong enough to ensure full type-safety of the quantum programs. In
the current Quipper implementation, it is therefore the programmer's
responsibility to ensure that quantum components are plugged together
in physically meaningful ways. This means that certain types of
programming errors will not be prevented by the compiler; in the worst
case, this may lead to ill-formed output or run-time errors in other
parts of the tool chain.

In this report, we describe a type-safe version of a small fragment of
Quipper, which we call {\em Proto-Quipper}. Proto-Quipper has been
implemented as a stand-alone (non-embedded) programming language.  The
Proto-Quipper language is designed to ``enforce the physics'', in the
sense that it will detect, at compile-time, programming errors that
could lead to ill-formed or undefined circuits.  

We note that type-safety in Proto-Quipper, as in all programming
languages, only guarantees the {\em well-formedness} of programs, and
not their {\em correctness}. Correctness, of course, remains the
programmer's responsibility. In particular, type-safety does not
guarantee anything about the correctness of {\em programmer
  assertions}, including the correct use of assertive termination
gates. 

We distinguish between the \emph{core} of Proto-Quipper, which 
represents the proved type-safe fragment of the language, and 
the \emph{extensions} of the language, containing newly 
implemented features of Proto-Quipper that are currently under 
development. 

\subsection{Outline}

This report is organized as follows. In Section~\ref{sec-design}, we
briefly explain the rationale behind Proto-Quipper's design, including
the differences between Quipper, Proto-Quipper, Core Proto-Quipper,
and the quantum lambda calculus. In Section~\ref{sec-core}, we
formally define the Core Proto-Quipper language, its type system, and
its operational semantics. In Section~\ref{sec-type-safety}, we prove
the type-safety of the language. In Section~\ref{sec-inference}, we
describe a type inference algorithm for Core Proto-Quipper. In
Section~\ref{sec-extensions}, we discuss some extensions of
Proto-Quipper that are already implemented in our language
implementation, but not yet formalized. In Section~\ref{sec-future},
we discuss possible future work, including how Proto-Quipper could be
extended with additional Quipper features.
Section~\ref{sec-user-guide} provides a user-level tutorial guide to
the Proto-Quipper implementation.

\subsection{Additional materials}

This document is accompanied by the Proto-Quipper software version
0.1:
\begin{compactitemize}
\item the Proto-Quipper language implementation, including
\item the Proto-Quipper browsable documentation (in the doc/ directory).
\end{compactitemize}

Please also note that a user-level tutorial introduction to the
Proto-Quipper implementation is given in
Section~\ref{sec-user-guide}. Readers who are looking for a software
guide, rather than the theory of Proto-Quipper, should skip ahead to
Section~\ref{sec-user-guide}.

% ----------------------------------------------------------------------
\clearpage
\section{Design rationale}\label{sec-design}

\subsection{Design goals}\label{ssec-goals}

In designing the Proto-Quipper language, our approach was to start
with a limited (but still expressive) fragment of the Quipper language
and make it completely type-safe.  This fragment serves as a robust
basis for future language extensions. The idea is to eventually close
the gap between Proto-Quipper and Quipper by extending Proto-Quipper
with one feature at a time while retaining type-safety. 

The current version of Proto-Quipper (0.1) was designed with two goals
in mind:
\begin{itemize}
  \item to incorporate Quipper's ability to generate and act on 
  quantum circuits, and 
\item to provide a linear type system to guarantee that the produced
  circuits are physically meaningful. In particular, properties like
  no-cloning are respected.
\end{itemize}

\subsection{Quantum lambda calculus}

An important precursor to Proto-Quipper is the quantum lambda calculus
{\cite{SeVa09}}. In the quantum lambda calculus, the execution of
programs is modelled by the so-called {\em reduction relation}. This
relation is defined on \emph{closures}, which are essentially pairs
$[C,t]$ consisting of a term of the language $t$ and a quantum state
$C$. The state is a unit vector in a complex Hilbert space and $t$ is
a term whose free variables are linked to qubits in $C$. The quantum
state is held in a quantum device capable of performing certain
operations (applying unitaries, measuring qubits,\ldots). The
reduction relation in the quantum lambda calculus is then defined as a
probabilistic rewrite procedure on these closures. Typically, the
reduction will be classical until a redex involving a quantum constant
is reached. At this point, the quantum device will be instructed to
perform the appropriate quantum operation. For example: ``Apply a
Hadamard gate to qubit number 3''.

\subsection{From quantum lambda calculus to Proto-Quipper}

One of the main differences between Quipper and the quantum lambda
calculus is that Quipper acts as a {\em circuit description language}.
Quipper provides the ability to treat circuits as data, and to
manipulate them as a whole.  For example, Quipper has operators for
reversing circuits, decomposing them into gate sets, optimization of
circuits, resource counting, and so on. By contrast, the quantum
lambda calculus only manipulates {\em qubits}. In other words, in
the quantum lambda calculus, all quantum operations are immediately
carried out on a quantum device, and not stored for symbolic
manipulation.

In the design of Proto-Quipper, we extended the quantum lambda
calculus with the minimal set of features that makes it Quipper-like.
Namely, we added the ability to create and manipulate circuits.  As
detailed later in this report, we equipped this language with a type
system and proved {\em type-safety}, i.e., the property that no
well-typed program will perform a non-physical operation.

The execution of Proto-Quipper programs has been formalized as a
reduction relation on closures, similarly to the quantum lambda
calculus.  However, a closure $[C,t]$ in Proto-Quipper consists of a
term $t$ and a \emph{circuit state} $C$. The state $C$ represents the
circuit currently being built. Instead of having a quantum device
capable of performing quantum operations, we assume that we have a
\emph{circuit constructor} capable or performing certain circuit
building operations (such as appending gates, reversing, etc.). The
reduction is then defined as a non-probabilistic rewrite procedure on
closures.  As in the quantum lambda calculus, some redexes will affect
the state by sending instructions to the circuit constructor. For
example: ``Append a Hadamard gate to wire number 3''.


% ----------------------------------------------------------------------
\clearpage
\section{The core language}\label{sec-core}

In this section, we define the core of Proto-Quipper. We 
present in details the syntax, type system and 
operational semantics of the language.

\subsection{Types and terms}
\label{ssec-types-and-terms}

\begin{definition} 
The \emph{types} of Proto-Quipper are defined by:
\begin{center}
\begin{tabular}{rrl}
$\texttt{Type}$&$~A,B~~\bnf$ & $ \qubit \bor 1 \bor \bool \bor A\tensor B \bor 
A\loli B \bor {!}A \bor \Circ (T,U).$\\
\end{tabular}
\end{center}
Among the types, we single out the subset of \emph{quantum data types}:
\begin{center}
\begin{tabular}{rrl}
$\qdatatype$&$~T,U~~\bnf$ & $\qubit \bor 1 \bor T \tensor U.$
\end{tabular}
\end{center}
\end{definition}

The type system of Proto-Quipper, like the type system of the quantum
lambda calculus, is based on intuitionistic linear logic
{\cite{Gir87}}.  It can be helpful to think of types as sets of
values. Under this interpretation, the types can be understood as
follows. The type $\bool$ represents the set of booleans, $1$ is the
unit type, $A\x B$ is the set of pairs composed of a left member of
type $A$ and of right member of type $B$, and $A\loli B$ is the set of
functions from $A$ to $B$. The type ${!}A$ can be understood as the
subset of $A$ consisting of values that have the additional property
of being \emph{duplicable} or \emph{reusable}. We will sometimes write
${!}^nA$, with $n\in\N$, to mean:
\[
\underbrace{{!}\ldots {!}}_{n} A.
\]
The remaining types are specific to Proto-Quipper. The elements of
$\qubit$ are (quantum) wire identifiers, i.e., essentially references
to a logical qubit within a computation. They can be thought of as
references to quantum bits on some physical device, or simply as
references to quantum wires within the circuit currently being
constructed. Elements of quantum data types describe sets of circuit
endpoints, and consist of tuples of wire identifiers. We can think of
these as describing circuit interfaces. Finally, the type $\Circ(T,U)$
is the set of all circuits having an input interface of type $T$ and 
an output interface of type $U$. 

\begin{definition}
  Assume three countable sets: a set $\vset$ of \emph{term variables},
  denoted $x,y,z,\ldots$; a set $\qset$ of \emph{quantum variables},
  denoted $q,q_1,q_2,\ldots$; and a set $\cset$ of \emph{circuit
    constants}, denoted $C,D,\ldots$. The \emph{terms} of
  Proto-Quipper are defined by:
\begin{center}
\begin{tabular}{rrl}
$\term$&$~a,b,c~~ \bnf$ & $x \bor q \bor (t,C,a) \bor \true 
  \bor \false \bor \p{a,b} \bor * \bor$ \\[0.05in]
& & $ab \bor \lambda x.a \bor \boxx^T \bor \unbox \bor \rev 
    \bor $\\[0.05in]
& & $\ifthenelse{a}{b}{c} \bor \letin{\p{x,y}}{a}{b}.$
\end{tabular}
\end{center}
Among the terms, we single out the subset of \emph{quantum data terms}:
\begin{center}
\begin{tabular}{rrl}
$\qdataterm$&$~t,u~~\bnf$ & $q \bor * \bor \p{t,u}.$
\end{tabular}
\end{center}
Moreover, we assume that $\cset$ is equipped with two functions 
$\In,\Out\from \cset\to\pset_f(\qset)$ and that $\qset$ is 
well-ordered. Here, $\pset_f(\qset)$ denotes the set of finite subsets
of $\qset$.
\end{definition}

The meaning of most terms is intended to be the standard one. For
example $\p{a,b}$ is the pair of $a$ and $b$, $\true$ and $\false$ are
the booleans and $\lambda x.a$ is the function which maps $x$ to
$a$. For the more unusual terms we have:
\begin{itemize}
\item A circuit constant $C$ represents a low-level quantum circuit.
  Because it would be complicated, and somewhat besides the point, to
  define a formal language for describing low-level quantum circuits,
  Proto-Quipper assumes that there exists a constant symbol for {\em
    every} possible quantum circuit. Each circuit $C$ is equipped with
  a finite set of {\em inputs} and a finite set of {\em outputs},
  which are subsets of the set of quantum variables $\qset$.

  Proto-Quipper's abstract treatment of quantum circuits is further
  explained in Section~\ref{ssec-circuit-cons}.

\item The term $(t,C,a)$ represents a quantum circuit, regarded as
  Proto-Quipper data. The purpose of the terms $t$ and $a$ is to
  provide structure on the (otherwise unordered) sets of inputs and
  outputs of $C$, so that these inputs and outputs can take the shape
  of Proto-Quipper quantum data.  For example, suppose that $C$ is a
  circuit with inputs $\s{q_1,q_2,q_3}$ and outputs
  $\s{q_4,q_5,q_6}$. Then the term
  \[ (\p{q_2,\p{q_3,q_1}}, C, \p{\p{q_4,q_6},q_5})
  \] 
  represents the circuit $C$, but also specifies what it means to
  apply this circuit to a quantum data term $\p{p,\p{r,s}}$. Namely,
  in this case, the circuit inputs $q_2$, $q_3$, and $q_1$ will be
  applied to qubits $p$, $r$, and $s$, respectively.  Moreover, if the
  output of this circuit is to be matched against the pattern
  $\p{\p{x,y},z}$, then the variables $x$, $y$, and $z$ will be bound,
  respectively, to the quantum bits at endpoints $q_4$, $q_6$, and
  $q_5$.

  Terms of the form $(t,C,a)$ are not intended to be written by the
  user of the programming language; in fact, the Proto-Quipper
  implementation does not provide a concrete syntax for such
  terms. Rather, these terms are internally generated during the {\em
    evaluation} of Proto-Quipper programs. However, the circuits for
  certain basic gates may be made available to the user as pre-defined
  symbols.
\item $\boxx^T$ is a built-in function to turn a circuit-producing
  function (for example, a function of type $T\loli U$) into a
  circuit regarded as data (for example, of type $\Circ(T,U)$). It is
  the equivalent of the {\tt encapsulate\_generic} operator in Quipper.
\item $\unbox$ is a built-in function for turning a circuit regarded
  as data into a circuit-producing function. It is an inverse of
  $\boxx^T$, and corresponds to the {\tt unencapsulate\_generic}
  operator in Quipper.
\item $\rev$ is a built-in function for reversing a low-level
  circuit.
\end{itemize}
Note that the term $\boxx^T$ is parameterized by a type $T$. This
\emph{Church-style} typing of the language is the reason why types
were introduced before terms. Also note that in a term like $(t,C,a)$,
$t$ is assumed to be a quantum data term, but $a$ is not. The type
system to be introduced later will guarantee that even though $a$ is
not yet a quantum data term it will eventually reduce to one.

The \emph{values} are the terms whose execution is finished.

\begin{definition}
The \emph{values} of Proto-Quipper are defined by:
\begin{center}
\begin{tabular}{rrl}
$\val$&$~v,w~~\bnf$ & $x \bor q \bor (t,C,u) \bor \true \bor 
  \false \bor \p{v,w} \bor$ \\
& & $* \bor \lambda x.a  \bor \boxx^T \bor \unbox \bor \rev.$
\end{tabular}
\end{center}
\end{definition}

\noindent
For reference, we summarize some notational conventions that will be
used throughout these notes. Additional such conventions will be
adapted throughout. We write:
\begin{itemize}
  \item $x,y,z,\ldots$ for variables,
  \item $q_1,q_2,q_3,\ldots$ for quantum variables,
  \item $C,D,\ldots$ for circuit constants,
  \item $A,B,\ldots$ for types,
  \item $a,b,c,\ldots$ for terms,
  \item $S,T,U,\ldots$ for quantum data types,
  \item $s,t,u,\ldots$ for quantum data terms and
  \item $v,w,\ldots$ for values.
\end{itemize}

\subsection{Operations on types and terms}

We now introduce some useful syntactic operations on types and terms. 

\begin{definition}
The set of \emph{free (term) variables} of a term $a$, written $\FV(a)$, 
is defined recursively as follows:
\begin{itemize}
  \item $\FV(x)=\s{x}$,
  \item $\FV(\p{a,b})=\FV(a)\cup \FV(b)$,
  \item $\FV(ab)=\FV(a)\cup \FV(b)$,
  \item $\FV(\lambda x.a)=\FV(a)\setminus\s{x}$,
  \item $\FV(\ifthenelse{a}{b}{c}) = \FV(a) \cup \FV(b) \cup \FV(c)$,
  \item $\FV(\letin{\p{x,y}}{a}{b}) = \FV(a)\cup (\FV(b)\setminus \s{x,y})$,
  \item $\FV((t,C,a))= \FV(a)$ and
  \item $\FV(a)=\emptyset$ in all remaining cases.
\end{itemize}
\end{definition}

The above definition of free variables extends the usual one from
lambda calculus. Note that the free variables of a term of the form
$(t,C,a)$ are the free variables of $a$. This is justified since no
variables ever appear in the quantum data term $t$. Variables that are
not free are {\em bound}. The notions of $\alpha$-equivalence,
capture-avoiding substitution, etc., are defined in a straightforward
manner. To wit, two terms are {\em $\alpha$-equivalent} if they differ
only in the naming of bound variables, and we generally identify terms
up to $\alpha$-equivalence.

By analogy with the free term variables of a term, we introduce a
notion of \emph{quantum variable of term}.

\begin{definition}
  The set of \emph{free quantum variables} of a term $a$, written
  $\FQ(a)$, is recursively defined as follows:
\begin{itemize}
  \item $\FQ(q)=\s{q}$,
  \item $\FQ(\p{a,b})=\FQ(a)\cup \FQ(b)$,
  \item $\FQ(ab)=\FQ(a)\cup \FQ(b)$,
  \item $\FQ(\lambda x.a)=\FQ(a)$,
  \item $\FQ(\ifthenelse{a}{b}{c}) = \FQ(a) \cup \FQ(b) \cup \FQ(c)$,
  \item $\FQ(\letin{\p{x,y}}{a}{b})= \FQ(a)\cup \FQ(b)$ and
  \item $\FQ(a)=\emptyset$ in all remaining cases.
\end{itemize}
\end{definition}

Note that $\FQ((t,C,a))=\emptyset$. This reflects the idea that the 
quantum variables appearing in $t$ and $a$ are ``bound'' in $(t,C,a)$. 

To append circuits, we will need to be able to express the way in 
which wires should be connected. For this, we use the notion of a 
\emph{binding}.

\begin{definition}
A \emph{finite bijection} on a set $X$ is a bijection between two 
finite subsets of $X$. We write $\finbij(X)$ for the set of finite 
bijections on $X$.
\end{definition}

\begin{definition}
A \emph{binding} is a finite bijection on $\qset$ and if $\binding$ 
is a binding we write $\dom(\binding)$ for the domain of $\binding$.
\end{definition}

Adding to the list of notational conventions above, we will write 
$\binding$ for an arbitrary binding. 

\begin{definition}
If $a$ is a term, $\binding$ is a binding and $\dom(\binding)\cap
\FQ(a)=\s{q_1,\ldots,q_n}$, then $\binding(a)$ is the following 
term:
\[
\binding(a)= a[\binding(q_1)/q_1,\ldots ,\binding(q_n)/q_n].
\]
\end{definition}

\begin{definition}
The partial function $\bind: \qdataterm^2\to \finbij(\qset)$ is 
defined recursively as follows:
\[
\bind (t,u)= \left\{
  \begin{array}{ll}
    \emptyset & \mbox{if}~~ t=u=*, \\
    \s{(q_1,q_2)} & \mbox{if}~~ t=q_1 \mbox{ and } u=q_2, \\        
    \bind (t_1,u_1) \cup \bind (t_2,u_2) & 
      \mbox{if}~~ t=\p{t_1,t_2} \mbox{ and } u=\p{u_1,u_2}, \\
    \mbox{undefined} & \mbox{in all remaining cases.}
  \end{array}
\right.
\]
\end{definition}

\begin{definition}
Let $T$ be a quantum data type and $X$ a finite subset of $\qset$. 
An \emph{$X$-specimen} for $T$ is quantum data term written $\spec_X(T)$ 
defined by recursion as follows:
\begin{itemize}
  \item $\spec_X(1)=*$,
  \item $\spec_X(\qubit)=q$ where $q$ is the smallest quantum 
  index of $\qset\setminus X$,
  \item $\spec_X(T\tensor U)=\p{t,u}$ where $t=\spec_X(T)$ 
  and $u=\spec_{X\cup \FQ(t)}(U)$.  
\end{itemize}
\end{definition}

% The definition of specimen uses the fact that $\mathcal{Q}$ is 
% well-ordered.

Informally, an $X$-specimen for $T$ is a quantum data term $t$ that is 
``fresh" with respect to the quantum variables appearing in $X$.
If $X$ is clear from the context, we simply write $\spec (T)$.


\subsection{The type system}

The fact that a term is reusable should not prevent us from using it
exactly once. Intuitively, this should imply that if ${!}A$ is a valid
type for a given term, then $A$ should also be a valid type for it.
To capture this idea, we use a sub-typing relation on types.

\begin{definition}
The \emph{sub-typing relation} $<:$ is the smallest relation on 
types satisfying the rules given in 
Figure~\hyperref[subtyping_congruences]{\ref*{subtyping_congruences}}.
\end{definition}

\begin{figure}[!ht]
\begin{mdframed}
\[
  \infer[]{\qubit <: \qubit}{}
~~~~
  \infer[]{1 <: 1}{}
~~~~
  \infer[]{\bool <: \bool}{}
\]
\[
  \infer[]{ (A_1\x A_2) <:  (B_1 \x B_2)}{A_1<:B_1~~A_2<:B_2}
~~~~
  \infer[]{ (A_1\loli B_1) <: (A_2\loli B_2)}{A_2<:A_1~~B_1<:B_2}
\]
\[
  \infer[]{ \Circ(A_1, B_1) <:  \Circ(A_2, B_2)}{A_2<:A_1~~B_1<:B_2}
\]
\[
  \infer[]{ {!}^nA <: {!}^mB}{
    A<:B
    &
    (n=0 \imp m=0)
  }
\]
% A not as nice version of the subtyping rules:
%
%\[
%  \infer[]{{!}^n\qubit <: {!}^m\qubit}{}
%~~~~
%  \infer[]{{!}^n1 <: {!}^m1}{}
%~~~~
%  \infer[]{{!}^n\bool <: {!}^m\bool}{}
%\]
%\[
%  \infer[]{{!}^n (A_1\x A_2) <: {!}^m (B_1 \x B_2)}{A_1<:B_1~~A_2<:B_2}
%~~~~
%  \infer[]{{!}^n (A'\loli B) <: {!}^m (A\loli B')}{A<:A'~~B<:B'}
%\]
%\[
%  \infer[.]{{!}^n \Circ(A', B) <: {!}^m \Circ(A, B')}{A<:A'~~B<:B'}
%\]
\end{mdframed}
\caption{The sub-typing rules of Proto-Quipper.}
\label{subtyping_congruences}
\end{figure}

Note that the subtyping of $A\loli B$ and $\Circ(A,B)$ is {\em
  contravariant} in the left argument, i.e., $A<:A'$ implies $A'\loli
B<:A\loli B$.

\begin{remark}
\label{subtyping_shape}
If $A<:B$ then:
\begin{enumerate}
  \item if $A\in\s{\qubit, 1, \bool}$, then $A=B$;
  \item if $A=A_1\x A_2$, then $B=B_1\x B_2$, 
  $A_1<:B_1$ and $A_2<:B_2$;
  \item if $A=A_1\loli A_2$, then $B=B_1\loli B_2$, 
  $B_1<:A_1$ and $A_2<:B_2$;
  \item if $A=\Circ(A_1, A_2)$, then $B=\Circ(B_1,B_2)$, 
  $B_1<:A_1$ and $A_2<:B_2$;
  \item if $B={!}B'$, then $A={!}A'$ and $A'<:B'$;\label{subtype_bang}
  \item if $A$ is not of the form ${!}A'$, then $B$ is not 
  of the form ${!}B'$.
\end{enumerate}
\end{remark}

\begin{proposition}
The subtyping relation is reflexive and transitive.
\end{proposition}

Note that by taking $n=0$ and $m=1$ in the last subtyping rule, the
following rule is derivable:
\[
  \infer[]{{!}A <: A}{}
  .
\]

\begin{definition}
A \emph{typing context} is a finite set 
$\s{x_1:A_1,\ldots,x_n:A_n}$ of pairs of a variable and 
a type, such that no variable occurs more than once. A 
\emph{quantum context} is a finite set of quantum variables. 
The expressions of the form $x:A$ in a typing context are 
called \emph{type declarations}.	
\end{definition}

We write $\Gamma$ or $\Delta$ for a typing context and $Q$ for 
a quantum context. If $\Gamma =\s{x_1:A_1,\ldots,x_n:A_n}$ is 
a typing context, then $|\Gamma|=\s{x_1,\ldots,x_n}$, 
$\Gamma (x_i)=A_i$ and we write ${!}\Gamma$ if $\Gamma(x_i)={!}A_i'$ 
for every $i$. The union of two contexts is defined when
$|\Gamma|\cap  |\Gamma'|=\emptyset$ and is denoted by $\Gamma,\Gamma'$, 
and similarly for quantum contexts. Finally, we extend the subtyping 
relation to typing contexts as follows: $\Gamma <: \Gamma'$ if and 
only if $|\Gamma | = |\Gamma'|$ and $\Gamma (x_i)<: \Gamma' (x_i)$ 
for every $i$.

\begin{definition}
Let $T,U$ be quantum data types and $m,n\in\N$. For each of the constants 
$\boxx^T$, $\unbox$, and $\rev$, we introduce a type as follows:
\begin{itemize}
  \item $A_{\boxx^T}(T,U)={!}(T\loli U)\loli {!}\Circ(T,U)$,
  \item $A_{\unbox}(T,U)=\Circ(T,U)\loli {!}(T\loli U)$, and
  \item $A_{\rev}(T,U)=\Circ(T,U) \loli {!}\Circ(U,T)$.
\end{itemize}
\end{definition}

\begin{definition}
A \emph{typing judgment} is an expression of the form:
\[
\Gamma ; Q \entails a:A
\] 
where $\Gamma$ is a typing context, $Q$ is a quantum context, 
$a$ is a term and $A$ is a type. A typing judgment is \emph{valid} if 
it can be inferred from the rules given in Figure~\hyperref[trules]{\ref*{trules}}. In the rule $(\rul{cst}_c)$, 
$c$ ranges over the set $\s{\boxx^T, \unbox, \rev}$. Each typing rule
carries an implicit side condition that the judgements appearing in it
are well-formed. In particular, a rule containing a context of the form
$\Gamma_1,\Gamma_2$ may not be applied unless
$|\Gamma_1|\cap|\Gamma_2|=\emptyset$. 
\end{definition}

Note that in the typing judgements of Proto-Quipper, quantum variables
and variables are kept separate. As a result, we do not have to specify
that $q:\qubit$ for every quantum variable $q$ since the typing rules
implicitly enforce this. However, when a future version of
Proto-Quipper will be equipped with the ability to manipulate quantum
\emph{and} classical wires, the type of a wire might have to be
explicitly stated.

% Another reason for this is because in the reduction rule for
% (t,c,u) we need to be able to construct, e.g., t in a context
% that is empty but for the quantum variables appearing in t.

\begin{figure}[!ht]
\begin{mdframed}
\[
\infer[(\rul{ax}_c)]{{!}\Delta, x:A;\emptyset\entails x:B}{
  A<:B
}
~~~~
\infer[(\rul{ax}_q)]{{!}\Delta;\s{q}\entails q:\qubit}{
} 
\]
\[
\infer[(\rul{cst}_c)]{{!}\Delta;\emptyset \entails c:B}{
  {!}A_{c}(T,U)<:B
} 
~~~~
\infer[(\rul{unit})]{{!}\Delta;\emptyset\entails *:{!}^n 1}{
}
\]
\[
\infer[(\lambda_1)]{\Gamma;Q\entails \lambda x.b:A\loli B}{
  \Gamma,x:A;Q \entails b:B
}
~~~~
\infer[(\lambda_2)]{{!}\Delta;\emptyset \entails \lambda x.b:~{!}^{n+1}(A\loli B)}{
  {!}\Delta, x:A;\emptyset \entails b:B
}
\]
\[
\infer[(\rul{app})]{\Gamma_1,\Gamma_2, {!}\Delta;Q_1,Q_2\entails ca:B}{
  \Gamma_1, {!}\Delta;Q_1\entails c:A\loli B 
  &
  \Gamma_2, {!}\Delta ;Q_2\entails a:A 
}
\]
\[
\infer[(\x\mbox{-i})]{\Gamma_1,\Gamma_2, {!}\Delta;Q_1,Q_2\entails \p{a,b}:{!}^n(A\x B)}{
  \Gamma_1, {!}\Delta;Q_1\entails a:{!}^nA 
  &
  \Gamma_2, {!}\Delta ;Q_2\entails b:{!}^nB
}
\]
% Note that in fact the \x intro rule could have equivalently been written with
% a:{!}^nA b:{!}^mB and (a,b):{!}^o(A\x B) where o=min {n,m}
% Indeed the rules are equivalent via the type isomorphism {!!}A~{!}A and the 
% subtyping relation {!}A<:A. The moral here is that a pair is as 
% reusable as its least reusable component.
\[
\infer[(\x\mbox{-e})]{\Gamma_1,\Gamma_2, {!}\Delta;Q_1,Q_2\entails \letin{\p{x,y}}{b}{a}:A}{
  \Gamma_1, {!}\Delta;Q_1\entails b:{!}^n(B_1\x B_2) 
  &
  \Gamma_2, {!}\Delta, x:{!}^nB_1, y:{!}^nB_2 ;Q_2\entails a:A
}
\]
\[
\infer[(\top)]{{!}\Delta;\emptyset\entails \true:{!}^n \bool}{
} 
~~~~
\infer[(\bot)]{{!}\Delta;\emptyset\entails \false:{!}^n \bool}{
}
\]
\[
\infer[(\rul{if})]{\Gamma_1,\Gamma_2, {!}\Delta;Q_1,Q_2\entails \ifthenelse{b}{a_1}{a_2}:A}{
  \Gamma_1, {!}\Delta;Q_1\entails b:\bool 
  &
  \Gamma_2, {!}\Delta;Q_2 \entails a_1:A ~~~ \Gamma_2, {!}\Delta;Q_2 \entails a_2:A
}
\]
\[
\infer[(\rul{circ})]{{!}\Delta;\emptyset \entails (t,C,a):{!}^n\Circ(T,U)}{
  Q_1\entails t:T 
  &
  {!}\Delta ; Q_2\entails a:U 
  &
  \In(C)=Q_1 
  &
  \Out(C)=Q_2
}
\]
\end{mdframed}
\caption{The typing rules of Proto-Quipper.}
\label{trules}
\end{figure}

As a first illustration of the safety properties of the type system,
note that the $(\x\mbox{-i})$ rule ensures that $\lambda x. \p{x,x}$
cannot be given the type $\qubit\loli \qubit \x \qubit$.


\subsection{Circuit constructors}\label{ssec-circuit-cons}

As mentioned in Section 2, the reduction relation for Proto-Quipper is
defined in the presence of a \emph{circuit constructor}. This is a
device capable of performing certain basic circuit building
operations. It is not necessary to have a detailed description of the
inner workings of this device. In fact, all that is required for the
definition of Proto-Quipper's operational semantics is the existence
of some primitive operations. We now axiomatize these
operations. Their intuitive meaning will be explained following
Definition~\ref{circuit_constructor}.

\begin{definition}
\label{circuit_constructor}
A \emph{circuit constructor} consists of a pair of countable sets $\atuple{Q,S}$ 
together with the following maps:
\begin{itemize}
  \item $\mathtt{New}\from \pow_f(Q) \to S$,
  \item $\mathtt{In}\from S\to \pow_f(Q)$,
  \item $\mathtt{Out}\from S\to \pow_f(Q)$,
  \item $\mathtt{Rev}\from S \to S$,
  \item $\mathtt{Append}\from S\times S\times \finbij(Q) \to S \times \finbij(Q)$
\end{itemize}
satisfying the following conditions:
\begin{enumerate}
  \item $\mathtt{Rev}\circ\mathtt{Rev}=1_S$,
  \item $\mathtt{In}\circ\mathtt{Rev}= \mathtt{Out}$ and 
        $\mathtt{Out}\circ\mathtt{Rev}= \mathtt{In}$\label{in_out_rev},
  \item $\mathtt{In}\circ\mathtt{New} = \mathtt{Out}\circ\mathtt{New} =
    1_{\mathcal{P}_f(\mathcal{Q})}$,
  \item if $\mathtt{Append} (C,D,b)=(C',b')$ and 
    $b\from X \to \mathtt{In}(D)$ for some $X\subseteq \mathtt{out}(C)$, 
    then \label{Append_cond_x}
    \begin{enumerate}
      \item $\mathtt{In}(C') = \mathtt{In}(C)$,\label{Append_cond_2b}    
      \item $b'\from \mathtt{Out}(D)\to Y$ for some 
      $Y\subseteq \mathtt{Out}(C')$ and\label{Append_cond_2}
      \item $\mathtt{Out}(C')=Y\cupdot
      (\mathtt{Out}(C)\setminus X)$.\label{Append_cond_3}
    \end{enumerate}
\end{enumerate}
\end{definition}

If $\p{Q,S}$ is a circuit constructor, we call the elements of $S$
\emph{circuit states} and the elements of $Q$ \emph{wire identifiers}.
We now explain the intended meaning of these operations. An element
$C\in S$ is a quantum circuit, such as 
\[ C \quad=\quad \mp{.8}{\Qcircuit @C=1em @R=.7em {
& \lstick{q_1} & \gate{H} & \targ & \rstick{q_3} \qw \\
& \lstick{q_2} & \qw & \ctrl{-1} & \rstick{q_4.}\qw
}}
\]
Each circuit has a finite set of inputs and a finite set of outputs,
given by the functions $\mathtt{In}$ and $\mathtt{Out}$. For example,
$\mathtt{In}(C) = \s{q_1,q_2}$ and $\mathtt{Out}(C)=\s{q_3,q_4}$.
For $X\seq Q$, the circuit $\mathtt{New}(X)$ is the identity circuit
with inputs and outputs $X$; for example,
\[
\mathtt{New}(q_1,q_2,q_3)\quad=\quad~~
\mp{0.5}{\Qcircuit @C=1em @R=1.3em {
&\lstick{q_1}& \qw & \qw & \qw & \rstick{q_1}\qw \\
&\lstick{q_2}& \qw & \qw & \qw & \rstick{q_2}\qw \\
&\lstick{q_3}& \qw & \qw & \qw & \rstick{q_3.}\qw 
}}
\]
The operator $\mathtt{Rev}$ reverses a circuit, swapping its inputs
and outputs in the process. When $(C',b') = \mathtt{Append}(C,D,b)$,
the circuit $C'$ is obtained by appending the circuit $D$ to the end
of the circuit $C$. The function $b$ is used to specify along which
wires to compose $C$ and $D$ while the function $b'$ updates the wire
names post composition.  An illustration of this is given in
Figure~\hyperref[rep_unencap]{\ref*{rep_unencap}}. 

\begin{figure}[!ht]
\[
\mbox{
\Qcircuit @C=.5em @R=1.7em {
& & & & & 
     & & & & & & \ustick{b} & & &
     & & & 
     & & & & & & \ustick{b'} & & & \\
&\qw &\ustick{q_1}\qw &\qw &\qw &\multigate{4}{~~~C~~~} 
     &\qw &\qw &\ustick{q_1}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_1'}\qw
     &\qw &\qw &\multigate{2}{~~~D~~~} 
     &\qw &\qw &\ustick{p_1}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{p_1'}\qw \\
&\qw &\ustick{q_2}\qw &\qw &\qw &\ghost{~~~C~~~}       
     &\qw &\qw &\ustick{q_2}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_2'}\qw
     &\qw &\qw &\ghost{~~~D~~~} 
     &\qw &\qw &\ustick{p_2}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{p_2'}\qw \\     
&\qw &\ustick{q_3}\qw &\qw &\qw &\ghost{~~~C~~~}        
     &\qw &\qw &\ustick{q_3}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_3'}\qw
     &\qw &\qw &\ghost{~~~D~~~} 
     &\qw &\qw &\ustick{p_3}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{p_3'}\qw \\     
&\qw &\ustick{q_4}\qw &\qw &\qw &\ghost{~~~C~~~}       
     &\qw &\qw &\ustick{q_4}\qw &\qw &\qw &\qw &\qw &\qw &\qw
     &\qw &\qw &\qw 
     &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_4}\qw \\     
&\qw &\ustick{q_5}\qw &\qw &\qw &\ghost{~~~C~~~}     
     &\qw &\qw &\ustick{q_5}\qw &\qw &\qw &\qw &\qw &\qw &\qw
     &\qw &\qw &\qw 
     &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_5}\qw     
     \gategroup{2}{3}{6}{8}{3.3em}{--}
     \gategroup{2}{16}{4}{20}{3.3em}{--}     
     \gategroup{2}{23}{5}{24}{4.5em}{^\}}     
     \gategroup{2}{11}{5}{13}{4.5em}{^\}}     
}}
\]
\caption{A representation of $\mathtt{Append} (C,D,b)$.}
\label{rep_unencap}
\end{figure}

We note that the axiomatization of
Definition~\ref{circuit_constructor} does not mention the concept of a
{\em gate}. Indeed, any gate is a circuit, and thus a member of the
set $S$; conversely, any circuit can be used as a gate. In
Proto-Quipper, we simply assume that certain members of $S$ are
available as pre-defined constants, serving as ``elementary'' gates.
The operation of appending a gate to a circuit is subsumed 
by the more general operation of composing circuits. 

Proto-Quipper's quantum variables and circuit constants are supposed 
to be the syntactic representatives of a circuit constructor's wire 
identifiers. This idea is formalized in the following definition.

\begin{definition}
A circuit constructor $\atuple{Q,S}$ is \emph{adequate} if it can 
be equipped with bijections $\mathtt{Wire}\from \mathcal{Q} \to Q$ 
and $\mathtt{Name}\from \mathcal{C} \to S$ such that:
\[\In=\mathtt{Wire}' \circ\mathtt{In}\circ \mathtt{Name} 
~\mbox{ and }~ 
\Out=\mathtt{Wire}'\circ\mathtt{Out}\circ \mathtt{Name}
\]
where $\mathtt{Wire}'$ denotes the lifting of $\mathtt{Wire}^{-1}$ 
from $\mathcal{Q}$ to $\mathcal{P}(\mathcal{Q})$.
\end{definition}

\begin{remark}
\label{structure-transfer}
The existence of the bijections $\mathtt{Wire}$ and $\mathtt{Name}$ has 
the following consequences:
\begin{itemize}
  \item $\mathcal{C}$ can be equipped with an involution:
\[
(.)^{-1} = \mathtt{Name}\circ \mathtt{rev} \circ \mathtt{Name}^{-1}
           \from \mathcal{C}\to\mathcal{C}
\]
such that $\In(C^{-1})=\Out(C)$ and 
$\Out(C^{-1})=\In(C)$.
  \item If $t$ and $u$ are quantum data terms such that 
  $\bind(t,u)=\binding$, then we can define 
  $b = \mathtt{Wire}\circ \binding\circ \mathtt{Wire}^{-1}
  \in \finbij(Q)$.
\end{itemize}

From now on, we always assume an adequate circuit constructor. Moreover, we work 
under the simplifying assumptions that $\mathcal{Q}=Q$,
$\mathcal{C}=S$, $\mathtt{Wire}=1_Q$, and $\mathtt{Name}=1_S$.
\end{remark}


\subsection{Operational semantics}

We are now in a position to define Proto-Quipper's operational 
semantics.

\begin{definition}
Let $\atuple{Q,S}$ be an adequate circuit constructor. A 
\emph{closure} is a pair $[C,a]$ where $C\in S$, $a$ is a 
term and $\FQ(t)\subseteq\mathtt{Out}(C)$. 
\end{definition}

% We require $\FQ(t)\subseteq\mathtt{Out}(C)$ and not $\FQ(t)=\mathtt{Out}(C)$
% because the reduction is defined by recursion on the terms. For
% example, to reduce a pair, one must first reduce the left component
% in the context of the current circuit. If we required an equality 
% we could not simply do this.

\begin{definition}
The \emph{one-step reduction relation}, written $\to$, is defined 
on closures by the rules given in Tables~\hyperref[cong_rules]{\ref*{cong_rules}}, 
\hyperref[classical_rules]{\ref*{classical_rules}} 
and \hyperref[circ_gen_rules]{\ref*{circ_gen_rules}}. 
The \emph{reduction relation}, 
written $\to^*$, is defined to be the reflexive and transitive closure of $\to$.
\end{definition}

\begin{figure}[p]
\begin{mdframed}
\[
  \infer[(\rul{fun})]{[C,ab]\to[C',a'b]}{
    [C,a]\to[C',a']
  }
~~~~~~
  \infer[(\rul{arg})]{[C,vb]\to [C',vb']}{
    [C,b]\to [C',b']
  }
\]
\[
  \infer[(\rul{right})]{[C,\langle a,b\rangle]\to [C',\langle a,b'\rangle]}{
    [C,b]\to [C',b']
  }
~~~~~~
  \infer[(\rul{left})]{[C,\langle a,v\rangle]\to [C',\langle a',v\rangle]}{
    [C,a]\to [C',a']
  }
\]
\[
  \infer[(\rul{let})]{[C,\letin{\p{x,y}}{a}{b}]\to 
                [C', \letin{\p{x,y}}{a'}{b}]}{
    [C,a]\to [C',a']
  }
\]
\[
  \infer[(\rul{cond})]{[C, \ifthenelse{a}{b}{c}]\to [C', \ifthenelse{a'}{b}{c}]}{
    [C,a]\to [C',a']
  }
\]
\[
  \infer[(\rul{circ})]{[C, (t,D,a)]\to [C, (t,D',a')]}{
    [D,a]\to [D',a']
  }
\]
\end{mdframed}
\caption{The congruence rules.}
\label{cong_rules}
\end{figure}

\begin{figure}[p]
\begin{mdframed}
\[
  \infer[(\beta)]{[C,(\lambda x.a)v]\to [C, a[v/x]]}{}
\]
\[
  \infer[(\rul{pair})]{[C,\letin{\p{x,y}}{\p{v,w}}{a}]\to[C,a[v/x,w/y]]}{}
\]
\[
  \infer[(\rul{if}\mbox{-}\mathtt{F})]{[C,\ifthenelse{\mathtt{False}}{a}{b}] \to [C, b]}{}
\]
\[
  \infer[(\rul{if}\mbox{-}\mathtt{T})]{[C,\ifthenelse{\mathtt{True}}{a}{b}] \to [C, a]}{}
\]
\end{mdframed}
\caption{The classical rules.}
\label{classical_rules}
\end{figure}

\begin{figure}[p]
\begin{mdframed}
\[
  \infer[(\boxx)]{[C,\boxx^T(v)]\to [C,(t,D,vt)]}{
    \spec_{\FQ(v)}(T)=t
    &
    \mathtt{new}(\FQ(t))=D
  }
\]
\[
  \infer[(\unbox)]{[C,(\unbox\,(u,D,u'))v]\to [C',\binding'(u')]}{
    \bind(v,u)=\binding 
    &
    \mathtt{Append}(C,D,\binding) = (C',\binding') 
  }
\]
\[
  \infer[(\rev)]{[C,\rev\,(t,C,t')]\to [C,(t',C^{-1},t)]}{}
\]
\end{mdframed}
\caption{The circuit generating rules.}
\label{circ_gen_rules}
\end{figure}

The classical reduction rules and the congruence rules (except $(\rul{circ})$) 
are standard. They describe the usual call-by-value reduction strategy. 
The $(\rev)$ rule is straightforward. We briefly discuss the remaining 
rules. 

The $(\boxx)$ rule is to be understood as follows. To reduce a closure
of the form $[C, \boxx^T(v)]$, start by generating a specimen of type
$T$. Then apply the function $v$ on the input $t$ in the context of an
empty circuit of the appropriate arity.  By the $(\rul{circ})$
congruence rule, this computation will continue until a value is
reached, i.e., a term of the form $(t,D,t')$. Note that while this
computation is taking place, the state $C$ is not accessible. When a
value of the form $(t,D,t')$ is reached, the construction of $C$ can
resume. Note that it was necessary to know the type $T$ in order to
generate the appropriate specimen. This explains the choice of a
Church-style typing of the $\boxx$ operator. 

The $(\unbox)$ rule will first generate a binding from $v$ and the
input $u$ of $D$. Then, it will compose $C$ and $D$ along that binding
and update the names of the wire identifiers appearing in $u'$
according to $\binding'$. 

The recursive nature of the reduction rules explains why closures are 
not required to satisfy $\FQ(a)=\mathtt{Out}(C)$. The requirement that 
$\FQ(a)\subseteq \mathtt{Out}(C)$ is justified by the idea that a term 
should not affect a wire outside of $C$. But if we also asked for the 
opposite inclusion, it would not be possible to define a recursive
reduction in a straightforward way. For example, the reduction of a 
pair is done component-wise: to reduce $\p{a,b}$ one first reduces $b$. 
The simplest way to express this in terms of closures is to carry the 
whole circuit state along. This implies that if both $a$ and $b$ 
contain wire identifiers, then the equality $\FQ(a)=\mathtt{Out}(C)$ 
cannot be satisfied.

Proto-Quipper's reduction is non-probabilistic, in the sense that the 
right member of any reduction rule is a unique closure. The following 
proposition establishes that Proto-Quipper's reduction is moreover  
\emph{deterministic}.

\begin{proposition}
\label{determinicity}
If $[C,a]$ is a closure, then at most one reduction rule applies
to it.
\end{proposition}

\begin{proof}
By case distinction on $a$.
\end{proof}


% ----------------------------------------------------------------------
\clearpage
\section{Type safety}\label{sec-type-safety}

In this section, we establish that the core of  Proto-Quipper 
is a \emph{type safe} language. We follow \cite{WrFe94} in 
considering that a language is type safe if it enjoys the 
following two properties: 
\begin{description}
  \item[Subject Reduction:] This property guarantees 
  that the type of a term is stable under reduction.
  As a corollary, it also shows that if a term is 
  well-typed, then it never reduces to an ill-typed 
  term.
  \item[Progress:] This property shows that a 
  well-typed term never reaches an ``error state", 
  which is defined to be a closure $[C,t]$ to which 
  no reduction rule applies but such that 
  $t\notin \mathtt{Val}$. 
\end{description}
Note that the reduction relation is defined on closures 
but the typing rules apply to terms. We therefore extend 
the notions of typing judgement and validity to closures.

\begin{definition}
A \emph{typed closure} is an expression of the form:
\[
\Gamma;Q\entails [C,a]:A,(Q'|Q'').
\]
It is \emph{valid} if $\mathtt{In}(C)=Q'$ and $\mathtt{Out}(C)=Q,Q''$,
and $\Gamma;Q\entails a:A$ is a valid typing judgement.
\end{definition}

\subsection{Properties of the type system}

Before proving the Subject Reduction and Progress properties, we
record some properties of the type system, including the technical but
important \emph{Substitution Lemma}. Note that the typing rules
enforce a \emph{strict} linearity on variables and quantum
variables. In particular, if a quantum variable appears in the quantum
context of a valid typing judgement for a term $a$, then it must
belong to the free quantum variables of $a$.

\begin{lemma}~
\label{prop_type_syst}
\begin{enumerate}
  \item If $\Gamma; Q \entails a:A$ is valid, 
  then $Q=\FQ(a)$.\label{q_context}
  \item If $\Gamma,x:B;Q \entails a:A$ is valid, 
  and $x\notin \FV(a)$, then $B={!}B'$ and 
  $\Gamma;Q \entails a:A$ is valid.\label{unused_var}
  \item If $\Gamma; Q \entails a:A$ is valid, 
  then $\Gamma, {!}\Delta ; Q \entails a:A$ is valid.\label{weakening}
  \item If $\Gamma ; Q \entails a:A$ is valid, $\Delta <: \Gamma$
  and $A<:B$, then $\Delta ; Q \entails a:B$ is valid.\label{subtype}
\end{enumerate}
\end{lemma}

\begin{proof}
By induction on the corresponding typing derivation.
\end{proof}

\begin{lemma}
\label{specimen}
If $T$ is a quantum data type and $X$ is a finite subset of
$\mathcal{Q}$, then $\FQ(t)\entails \spec_X(T):T$ is valid.
\end{lemma}

\begin{proof}
We prove the Lemma by induction on $T$.
  \begin{itemize}
    \item If $T=1$, then $\spec_X(T)=*$ and we can use the $(\rul{unit})$ rule.
    \item If $T=\qubit$, then $\spec_X(T)=q$ for some quantum variable $q$ and we can 
          use the $(\rul{ax}_q)$ rule.
    \item If $T=T_1\x T_2$, then $\spec_X(T)=\p{t_1,t_2}$ where $t_1=\spec_X(T_1)$ 
          and $u=\spec_{X\cup \FQ(t_1)}(T_2)$. By the induction hypothesis, both 
          $\FQ(t_1)\entails t_1:T_1$ and $\FQ(t_2)\entails t_2:T_2$ are valid typing 
          judgements. We can therefore conclude by applying the $(\tensor\mbox{-i})$ rule.
  \end{itemize}
\end{proof}

\begin{lemma}
\label{binding_judgement}
If $\Gamma;Q \entails a:A$ is valid and $\binding$ is a 
binding such that $FQ(a)\subseteq\dom(\binding)$ 
then $\Gamma;\binding (Q) \entails \binding(a):A$ is valid.
\end{lemma}

\begin{proof}
By induction on the typing derivation of $\Gamma;Q \entails a:A$.
\end{proof}

\begin{lemma}
\label{context_value}
If $v\in\mathtt{Val}$ and $\Gamma;Q \entails v:{!}A$ is valid, 
then $Q=\emptyset$ and $\Gamma={!}\Delta$ for some $\Delta$.
\end{lemma}

\begin{proof}
By induction on the typing derivation of $\Gamma;Q \entails v:{!}A$. 
In the case of $(\rul{ax}_c)$, use Lemma~\hyperref[subtype_bang]{\ref*{subtyping_shape}(\ref*{subtype_bang})}.
\end{proof}

\begin{lemma}
\label{non_values}
If a term $a$ is not a value then it is of one 
of the following forms: 
\begin{compactitemize}
\item $(t,C,a')$ with $a'\notin \mathtt{Val}$, 
\item $\p{a_1,a_2}$ with $a_1\notin \mathtt{Val}$ or $a_2\notin
  \mathtt{Val}$, 
\item $\ifthenelse{a_1}{a_2}{a_3}$,
\item $\letin{\p{x,y}}{a_1}{a_2}$, or
\item $a_1a_2$.
\end{compactitemize}
\end{lemma}

\begin{proof}
Trivial, by the definition of terms and values.
\end{proof}

\begin{lemma}
\label{form_values}
A well-typed value $v$ is either a variable, a quantum variable, a constant or one 
of the following case occurs: 
\begin{compactitemize}
\item if it is of type ${!}^n\Circ(T,U)$, it is of the 
form $(t,C,u)$ with $t$ and $u$ values; 
\item if it is of type ${!}^n\bool$ it is either 
$\true$ or $\false$; 
\item if it is of type ${!}^n (A\x B)$, it is of the
form $\p{w,w'}$, with $w$ and $w'$ values; 
\item if it is of type ${!}^n1$, it is 
precisely the term $*$; 
\item if it is of type ${!}^n (A\loli B)$, it is a 
lambda-abstraction or a constant.
\end{compactitemize}
\end{lemma}

\begin{proof}
By induction on the typing derivation of $v$.
\end{proof}

\begin{corollary}
\label{typed_qd_term}
If $T$ is a quantum data type and $v$ is a well-typed value of type $T$ then $v$ is 
a quantum data term.
\end{corollary}

\begin{lemma}
{\bf (Substitution).}
\label{substitution}
If $v\in\mathtt{Val}$ and both $\Gamma',{!}\Delta;Q' \entails v:B$ and 
$\Gamma,{!}\Delta,x:B;Q \entails a:A$ are valid typing judgements, 
then $\Gamma,\Gamma',{!}\Delta;Q,Q' \entails a[v/x]:A$ is also valid.
\end{lemma}

\begin{proof}
Let $\pi_1$ and $\pi_2$ be the typing derivations  of 
$\Gamma,{!}\Delta,x:B;Q \entails a:A$ and  $\Gamma',{!}\Delta;Q' \entails v:B$ 
respectively. We prove the Lemma by induction on $\pi_1$.
\begin{itemize}
 \item If the last rule of $\pi_1$ is $(\rul{ax}_c)$ and $a=x$, then $\pi_1$ is
 \[
   \infer[(\rul{ax}_c)]{{!}\Delta, x:B;\emptyset\entails x:A}{
     B<:A
   }
 \]
 with $\Gamma=Q=\emptyset$. Then $a[v/x]=v$ and can conclude by applying 
 Lemma~\hyperref[subtype]{\ref*{prop_type_syst}.\ref*{subtype}} to $\pi_2$.
 \item If the last rule of $\pi_1$ is $(\rul{ax}_c)$ and $a=y\neq x$, then 
 $\pi_1$ is
 \[
   \infer[(\rul{ax}_c)]{{!}\Delta, x:{!}B',y:A';\emptyset\entails y:A}{
     A'<:A
   }
 \]
 with $B={!}B'$, $Q=\emptyset$ and $\Gamma =\s{y:A'}$ or $\Gamma=\emptyset$ 
 depending on whether or not $A'$ is duplicable. Therefore $v$ is a value of 
 type ${!}B'$ and by Lemma~\hyperref[context_value]{\ref*{context_value}}, 
 we know that $\Gamma'=Q'=\emptyset$. Since $a[v/x]=y$ and $x\notin \FV(y)$ 
 we can conclude by applying
 Lemma~\hyperref[unused_var]{\ref*{prop_type_syst}.\ref*{unused_var}} to $\pi_1$.
 \item If the last rule of $\pi_1$ is one of $(\rul{ax}_q)$, $(\rul{cst}_c)$, 
 $(\rul{unit})$, $(\top)$ and $(\bot)$, and $a$ is the corresponding constant, 
 then $x\notin \FV(a)$ and  $x$ must be declared of some type ${!}B'$.
 We can therefore reason as in the previous case. 
 \item If the last rule of $\pi_1$ is $(\lambda_1)$ and $a=\lambda y.b$, then $\pi_1$ is
  \[
   \infer[(\lambda_1)]{\Gamma,{!}\Delta,x:B;Q\entails \lambda y.b:A_1\loli A_2}{
     \deduce[]{\Gamma, {!}\Delta,x:B,y:A_1;Q \entails b:A_2}{
       \vdots
     }
   }
 \]
 with $A=A_1\loli A_2$. By the induction hypothesis, 
 $\Gamma, \Gamma',{!}\Delta,y:A_1;Q,Q' \entails b[v/x]:A_2$ is valid and we can conclude
 by applying $(\lambda_1)$.
 \item If the last rule of $\pi_1$ is $(\lambda_2)$ and $a=\lambda y.b$, 
 then $\pi_1$ is
 \[
  \infer[(\lambda_2)]{{!}\Delta, x:{!}B';\emptyset \entails \lambda y.b:~{!}^{n+1}(A_1\loli A_2)}{
    \deduce[]{{!}\Delta, x:{!}B',y:A_1;\emptyset \entails b:A_2}{
      \vdots
    }
  }
 \]
 with $A={!}^{n+1}(A_1\loli A_2)$ and $B={!}B'$. Hence $v$ is a value of type ${!}B'$ and  
 by Lemma~\hyperref[context_value]{\ref*{context_value}}, we know that
 $\Gamma'=Q'=\emptyset$. The induction hypothesis therefore implies that
 ${!}\Delta,y:A_1;\emptyset \entails b[v/x]:A_2$ is valid and we can conclude
 by applying $(\lambda_2)$.
 \item If the last rule of $\pi_1$ is $(\rul{app})$, and $a=ca'$, then $\pi_1$ can 
 be of one of three forms depending on $B$. If $B$ is duplicable, then $\pi_1$ is
 \[
 \infer[(\rul{app})]{\Gamma_1,\Gamma_2,{!}\Delta,x:{!}B';Q_1,Q_2\entails ca':A}{
    \deduce[]{\Gamma_1, x:{!}B',{!}\Delta;Q_1\entails c:A'\loli A}{
      \vdots
    }
    &
    \deduce[]{\Gamma_2, x:{!}B',{!}\Delta ;Q_2\entails a':A' }{
      \vdots
    }
 }
 \]
 with $B={!}B'$. Using 
 Lemma~\hyperref[context_value]{\ref*{context_value}} again, we 
 know that $\Gamma'=Q'=\emptyset$. The induction hypothesis therefore 
 implies that $\Gamma_1,{!}\Delta;Q_1\entails c[v/x]:A'\loli A$ and 
 $\Gamma_2,{!}\Delta ;Q_2\entails a'[v/x]:A'$ are valid and we can conclude 
 by applying $(\rul{app})$. If, instead, $B$ is non-duplicable, then the declaration 
 $x:B$ can only appear in one branch of the derivation. This means that $\pi_1$ 
 is either 
  \[
 \infer[(\rul{app})]{\Gamma_1,\Gamma_2,{!}\Delta,x:B;Q_1,Q_2\entails ca':A}{
    \deduce[]{\Gamma_1, x:B,{!}\Delta;Q_1\entails c:A'\loli A}{
      \vdots
    }
    &
    \deduce[]{\Gamma_2, {!}\Delta ;Q_2\entails a':A'}{
      \vdots
    }     
 }
 \]
 or
  \[
 \infer[(\rul{app}).]{\Gamma_1,\Gamma_2,{!}\Delta,x:B;Q_1,Q_2\entails ca':A}{
    \deduce[]{\Gamma_1, {!}\Delta;Q_1\entails c:A'\loli A}{ 
      \vdots
    }
    &
    \deduce[]{\Gamma_2, x:B,{!}\Delta ;Q_2\entails a':A'}{
      \vdots
    }     
 }
 \]
 In the first case, the induction hypothesis implies that 
 $\Gamma_1,\Gamma' {!}\Delta;Q_1,Q'\entails c[v/x]:A'\loli A$ is valid and 
 we can conclude by $(\rul{app})$. The second case is treated analogously.
 \item If the last rule of $\pi_1$ is on of $(\x\mbox{-i})$, $(\x\mbox{-e})$ 
 and $(\rul{if})$, and $a$ is the corresponding term, then we can reason as above
 by considering in turn the case where $B$ is duplicable and the case where
 $B$ is non-duplicable.
 \item If the last rule of $\pi_1$ is $(\rul{circ})$, and $a=(t,C,a')$, then 
 $\pi_1$ is
 \[
 \infer[(\rul{circ})]{{!}\Delta,x:{!}B';\emptyset \entails (t,\mathbf{c},a'):{!}^n\Circ(T,U)}{
    \deduce[]{Q_1\entails t:T}{
      \vdots
    }    
    &
    \deduce[]{{!}\Delta,x:{!}B' ; Q_2\entails a':U}{
      \vdots
    }     
    &
    \In(C)=Q_1 
    &
    \Out(C)=Q_2
 }
 \]
 with $A={!}^n\Circ(T,U)$ and $B={!}B'$ for some types $T$, $U$ and $B'$. Using  
 Lemma~\hyperref[context_value]{\ref*{context_value}} again, we know 
 that $\Gamma'=Q'=\emptyset$. The induction hypothesis therefore implies that
 ${!}\Gamma; Q_2\entails a'[v/x]:U$ is valid and we can conclude
 by applying $(\rul{circ})$.
\end{itemize}
\end{proof}


\subsection{Subject reduction}

\begin{lemma}
\label{Inwires}
If $[C,a]\to[C',a']$ then $\mathtt{In}(C)=\mathtt{In}(C')$.
\end{lemma}

\begin{proof}
By induction on the derivation of $[C,a]\to[C',a']$. 
In all but the $(\unbox)$ case, the result follows either from the induction 
hypothesis or from the fact that $C=C'$. In the $(\unbox)$ case, use 
Definition~\hyperref[Append_cond_2b]{\ref*{circuit_constructor}(\ref*{Append_cond_2b})}.
\end{proof}

\begin{theorem}
{\bf (Subject Reduction).}
\label{thm-subject-red}
If $\Gamma;\FQ(a)\entails [C,a]:A,(Q'|Q'')$ is a valid typed closure 
and $[C,a]\to [C',a']$, then $\Gamma;\FQ(a')\entails [C',a']:A,(Q'|Q'')$ is 
a valid typed closure.
\end{theorem}

\begin{proof}
We prove the theorem by induction on the derivation of the reduction 
 $[C,a]\to[C',a']$. In each case, we start by reconstructing 
the unique typing derivation $\pi$ of $\Gamma;\FQ(a)\entails a:A$ and we use 
it to prove that $\Gamma;\FQ(a')\entails [C',a']:A,(Q'|Q'')$ is valid. 
By Lemma~\hyperref[Inwires]{\ref*{Inwires}} we never need to 
verify that $\mathtt{In}(C')=Q'$ so that we only need to show:
\begin{itemize}
  \item $\mathtt{Out}(C')=\FQ(a'),Q''$ and
  \item $\Gamma;\FQ(a')\entails a':A$ is valid.
\end{itemize}
Throughout the proof, we write $IH(\pi)$ to denote the proof obtained by applying 
the induction hypothesis to $\pi$.

\begin{description}
\item[Congruence rules:] These rules are treated uniformly. We illustrate the 
$(\rul{fun})$ and $(\rul{circ})$ cases.
\begin{itemize}
  \item $(\rul{fun})$: the reduction rule is
  \[
    \infer[]{[C,cb]\to[C',c'b]}{
      [C,c]\to[C',c']
    }
  \]
  with $a=cb$ and $a'=c'b$. The typing derivation $\pi$ is therefore
  \[
    \infer[]{\Gamma_1,\Gamma_2, {!}\Delta;\FQ(c),\FQ(b)\entails cb:A}{
      \deduce[]{\Gamma_1, {!}\Delta;\FQ(c)\entails c:B\loli A}{
        \vdots~\pi_1
      } 
      &
      \deduce[]{\Gamma_2, {!}\Delta ;\FQ(b)\entails b:B}{
        \vdots~\pi_2
      } 
    }
  \]
  and $\Gamma_1,\Gamma_2;\FQ(c),\FQ(b)\entails [C, cb],(Q'|Q'')$ is valid.
  It follows that $\Gamma_1, {!}\Delta;\FQ(c)\entails [C,c]:B\loli A,(Q'|\FQ(b),Q'')$ 
  is valid and, by the induction hypothesis, this implies that 
  $\Gamma_1, {!}\Delta;\FQ(c')\entails [C',c']:B\loli A,(Q'|\FQ(b),Q'')$ is also valid.
  In particular, it follows that $\mathtt{Out}(C')=\FQ(c'),\FQ(b),Q''$. This, 
  together with the following typing derivation,
  \[
    \infer[]{\Gamma_1,\Gamma_2, {!}\Delta;\FQ(c'),\FQ(b)\entails c'b:A}{
      \deduce[]{\Gamma_1, {!}\Delta;\FQ(c')\entails c':B\loli A}{
        \vdots~IH(\pi_1)
      } 
      &
      \deduce[]{\Gamma_2, {!}\Delta ;\FQ(b)\entails b:B}{
        \vdots~\pi_2
      } 
    }
  \]  
  shows that $\Gamma_1,\Gamma_2, {!}\Delta;\FQ(c'),\FQ(b)\entails [C',c'b]:A,(Q',Q'')$ 
  is valid.
  \item $(\rul{circ})$: the reduction rule is
  \[
    \infer[(\rul{circ})]{[C, (t,D,b)]\to [C, (t,D',b')]}{
      [D,b]\to [D',b']
    }
  \]  
  with $a=(t,D,b)$ and $a'=(t,D',b')$. The typing derivation $\pi$ is therefore
  \[
  \infer[]{{!}\Delta;\emptyset\entails (t,D,b):{!}^n\Circ(T,U)}{
    \deduce[]{\FQ(t)\entails t:T}{
      \vdots~\pi_1
    } 
    &
    \deduce[]{{!}\Delta ; \FQ(b)\entails b:U}{
      \vdots~\pi_2
    }
    &
    \deduce[]{\In(D)=\FQ(t)}{
      \Out(D)=\FQ(b)
    }
  }
  \]  
  and ${!}\Delta ; \emptyset \entails [C,(t,D,b)]:{!}^n\Circ(T,U),(Q'|Q'')$ is valid. 
  Disregarding $\pi_1$, it follows from the assumptions in the above rule 
  that ${!}\Delta ; \FQ(b)\entails [D,b]:U, (\FQ(t)|\emptyset)$ is valid and, 
  by the induction hypothesis, this implies that 
  ${!}\Delta,\FQ(b')\entails [D',b']:U,(\FQ(t)|\emptyset)$ is also valid.
  This, together with the following typing derivation,
  \[
  \infer[.]{{!}\Delta;\emptyset\entails (t,D,b'):{!}^n\Circ(T,U)}{
    \deduce[]{\FQ(t)\entails t:T}{
      \vdots~\pi_1
    } 
    &
    \deduce[]{{!}\Delta ; \FQ(b')\entails b':U}{
      \vdots~IH(\pi_2)
    }
    &
    \deduce[]{\In(D')=\FQ(t)}{
      \Out(D')=\FQ(b')
    }
  }  
  \]
  shows that ${!}\Delta;\emptyset\entails [C,(t,D',b')] :{!}^n\Circ(T,U),(Q'|Q'')$ 
  is valid.
\end{itemize}
\item[Classical rules:] These rules are also treated uniformly, we illustrate 
the $(\beta)$ case.
\begin{itemize}
  \item $(\beta)$: the reduction rule is
  \[
    \infer[(\beta)]{[C,(\lambda x.b)v]\to [C, b[v/x]]}{}
  \]  
  with $a=(\lambda x.b)v$ and $a'=b[v/x]$. The typing derivation $\pi$ is 
  therefore
  \[
    \infer[]{\Gamma_1,\Gamma_2,{!}\Delta;\FQ(b),\FQ(v)\entails (\lambda x.b)v:A}{
      \infer[]{\Gamma_1,{!}\Delta;\FQ(b)\entails \lambda x.b:B\loli A}{
        \deduce[]{\Gamma_1,{!}\Delta,x:B;\FQ(b) \entails b:A}{
          \vdots~\pi_1
        }
      }
      &
      \deduce[]{\Gamma_2,{!}\Delta;\FQ(v)\entails v:B}{
        \vdots~\pi_2
      }      
    }
  \]  
  and $\Gamma_1,\Gamma_2,{!}\Delta;\FQ(b),\FQ(v)\entails [C,(\lambda x.b)v]:A,(Q'|Q'')$ 
  is valid. By Lemma \hyperref[substitution]{\ref*{substitution}}, we know that
  $\Gamma_1,\Gamma_2,{!}\Delta;\FQ(b),\FQ(v)\entails b[v/x]:A$ is a valid typing 
  judgement which implies that 
  \[ \Gamma_1,\Gamma_2,{!}\Delta;\FQ(b),\FQ(v)\entails
  [C,b[v/x]]:A,(Q'|Q'')\]
  is a valid
  typed closure.
\end{itemize}
\item[Circuit generating rules:] These rules represent the most interesting cases. 
We treat them individually.
\begin{itemize}
  \item $(\boxx)$: the reduction rule is
  \[
  \infer[]{[C,\boxx^T(v)]\to [C,(t,D,vt)]}{
    \spec(T)=t
    &
    \mathtt{new}(\FQ(t))=D
  }
  \]
  with $a=\boxx^T(v)$ and $a'=(t,D,vt)$. Since $v$ is a value, we know by  
  Lemma~\hyperref[context_value]{\ref*{context_value}} that the typing 
  derivation $\pi$ is
  \[
  \infer[]{{!}\Delta;\emptyset\entails \boxx^T(v):{!}^n\Circ(T,U)}{
    \infer[]{{!}\Delta;\emptyset \entails \boxx^T:{!}(T\loli U)\loli {!}^n\Circ(T,U)}{
    }   
    &
    \deduce[]{{!}\Delta ;\emptyset\entails v:{!}(T\loli U)}{
     \vdots ~\pi_1
    }
  }
  \]
  and ${!}\Delta;\emptyset\entails [C,\boxx^T(v)]:{!}^n\Circ(T,U),(Q'|Q'')$ is valid.
  By Lemma \hyperref[specimen]{\ref*{specimen}}, there exists 
  a typing derivation $\pi_2$ of $\FQ(t)\entails t:T$ and applying 
  Lemma~\hyperref[subtype]{\ref*{prop_type_syst}.\ref*{subtype}}
  to $\pi_1$ we get a derivation $\pi_1'$ of ${!}\Delta ;\emptyset\entails v:T\loli U$.
  We can therefore construct the following derivation $\tau$:
  \[
  \infer[]{{!}\Delta;\FQ(t)\entails vt : U}{
    \deduce[]{{!}\Delta ;\emptyset\entails v:T\loli U}{
      \vdots ~\pi_1'
    }
    &
    \deduce[]{{!}\Delta;\FQ(t)\entails t:T}{
      \vdots ~\pi_2'
    }
  }
  \]
  where $\pi_2'$ is obtained from $\pi_2$ by Lemma 
  \hyperref[weakening]{\ref*{prop_type_syst}.\ref*{weakening}}.
  Moreover, since $\FQ(vt)=\FQ(t)=\mathtt{Out}(D)=\mathtt{In}(D)$, 
  we have:
  \[
  \infer[.]{{!}\Delta;\emptyset \entails (t,D,vt):{!}^n\Circ(T,U)}{
    \deduce[]{\FQ(t)\entails t:T}{
      \vdots~\pi_2
    }
    &
    \deduce[]{{!}\Delta ; \FQ(vt)\entails vt:U}{
      \vdots~\tau
    } 
    &
    \deduce[]{\In(D)=\FQ(t) }{
      \Out(D)=\FQ(vt)
    }
  }
  \]  
  Hence ${!}\Delta ;\emptyset \entails [C,(t,D,vt)]:{!}^n\Circ(T,U) (Q'|Q'')$ is 
  a valid typed closure.
  \item $(\unbox)$ the reduction rule is
  \[
    \infer[(\unbox)]{[C,(\unbox\,(t,D,t'))v]\to [C',\binding'(t')]}{
      \bind(v,t)=\binding 
      &
      \mathtt{Append}(C,D,\binding) = (C',\binding') 
    }
  \]
  with $a=(\unbox\,(t,D,t'))v$ and $a'=\binding'(t')$. 
  To reconstruct the typing derivation $\pi$, first note 
  that we have the following derivation $\pi_1$ of    
  ${!}\Delta;\emptyset\entails \unbox\,(t,D,t'):T\loli U$
  \begin{footnotesize}
  \[
    \infer[]{{!}\Delta;\emptyset\entails \unbox\,(t,D,t'):T\loli U}{
      \infer[]{{!}\Delta;\emptyset \entails \unbox:\Circ(T,U)\loli (T\loli U)}{
      }   
      &
      \infer[]{{!}\Delta ;\emptyset\entails (t,D,t'):\Circ(T,U)}{
        \deduce[]{\FQ(t)\entails t:T}{
          \vdots ~\pi_1^1
        }
        &
        \deduce[]{{!}\Delta;\FQ(t')\entails t':U}{
          \vdots ~\pi_1^2     
        }
      }
    }
    \]
    \end{footnotesize} 
  with $\In(D)=\FQ(t)$, $\Out(D)=\FQ(t')$. We can then use $\pi_1$ 
  to rebuild $\pi$ as follows:
  \begin{footnotesize}
  \[
  \infer[]{{!}\Delta; \FQ(v)\entails (\unbox\,(t,D,t'))v :U}{
    \infer[]{{!}\Delta;\emptyset\entails \unbox\,(t,D,t'):T\loli U}{
      \vdots~\pi_1            
    }
    &
    \infer[]{{!}\Delta ; \FQ(v)\entails v:T}{
      \vdots~\pi_2
    }
  }
  \]
  \end{footnotesize} 
  and the typed closure
  \[
  {!}\Delta; \FQ(v) \entails [C,(\unbox\,(t,D,t'))v] :U,(Q'|Q'')
  \] 
  is valid. In the conclusion of $\pi_2$, all the 
  term variables are declared of a duplicable type. This 
  follows from Corollary \ref{typed_qd_term} and 
  Lemma~\hyperref[unused_var]{\ref*{prop_type_syst}.\ref*{unused_var}}. 
  By Definition~\hyperref[Append_cond_2]{\ref*{circuit_constructor}
  (\ref*{Append_cond_2})}, we know that $\FQ(t')\subseteq\dom(\binding')$. 
  We can therefore apply Lemma~\hyperref[binding_judgement]
  {\ref*{binding_judgement}} to $\pi_1^2$ to get a typing 
  derivation $\tau$ of 
  \[
  {!}\Delta;\FQ(\binding(t'))\entails \binding(t'):U.
  \]
  Now by 
  Definition~\hyperref[Append_cond_3]{\ref*{circuit_constructor}.\ref*{Append_cond_3}} 
  we have:
  \[
  \begin{array}{rcl}
  \mathtt{Out}(C') & = & \binding(\mathtt{Out}(D)), (\mathtt{Out}(C)\setminus\binding^{-1}(\mathtt{In}(D))) \\
                   & = & \binding(\FQ(t')) , ((Q'',\FQ(v))\setminus \binding^{-1}(\FQ(t))) \\
                   & = & \FQ(\binding(t')) , ((Q'',\FQ(v))\setminus \FQ(v)) \\
                   & = & \FQ(\binding(t')),Q''.                   
  \end{array}
  \]
  Hence ${!}\Delta; \FQ(\binding(t'))\entails [C',\binding(t')] :U,(Q'|Q'')$  is valid.
  \item $(\rev)$ the reduction rule is
  \[
    \infer[(\rev)]{[C,\rev\,(t,D,t')]\to [C,(t',D^{-1},t)]}{}
  \]
  with $a=\rev\,(t,D,t')$ and $a'=(t',D^{-1},t)$. The typing derivation $\pi$ 
  is therefore
  \begin{footnotesize}
  \[
  \infer[]{{!}\Delta;\emptyset\entails \rev\,(t,D,t'):{!}^n\Circ(U,T)}{
    \infer[]{{!}\Delta;\emptyset \entails \rev:\Circ(T,U)\loli {!}^n\Circ(U,T)}{
    }   
    &
    \infer[]{{!}\Delta ;\emptyset\entails (t,D,t'):\Circ(T,U)}{
      \deduce[]{\FQ(t)\entails t:T}{
        \vdots ~\pi_1
      }
      &
      \deduce[]{{!}\Delta;\FQ(t')\entails t':U}{
        \vdots ~\pi_2     
      }
    }
  }
  \]
  \end{footnotesize}  
  with $\In(D)=\FQ(t)$, $\Out(D)=\FQ(t')$ and 
  ${!}\Delta;\emptyset\entails \rev\,(t,D,t'):{!}^n\Circ(T,U),(Q'|Q'')$ is 
  valid. Now note that since $t'$ is a quantum data term, it contains no variables. 
  Applying Lemma~\hyperref[unused_var]{\ref*{prop_type_syst}.\ref*{unused_var}} 
  to $\pi_2$ repeatedly we therefore get a derivation $\pi_2'$ of 
  $\FQ(t')\entails t':U$. Moreover, by applying
  Lemma~\hyperref[weakening]{\ref*{prop_type_syst}.\ref*{weakening}} to $\pi_1$ 
  we get a typing derivation $\pi_1'$ of ${!}\Delta ,\FQ(t)\entails t:T$.
  Since, by 
  Remark~\hyperref[structure-transfer]{\ref*{structure-transfer}}, 
  we have $\Out(D^{-1})=\In(D)=t$ and $\In(D^{-1})=\Out(D)=t'$, we can construct 
  the following typing derivation:
  \[
  \infer[]{{!}\Delta ;\emptyset\entails (t',D^{-1},t):\Circ(U,T)}{
    \deduce[]{\FQ(t')\entails t':U}{
      \vdots ~\pi_2'
    }
    &
    \deduce[]{{!}\Delta;\FQ(t)\entails t:T}{
      \vdots ~\pi_1'     
    }
    &
    \deduce[]{\In(D^{-1})=\FQ(t')}{
      \Out(D^{-1})=\FQ(t')
    }
  }  
  \]
  Hence ${!}\Delta;\emptyset\entails (t',D,t):{!}^n\Circ(T,U),(Q'|Q'')$ 
  is valid.    
\end{itemize}
\end{description}
\end{proof}

\begin{corollary}
If $\Gamma;\FQ(a)\entails [C,a]:A,(Q'|Q'')$ is a valid typed closure 
and $[C,a]\to^* [C',a']$, then $\Gamma;\FQ(a')\entails [C',a']:A,(Q'|Q'')$ 
is also a valid typed closure.
\end{corollary}

\begin{proof}
By induction on the length of the reduction sequence. The base case is 
provided by Theorem~\hyperref[thm-subject-red]{\ref*{thm-subject-red}}
\end{proof}

The above formulation of Subject Reduction explains why a typed closure contains 
information about the input and output wires of the circuit state. Indeed, 
Subject Reduction now guarantees (1) that the input wires of a circuit 
remain unchanged through reduction and (2) that a term can only affect 
wires whose identifiers are among its quantum variables.

\subsection{Progress}

\begin{theorem}
{\bf (Progress).}
If $\FQ(a)\entails [C,a]:A,(Q'|Q'')$ is a valid typed closure then either 
$a\in\mathtt{Val}$ or there exists a closure $[C',a']$ such that 
$[C,a]\to [C',a']$.
\end{theorem}

First, note that the Progress property is stated for a typed closure
whose typing context is empty. This is because the property is not
expected to hold if we allow for a non-empty typing context. Indeed,
it is easy to see that there are well-typed, non-closed closures such
as $[C,xy]$, which are neither values nor reduce. 
We now prove the theorem.

\begin{proof}
We prove the theorem by induction on the typing derivation $\pi$ of 
$\FQ(a)\entails a:A$. If $a$ is a value then there is nothing 
to prove. If $a$ is not a value, then by 
Lemma~\hyperref[non_values]{\ref*{non_values}} there are 5 cases to consider. 
In each case we show that $[C,a]$ is reducible in the sense that there exists a 
closure  $[C,b]$ such that $[C,a]\to[C,b]$
\begin{enumerate}
  \item If $a=(t,D,a')$ with $a'\notin \mathtt{Val}$, then the typing derivation 
  $\pi$ is:
  \[
  \infer[.]{\emptyset\entails (t,D,a'):\Circ(T,U)}{
    \deduce[]{\FQ(t)\entails t:T}{
      \vdots ~\pi_1
    }
    &
    \deduce[]{\FQ(a')\entails a':U}{
      \vdots ~\pi_2     
    }
    &
    \deduce[]{\In(D)=\FQ(t)}{
      \Out(D)=\FQ(a')
    }
  }   
  \]
  The typed closure 
  \[
  \begin{array}{rcl}
  \FQ(a') & \entails & [D,a']:U,(\FQ(t)|\emptyset)
  \end{array}
  \]
  is therefore valid. Since $a'$ 
  is not a value, the induction hypothesis implies that there exists $a''$ such 
  that $[D,a']\to [D',a'']$ and $[C,(t,D,a')]$ therefore reduces to 
  $[C,(t,D',a'')]$ by the $(\rul{circ})$ reduction rule.
  \item If $a=\p{a_1,a_2}$ with $a_1\notin \mathtt{Val}$ or $a_2\notin \mathtt{Val}$,
  then the typing derivation $\pi$ is:
  \[
  \infer[.]{\FQ(a_1),\FQ(a_2)\entails \p{a_1,a_2}:{!}^n(A_1\x A_2)}{
    \deduce[]{\FQ(a_1)\entails a_1:{!}^nA_1}{
      \vdots~\pi_1
    }
    & 
    \deduce[]{\FQ(a_2)\entails a_2:{!}^nA_2}{
      \vdots~\pi_2
    }
  }
  \] 
  The typed closures 
  \[
  \begin{array}{rcl}
  \FQ(a_1) & \entails & [C,a_1]:{!}^nA_1,(Q'|\FQ(a_2),Q'')\\
  \FQ(a_2) & \entails & [C,a_2]:{!}^nA_1, (Q'|\FQ(a_1),Q'')
  \end{array}
  \]
  are therefore both valid. 
  Now if $a_2\notin\mathtt{Val}$, then by the induction hypothesis 
  $[C,a_2]\to[C',a_2']$. Hence $[C,\p{a_1,a_2}]$ reduces to $[C',\p{a_1,a_2'}]$ 
  by the $(\rul{right})$ reduction rule.
  If on the other hand $a_2\in\mathtt{Val}$, then it must be the case that $a_1\notin\mathtt{Val}$ 
  and we can conclude by reasoning analogously that $[C,\p{a_1,a_2}]$ reduces to 
  some $[C',\p{a_1',a_2}]$ by the $(\rul{left})$ reduction rule.. 
  \item If $a=\ifthenelse{a_1}{a_2}{a_3}$, then the typing derivation $\pi$ is:
  \[
  \infer[.]{\FQ(a_1),Q\entails \ifthenelse{a_1}{a_2}{a_3}:A}{
    \deduce[]{\FQ(a_1)\entails a_1:\bool }{
      \vdots~\pi_1
    }
    &
    \deduce[]{Q \entails a_2:A}{
      \vdots~\pi_2
    }    
    &
    \deduce[]{Q \entails a_3:A}{
      \vdots~\pi_3
    }    
  }
  \]  
  The typed closure
  \[
  \begin{array}{rcl}
  \FQ(a_1) & \entails & [C,a_1]:\bool,(Q'|\FQ(a_2),\FQ(a_3),Q'')
  \end{array}
  \]
  is therefore valid. Now if $a_1\notin\mathtt{Val}$, then by the induction hypothesis 
  $[C,a_1]\to[C',a_1']$ and thus $[C,\ifthenelse{a_1}{a_2}{a_3}]$ can
  be seen to reduce
  to $[C',\ifthenelse{a_1'}{a_2}{a_3}]$ by the $(\rul{cond})$ reduction rule. 
  If on the other hand $a_1\in\mathtt{Val}$, then by 
  Lemma~\hyperref[form_values]{\ref*{form_values}} either $a_1=\true$ or $a_1=\false$. 
  Thus $[C,\ifthenelse{a_1}{a_2}{a_3}]$ reduces either to $[C,a_2]$ by the 
  $(\rul{if}\mbox{-}\mathtt{T})$ reduction rule or 
  to $[C,a_3]$ by the $(\rul{if}\mbox{-}\mathtt{F})$ reduction rule.
  \item If $a=\letin{\p{x,y}}{a_1}{a_2}$, then we can reason as above to show that 
  if $a_1$ is not a value, then the $(\rul{let})$ congruence rule applies and that if 
  $a$ is a value then Lemma~\hyperref[form_values]{\ref*{form_values}} 
  guarantees that the $(\rul{pair})$ rule applies.
  \item If $a=a_1a_2$ then the typing derivation $\pi$ is: 
  \[
    \infer[.]{\FQ(a_1),\FQ(a_2)\entails a_1a_2:A}{
      \deduce[]{\FQ(a_1)\entails a_1:B\loli A}{
        \vdots~\pi_1
      }
      &
      \deduce[]{\FQ(a_2)\entails a_2:B}{
        \vdots~\pi_2
      }      
    }
  \]  
  The typed closures
  \[
  \begin{array}{rcl}
  \FQ(a_1) & \entails & [C,a_1]:B\loli A,(Q'|\FQ(a_2),Q'')\\
  \FQ(a_2) & \entails & [C,a_2]:B, (Q'|\FQ(a_1),Q'')
  \end{array}
  \]
  are therefore valid. There are three cases to treat.
  \begin{itemize}
    \item If $a_1\notin\val$, then $[C,a_1a_2]\to[C',a_1'a_2]$
    by the induction hypothesis and the $(\rul{fun})$ rule.
    \item If $a_1\in\val$ and $a_2\notin\mathtt{Val}$, then 
    $[C,a_1a_2]\to[C',a_1a_2']$ by the induction hypothesis and 
    the $(\rul{arg})$ rule.
    \item If $a_1,a_2\in\val$ then by 
    Lemma~\hyperref[form_values]{\ref*{form_values}}, $a_1$ is either 
    an abstraction or a constant. In each case $[C,a_1a_2]$ reduces 
    by the appropriate rule among $(\beta)$, $(\boxx)$, $(\unbox)$ 
    and $(\rev)$. 
  \end{itemize}
\end{enumerate}
\end{proof}

% ----------------------------------------------------------------------
\clearpage
\section{Type inference}\label{sec-inference}

In this section, we describe the type inference algorithm 
for Proto-Quipper. We detail the algorithm and prove its 
correctness for a fragment of the language and explain, 
at the end of the section, how to extend it.

\input{algorithm.tex}


% ----------------------------------------------------------------------
\clearpage
\section{Language extensions}
\label{sec-extensions}

The implementation of Proto-Quipper provides all of the features of
Core Proto-Quipper described in Sections~\ref{sec-core} and
{\ref{sec-type-safety}}, and also includes the type inference
algorithm of Section~\ref{sec-inference}. The implementation also
includes some additional features that are not part of Core
Proto-Quipper. These extensions are provided for the convenience of
the programmer, but are not yet formalized. This means that the proofs 
of type-safety for these extensions of the core language are 
currently under development. We briefly describe these features 
here. Further explanations and sample code can be found in the 
user guide of Section \ref{sec-user-guide}.

\subsection{Polymorphism} 

Our implementation of Proto-Quipper is equipped with a polymorphic
$\textit{let}$ binder. This means that expressions such as:
\[
\letin{x}{a}{b}
\]
are valid expressions of the syntax (note that $a$ is not required
to be a pair). Moreover, such $\textit{let}$ expressions are not
simply syntactic sugar for $(\lambda x.b)a$. In fact, the
expression will not be attributed a type but rather a \emph{type
  scheme} (also known as a {\em polymorphic type}), which
describes all possible types of this expression.  Type schemas
follow the pattern:
$$\forall \vec{\alpha}~ \vec{i}, \lset \Rightarrow T$$
This is to be interpreted as: 
\begin{quote} For all type variables
  $\vec{\alpha'}$ and flag variables $\vec{i'}$ satisfying the
  constraints $\lset[\vec{\alpha'} / \vec{\alpha}, \vec{i'}/
  \vec{i}]$, the expression ``$a$" can have the type
  $T[\vec{\alpha'} / \vec{\alpha}, \vec{i'}/ \vec{i}]$.
\end{quote}
This is illustrated by the following constraint typing rule:
\begin{prooftree}
  \AxiomC{$\vec{\alpha'}, \vec{i'} \notin \Delta, (\forall \vec{\alpha} ~\vec{i}, \lset_T \Rightarrow T)$} \noLine
  \UnaryInfC{$\lset = \lset_T[\vec{\alpha'}/\vec{\alpha}, \vec{i'}/\vec{i}] \cup
    \{ 1 \le I, T[\vec{\alpha'}/\vec{\alpha}, \vec{i'}/\vec{i}] \prec: U \}$}
  \RightLabel{$(\rul{ax}.S)$}
  \UnaryInfC{${!}^I \Delta, x: ~(\forall \vec{\alpha} ~\vec{i}, \lset_T \Rightarrow T) \vdash_\lset x : U ~|_{\{\vec{\alpha'}, \vec{i'}\}}$}
\end{prooftree}
For example, in the term 
\[ \letin{f}{\lambda x.x}{b},
\]
the expression $f$ will be given the type scheme 
\[ \forall \alpha, \beta,k,n,m,\s{\alpha \prec:\beta, m\leq n} \imp {!}^k({!}^n\alpha\loli{!}^m\beta),
\]
Some possible types for this expressions are $A\loli A$, ${!}A\loli
A$, ${!}A\loli{!}A$, ${!}(A\loli B)\loli ({!}A\loli B)$, and so on. 
Since $f$ can be typed differently at each calls site, a term such as
\[ \letin{f}{\lambda x.x}{f(f)}
\]
is typeable in polymorphic Proto-Quipper.

\subsection{Algebraic types, integers and lists}

Our implementation of Proto-Quipper provides built-in types of
integers and lists. These are accompanied by basic functions such as
equality testing, comparison, etc. Moreover, Proto-Quipper supports
user-definable recursive types (in fact, lists are a special case of
this, and are defined using this general mechanism).

\subsection{Recursion}

Our implementation of Proto-Quipper allows recursive function
definitions. To do this, we add the following term constructor to the
language:
\[
\letrecin{a\,x}{b}{c}
\]    
together with the associated typing rule:
\[
\infer[(\rul{rec})]{{!}\Delta;Q \entails \letrecin{a\,x}{b}{c}:C}{
  {!}\Delta,a:{!}(A\loli B), x:A;\emptyset \entails b:B
  &
  {!}\Delta, a:{!}(A\loli B) ;Q \entails c:C      
}
\]
and reduction rule:
\[
\infer[(\rul{rec}).]{[C,\letrecin{a\,x}{b}{c}]\to [C, c[\lambda x.(\letrecin{a\,x}{b}{b})/a]}{}
\]
Preliminary research shows that the core language can be extended 
with this recursion operator without losing type-safety. 

% ----------------------------------------------------------------------
\clearpage
\section{Future work}\label{sec-future}

In this section, we describe some work that is ongoing or planned for
the future. As already mentioned in Section~\ref{ssec-goals}, the
rationale behind the design of Proto-Quipper was to start with the
simplest language possible, establish type-safety, and then extend the
language in small steps with the goal of eventually adding most of
Quipper's features to Proto-Quipper in a type-safe way. 

\subsection{Extensions and proof mechanization}

On project that is currently ongoing is to incorporate the extensions
discussed in the previous section (polymorphism, algebraic data types,
and recursion) into the type safe fragment of the language. This
progressive augmentation process is inherent to Proto-Quipper since
the language was defined to be a type safe reconstruction of
Quipper. 

Currently, making even small extensions to Core Proto-Quipper is a
labor-intensive process, as for every change to the language, type
system, or operational semantics, the proofs of type safety have to be
rewritten. Because this process is time-consuming and error-prone, we
are investigating the use of proof assistant software (such as Coq,
Isabelle, Abella, Twelf, Beluga) to formalize the definition of
Proto-Quipper and the proofs of its meta-properties.

\subsection{Reversibility and measurements}

In Proto-Quipper 0.1, all circuits are reversible. This follows from
the definition of the $(\rev)$ and $(\rul{circ})$ typing rules and
will have to be modified to accommodate non-reversible gates such as
measurements. In such a setting, the type system should ensure that
circuits are reversed only if it is meaningful to do so. In
particular, if a circuit contains a measurement, then it should not be
possible to reverse it.

\subsection{Dependent types and parameterized families of circuits}
 
A circuit generating function that inputs a list of qubits does not
define just one circuit, but rather a family of circuits parameterized
by the length $n$ of the list.  To box such a function, a particular
value of $n$ has to be given. In Quipper, we refer to $n$ as the
``shape'' of the argument of the function. Operations such as boxing
and reversing often require shape information. An alternative solution
would be to equip Proto-Quipper with a {\em dependent type
  system}. This would allow shape information to the stored at the
type level.

\subsection{Imperative-style arguments}

In the current version of Proto-Quipper, all the wires manipulated in
the body of a function must be explicitly returned. It is not possible
to implicitly return the wires that have not been terminated. In
Quipper, we call this the ``functional style'' of programming. Unlike
Proto-Quipper, Quipper also permits an ``imperative style'' of
programming. We plan to extend the Proto-Quipper type system to handle
such imperative-style arguments in a type-safe way.

\subsection{Type-safe cleanup of garbage}

When programming classical oracles, usually some number of ancilla
bits are used, and returned in a ``dirty'' state at the end of the
circuit. The standard trick for making such an oracle reversible is to
uncompute the ancillas by running the computation in reverse. When
programming in a strictly linear language such as Proto-Quipper, all
the ancilla bits must be explicitly accounted for in the type of the
oracle function. A useful extension of the type system would be to
handle such ``garbage'' ancillas automatically.

\subsection{Non-linear controls}

Proto-Quipper handles qubits in a strictly linear fashion. This
ensures that qubits are never discarded or duplicated and is therefore
key in guaranteeing that the type system enforces physical properties
such as no-cloning. However, this discipline is too strict since
certain operations, like controlling, can safely use a qubit in
non-linear way. For example, if a quantum-not gate on qubit $q$ is
controlled by qubits $r$ and $s$, then we must have $q\neq r$ and
$q\neq s$, but it is not necessary that $r\neq s$. This situation
frequently arises in the context of automatically generated quantum
oracles, such as in the Quantum Linear Systems algorithm. In fact,
this is the reason that strict linearity checking is currently
disabled in Quipper. It is an interesting problem how to extend the
Proto-Quipper type system the non-linear use of qubits as controls.

\subsection{Dynamic lifting}

In contrast to the quantum lambda calculus, the reduction in
Proto-Quipper is non-probabilistic. Of course, the hypothetical
quantum device running the circuit produced by Proto-Quipper would
have to perform probabilistic operations, but the circuit generation
itself does not have to. This is justified by the ``principle of
deferred measurement" which states that any quantum circuit is
equivalent to one where all measurements are performed as the very
last operations (see, e.g., \cite{NC02} p.186). We therefore do not
need to rely on the result of a measurement to construct circuits and,
in theory, no computational power is lost by making this
assumption. In practice, however, this delaying of measurement may
significantly increase the size of the circuit. Thus in terms of
computational resources it is sometimes advantageous to permit circuit
generating functions that access previous measurement results. In
fact, several existing quantum algorithms, including the Unique
Shortest Vectors algorithm, rely on such interactive circuit
building. In the Unique Shortest Vectors algorithm, this takes the
form of a sieving step. 

In Quipper, this capability is captured by the notion of \emph{dynamic
  lifting} wherein a value of type $\bit$ (a circuit-execution time
value) is lifted to a value of type $\bool$ (a circuit-generation time
value). Adding such a feature to Proto-Quipper would make the
reduction relation probabilistic. It is a research problem how such an
extension can be carried out in a type-safe way. 

% ----------------------------------------------------------------------
\clearpage
\section{Proto-Quipper user guide}
\label{sec-user-guide}

In this section, we provide a tutorial-style introduction to 
programming in Proto-Quipper. 

\input{tutorial}

% ----------------------------------------------------------------------
\clearpage
\section*{Glossary of acronyms}
\addcontentsline{toc}{section}{Glossary of Acronyms}

\begin{itemize}
  \item $\FQ$ = Free quantum variables.
  \item $\FV$ = Free quantum variables.
  \item GFI = Government Furnished Information
  \item IARPA = Intelligence Advanced Research Projects Activity
  \item $IH$ = Induction hypothesis.
  \item ML = A family of functional programming languages, including
    Standard ML of New Jersey and OCaml.
  \item OCaml = The Objective Caml programming language.
  \item QCS = The IARPA Quantum Computer Science program.
  \item QFT = Quantum Fourier Transform.
  \item $\QP$ = Core Proto-Quipper.
  \item $\QP'$ = Type-inference version of Core Proto-Quipper.
\end{itemize}

% ----------------------------------------------------------------------
\clearpage

\bibliography{biblio}{}
\bibliographystyle{plain}
\addcontentsline{toc}{section}{Bibliography}

\end{document}

