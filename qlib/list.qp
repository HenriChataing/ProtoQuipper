-- -- LIST MODULE -- --
-- Defines the type of lists, and provides basic
-- list manipulation.

import Core

-- Type of lists
type list a =
    Nil
  | Cons of a * list a

let nil = Nil ;;

-- ----------------------------------------------------------------------
-- Operations that discard the list

-- The following operations potentially discard or duplicate some list
-- elements, so they can only be applied to lists of duplicable
-- elements.

let null l =
  match l with
    [] -> true
  | _ -> false
;;

let head (x:_) = x ;;

let tail (_:xs) = xs ;;

let rec last l =
  match l with
    [x] -> x
  | _:xs -> last xs
;;

let rec (@) l n =
  if n < 1 then
    head l
  else
    (tail l) @ (n - 1)
;;

let rec length l =
  match l with
    [] -> 0
  | x:xs -> 1 + length xs
;;

let rec take n l =
  match l with
    [] -> []
  | h:t -> if n <= 0 then [] else h : take (n-1) t
;;

let rec replicate n a =
  if n <= 0 then [] else a:(replicate (n-1) a)
;;

-- Return the nth element of l (counting from 0). It is an error for n
-- to be out of range.
-- 
-- list_index :: list a -> int -> a
let rec list_index l n =
  match l with
    h:t -> if n <= 0 then h else list_index t (n-1)
  -- other case is an error
;;

-- ----------------------------------------------------------------------
-- Operations that do not discard the list

-- The following operations preserve the list elements, so they can be
-- applied, for example, to lists of qubits.

let sf_null l =
  match l with
    [] -> (true, [])
  | xs -> (false, xs)
;;

let sf_head (x:xs) = (x, xs) ;;
let sf_tail (x:xs) = (xs, x) ;;
 

let rec sf_last l =
  match l with
    [x] -> (x, [])
  | x:xs -> let (d, xs) = sf_last xs in
            (d, x:xs)
;;

let rec sf_length l =
  match l with
    [] -> (0, [])
  | x:xs -> let (n, xs) = sf_length xs in
            (n+1, x:xs)
;;

-- Return the nth element of l (counting from 0), as well as the list
-- of remaining elements in their original order. It is an error for n
-- to be out of range.
-- 
-- sf_list_index :: list a -> int -> a * list a
let rec sf_list_index l n =
  match l with
    h:t -> 
      if n <= 0 then (h, t) else
      let (a, as) = sf_list_index t (n-1) in
      (a, h:as)
    -- other case is an error
;;

-- The inverse of sf_list_index: re-insert the element at the given
-- position. It is an error if the list has fewer than n elements.
-- 
-- sf_list_unindex :: a * list a -> int -> list a
let rec sf_list_unindex (a, as) n =
  if n <= 0 then a:as else
  match as with
    h:t -> h : sf_list_unindex (a, t) (n-1)
;;

-- Insert an element at position n in the given list. It is an error
-- if the list has fewer than n elements.
-- 
-- sf_insert :: a -> list a -> int -> list a
let sf_insert a as n = sf_list_unindex (a, as) n;;

-- ----------------------------------------------------------------------
-- Maps, zips, folds, etc.

let rec map f l =
  match l with
    [] -> []
  | x:xs -> (f x):(map f xs)
;;

let rec zip l1 l2 =
  match (l1,l2) with
    ([],[]) -> []
  | (h1:t1, h2:t2) -> (h1,h2) : zip t1 t2
  -- other cases give an error
;;

let rec unzip l =
  match l with
    [] -> ([],[])
  | (a,b):t -> 
      let (as,bs) = unzip t in
      (a:as, b:bs)
;;

let rec foldl f y l =
  match l with
    [] -> y
  | x:xs -> foldl f (f y x) xs
;;

let rec foldr f l y =
  match l with
    [] -> y
  | x:xs -> let y = foldr f l y in
            f x y
;;

let rec (++) l0 l1 =
  match (l0, l1) with
    ([], l) -> l
  | (l, []) -> l
  | (x:xs, l) -> let l = xs ++ l in
                 x:l
;;

let reverse l =
  let rec reverse_acc acc l =
    match l with
      [] -> acc
    | x:xs -> reverse_acc (x:acc) xs
  in

  reverse_acc [] l
;;

  
