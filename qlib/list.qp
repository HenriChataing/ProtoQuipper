-- -- LIST MODULE -- --
-- Defines the type of lists, and provides basic
-- list manipulation.

import Core

-- Type of lists
type list a =
    Nil
  | Cons of a * list a

let nil = Nil ;;


-- UNSAFE OPERATIONS

let null l =
  match l with
    [] -> true
  | _ -> false
;;

let head (x:_) = x ;;

let tail (_:xs) = xs ;;

let rec last l =
  match l with
    [x] -> x
  | _:xs -> last xs
;;

let rec (@) l n =
  if n < 1 then
    head l
  else
    (tail l) @ (n - 1)
;;

-- SAFE OPERATIONS

let sf_null l =
  match l with
    [] -> (true, [])
  | xs -> (false, xs)
;;

let sf_head (x:xs) = (x, xs) ;;
let sf_tail (x:xs) = (xs, x) ;;
 

let rec sf_last l =
  match l with
    [x] -> (x, [])
  | x:xs -> let (d, xs) = sf_last xs in
            (d, x:xs)
;;

let rec sf_length l =
  match l with
    [] -> (0, [])
  | x:xs -> let (n, xs) = sf_length xs in
            (n+1, x:xs)
;;

let rec map f l =
  match l with
    [] -> []
  | x:xs -> (f x):(map f xs)
;;

let rec zip l1 l2 =
  match (l1,l2) with
    ([],[]) -> []
  | (h1:t1, h2:t2) -> (h1,h2) : zip t1 t2
  -- other cases give an error
;;

-- let rec unzip l =
--   match l with
--     [] -> ([],[])
--   | (a,b):t -> 
--       let (as,bs) = unzip t in
--       (a:as, b:bs)
-- ;;

let rec take n l =
  match l with
    [] -> []
  | h:t -> if n <= 0 then [] else h : take (n-1) t
;;

let rec foldl f y l =
  match l with
    [] -> y
  | x:xs -> foldl f (f y x) xs
;;

let rec foldr f l y =
  match l with
    [] -> y
  | x:xs -> let y = foldr f l y in
            f x y
;;

let rec (++) l0 l1 =
  match (l0, l1) with
    ([], l) -> l
  | (l, []) -> l
  | (x:xs, l) -> let l = xs ++ l in
                 x:l
;;

let reverse l =
  let rec reverse_acc acc l =
    match l with
      [] -> acc
    | x:xs -> reverse_acc (x:acc) xs
  in

  reverse_acc [] l
;;

let rec replicate n a =
  if n <= 0 then [] else a:(replicate (n-1) a)
;;
  
