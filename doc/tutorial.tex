\subsection{Installing and invoking Proto-Quipper}

Install instructions can be found in the README file accompanying the code. 
To build the code type \verb#make# in the main Proto-Quipper directory. 

The \verb#qlib# directory contains some basic modules and examples that can 
be used to test the install. To invoke Proto-Quipper on a file, call 
\verb#./ProtoQuipper qlib/qft.qp -fv#. This will run Proto-Quipper on the sample code \verb#qft.qp#. The \verb#-fv# option selects the visual format. 
This should produce the following output, representing the circuit for the 
Quanutm Fourier Transform on three qubits (QFT3) together with its inferred 
type:
\begin{verbatim}
$ ./ProtoQuipper qlib/qft.qp -fv

----------------------*-----*----[H]---
                      |     |          
----------*----[H]----|----[R]---------
          |           |                
---[H]---[R]---------[R]---------------

 : !circ(qbit * qbit * qbit, qbit * qbit * qbit)
\end{verbatim}
The default format option is \verb#ir# which outputs the intermediate representation of quantum circuits specified in the context of the QCS program. The \verb#-h# option displays the list of available command line 
options. If multiple files are passed as arguments to Proto-Quipper, they 
are sequentially executed. If no argument file is given, Proto-Quipper 
enters its interactive mode:
\begin{verbatim}
$ ./ProtoQuipper
### Proto-Quipper -- Interactive Mode ###
# 
\end{verbatim}
In interactive mode, all commands must end with \verb#;;#. This mode accepts:
\begin{itemize}
  \item import statements, e.g., \verb#import Gates ;;#,
  \item type definitions, e.g., 
  \verb#type list a = Nil | Cons of a * list a ;;# and
  \item top-level declarations, e.g., \verb#let x = 1 ;;# or \verb#1+1 ;;#.
\end{itemize}
Commands in interactive mode always start with a \verb#:#. For example, 
\verb#:help# will display a list of available commands. These are (other 
than \verb#:help# itself): 
\begin{itemize}
  \item \verb#:ctx# which lists the variables of the current context, 
  \item \verb#:exit# which quits the interactive mode and
  \item \verb#:display# which displays the top-level circuit.
\end{itemize}
To invoke a command any one of the corresponding prefix will suffice.

\subsection{Primitives}

Our implementation of Proto-Quipper was developed in Haskell. However, the 
syntax might be more familiar to programmers having experience with OCaml.

Code in Proto-Quipper is organized in modules. Module names always start 
with an upper-case character. The implementation must be placed in a file 
of the same name but written in lower-case and ending with the {\tt.qp} 
extension. For example, the module {\tt List} will be implemented in 
{\tt list.qp}. Modules are organized as follows.
\begin{enumerate}
  \item The module starts with a list of import declarations, written 
  {\tt import Module}.
  \item All the type definitions of the module are placed after the list 
  of imports.
  \item The rest of the file forms the body of the module, organized as a 
  list of variable declarations and top-level expressions.
\end{enumerate}

The Proto-Quipper primitives include (most of) the formal syntax presented 
in the preceeding sections together with a list of built-in quantum gates. 
Figures \hyperref[types]{\ref*{types}} and \hyperref[terms]{\ref*{terms}} 
describe the correspondance between the formal and implemented versions of 
the core syntax.

\begin{figure}[!ht]
\begin{center}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{|c|c|}
  \hline
  \textbf{Formalization}    & \textbf{Implementation} \\\hline
  $qbit$, $bool, 1$         & \verb#qbit#, \verb#bool#, \verb#()# \\\hline
  $A \otimes B$             & \verb# A * B# \\\hline
  $A \multimap B$           & \verb# A -> B # \\\hline
  $Circ(T, U)$              & \verb# circ(T,U)# \\\hline
  ${!} A$                   & \verb# !A# \\\hline
\end{tabular}
\end{center}
\caption{Proto-Quipper Types.}
\label{types}
\end{figure}

\begin{figure}[!ht]
\begin{center}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{|c|c|}
  \hline
  \textbf{Formalization}          & \textbf{Implementation} \\\hline
  $x$                             & \verb# x# \\\hline
  $\texttt{True}, \texttt{False}$ & \verb#true#, \verb#false# \\\hline
  $\pair{a}{b}$                   & \verb# (a,b) # \\\hline
  $*$                             & \verb# ()# \\\hline
  $\lambda x.a$                   & \verb# fun x -> a# \\\hline
  $a \, b$                        & \verb#a b# \\\hline
  $box^T$                         & \verb# box[T]# \\\hline
  $unbox, rev$                    & \verb#unbox#, \verb#rev# \\\hline
  $if ~a~ then ~b~ else ~c$       & \verb# if a then b else c# \\\hline
  $let \pair{x}{y} = a ~in~ b$    & \verb# let (x,y) = a in b# \\\hline
\end{tabular}
\end{center}
\caption{Proto-Quipper Terms.}
\label{terms}
\end{figure}

Note that no term of the form $(t,C,u)$ appears in table 
\hyperref[terms]{\ref*{terms}}. This is because the $(t,C,u)$ construct is 
not accessible to the programmer. In its place, we provide a set of 
primitive quantum gates. The module \verb#Gates#, that can be found in the 
\verb#qlib# directory, contains the definition of a set of basic gates. 
These include: \verb#init0#, \verb#init1#, \verb#term0#, \verb#term1#, 
\verb#not#, \verb#hadamard#, \verb#T#, \verb#S#, \verb#Y#, \verb#Z#, 
\verb#phase#, \verb#W#, \verb#E#, \verb#toffoli#, \ldots Please refer to 
the documentation for a complete list.

\subsection{Bell states}
\label{ssec-quipper-by-e}

Now that we have introduced the primitive functions that can be used in Quipper programs, we can combine them into a larger program. We start with 
a basic example: a circuit producing two qubits in the Bell state. Below is
the code of the module \verb#Bell# contained in a file \verb#bell.qp#.

%\begin{figure}[!ht]
\begin{verbatim}
import Gates

box[] (fun x ->
  let q0 = hadamard (init0 ()) in
  let q1 = init0 () in
  let (q1, q0) = cnot (q1, q0) in
  (q0, q1)
) ;;
\end{verbatim}
%\caption{Contents of the module Bell.}
%\end{figure}

We give a line by line interpretation of the code. The circuit is the standard one found in the litterature and uses the gates \verb#hadamard#, 
\verb#init0# and \verb#cnot# that are provided by the \verb#Gates# module. 
To access this module, we must import it explicitly. This is the role of 
the line:
\begin{center}
  \verb#import Gates#
\end{center}
The \verb#box[]# constructor starts a new circuit of type \verb#circ((), T)#. 
Note that no type annotation was provided. The type is then assumed to be 
the unit type \verb#()#, so that \verb#box[]# is shorthand for 
\verb#box[()]#. The first step is to create a new qubit, initialized in the 
state $\ket{0}$. This is done by a call to \verb#init0#, which is defined as 
\verb#unbox INIT0#, where \verb#INIT0# corresponds to the following circuit 

$$\Qcircuit @C=1em @R=.7em {
  & \lstick{\ket{0}} & \qw
}$$

In fact, \verb#unbox# has been applied to all the primitive gates provided 
in the module \verb#Gates# so that they can be directly used as functions. 
In this manner, the \verb#hadamard# gate is applied to the newly created 
\verb#qbit# and the result is stored in the variable \verb#q0#. Similarly, 
another \verb#qbit# is initialized in the state $\ket{0}$ and stored in the 
variable \verb#q1#. The rest of the code is straightforward. A \verb#cnot# 
gate is applied to the pair \verb#(q1,q0)# and the pair is then returned. 
Remark that the pair \verb#(q0,q1)# \emph{must} be returned as the end of 
the box definition to respect the strict linearity of Proto-Quipper. The 
hypothetical code where \verb#q0, q1# are not returned would generate a 
typing error. Finally, every top-level expression in the body of the 
module must be suffixed by \verb#;;#. 

\subsection{Shorthand notations}

Remark that in the code given above for the Bell-state circuit, 
the first two occurences of the \verb#let# binder are not 
instances of the formal binder defined in subsection 
\hyperref[ssec-types-and-terms]{\ref*{ssec-types-and-terms}}. 
Indeed, the let binding used there not applied to a pair. 

%This is a syntactic sugar introduced in the implementation 
%to make the programming easier. A list of the available 
%shorthand notations is provided in the next subsection.

As is common with a lot of functional programming languages 
(Haskell, OCaml \ldots) some notations are introduced to increase
the readability of the code. Note that the let-binding is \emph{not} a syntactic sugar (it may be) as it is used to introduce
the let-polymorphism (an integral part of all the ML-based languages).
The figure \ref{sugar} gives the list of the notations introduced in Proto-Quipper. Some of those use patterns, objects that are
defined by the grammar
	\begin{center}
	\begin{tabular}{rcl}
		Pattern $p_1 \dots p_n$ & ::= & $x$ \\
		            & $|$ & $(p_1, \dots, p_n)$ \\
		            & $|$ & $()$
	\end{tabular}
	\end{center}

\begin{figure}[!ht]
\begin{tabular}{ll}
  \verb#let p = a in b#       & Binds the variables of the pattern 
                                \verb#p# \\
  \verb#p <- a; b#            & Same as \verb#let p = a in b# \\
  \verb#p <-* a; b#           & Used to compute \verb#let p = a p in b#
                                (\verb#a# must be a function)\\
  \verb#fun p -> a#           & Equivalent of 
                                \verb#fun x -> let p = x in a# \\
  \verb#fun x y z -> a#       & Equivalent of 
                                \verb#fun x -> fun y -> fun z -> a# \\
  \verb#let f x y z = a in b# & Equivalent of 
                                \verb#let f = (fun x y z -> a) in b#
\end{tabular}
\label{sugar}
\caption{Syntactic sugars.}
\end{figure}

\subsection{The Quantum Frourier Transform on three qubits}

With the help of the shorthand notations introduced above, we can write 
larger programs. For example, an implementation of the Quantum Fourier 
Transform of three qubits is given below:
\begin{verbatim}
box[qbit * qbit * qbit] (
  fun (q0, q1, q2) ->
    q2 <-* hadamard;
    (q2, q1) <-* cphase 2;
    q1 <-* hadamard;
    (q2, q0) <-* cphase 4;
    (q1, q0) <-* cphase 2;
    q0 <-* hadamard;
    (q0, q1, q2)
) ;;
\end{verbatim}
This code illustrate the usefulness of the \verb#p <-* a# notation, since 
the result of the application of quantum gates to qubits is usually stored 
in the same variables. Note that the type annotation in \verb#box# is 
\verb#qbit *qbit * qbit#, rather than \verb#qbit * (qbit * qbit)# or 
\verb#(qbit * qbit) * qbit#. This is because our implementation of 
Proto-Quipper allows the use unparenthesized tuples of arbitrary size. As 
with most syntactic sugars, this function producing same output circuit 
could have been coded without using this extension. However, this version 
is more compact. 

\subsection{Extensions}

The extensions discussed here were introduced in section 
\hyperref[sec-extensions]{\ref*{sec-extensions}}. 

\subsubsection{Polymorphism}

The let-bindings are always assumed to be polymorphic. For example, the 
function:
\begin{verbatim}
let double f q = f (f q) ;;
\end{verbatim}
can be used as follows:
\begin{verbatim}
box[qbit * qbit] (fun (q, r) ->
  q <- double not q;
  (q, r) <- double cnot (q, r);
  (q, r)
) ;;
\end{verbatim}
The first occurrence of \verb#double# has the type 
\verb#!(qbit -> qbit) -> qbit -> qbit#, while the second occurrence has type 
\verb#!(qbit * qbit -> qbit * qbit) -> qbit * qbit -> qbit * qbit#.

\subsubsection{Algebraic types, integers and lists}

The formal definition of sum types, with $left$ and $right$ constructors, 
is not particularly user-friendly. We therefore authorize algebraic types, 
which can be seen as a generalization of sum types. The definitions of such 
types have to be placed at the beginning of the source file, immediately 
following the \verb#import# statements. These definitions follow the pattern: 
\begin{verbatim}
type typename [a b ..] =
    Datacon1 [of T1]
  | Datacon2 [of T2]
  ..
  | DataconN [of TN]
\end{verbatim}
where \verb#a#, \verb#b#, \ldots are type variables and \verb#T1#, \ldots, 
\verb#TN# are type expressions possibly involving the variables \verb#a#, 
\verb#b#, \ldots In particluar:
\begin{itemize}
  \item The name of the type must start with a lower case character
  \item The type is followed by a (eventually empty) list of type arguments
  \item The name of the data constructors starts with an upper case  
  character. Each data constructor can take one argument type, introduced 
  by \verb#of#.
\end{itemize}

All the types defined in the same module are assumed to be co-inductive. For 
example, the type of lists included in the module \verb#List# has the 
definition
\begin{verbatim}
type list a =
    Nil
  | Cons of a * list a
\end{verbatim}
Since lists are part of the basic objects, some notations have been introduced in the syntax to simplify the writing and manipulation of lists. 
These are
\begin{center}
\begin{tabular}{ll}
  \verb#[]#               & for ~ \verb#Nil# \\
  \verb#x:xs#             & for ~ \verb#Cons (x, xs)# \\
  \verb#[x1, x2, .., xn]# & for ~ 
                            \verb#Cons (x1, Cons (x2, .. Cons (xn, Nil) ..))#
\end{tabular}
\end{center}
and can be used in either expressions or patterns.

\subsubsection{Recursion}

Recursive functions can be written using the syntax:
\begin{verbatim}
let rec f x y z = a in b
\end{verbatim}
Note that only functions may be declared recursive in Proto-Quipper, whereas 
Haskell authorized recursive values, and for example lists of infinite size.

\subsection{The Quantum Fourier Transform}

With the extensions given in the previous subsection, we can write an 
algorithm for the Quantum Fourier Transform for quantum registers encoded 
as lists of qubits. The QFT is now defined as a recursive function that 
inputs a quantum register. The output is the list of resulting qubits. 

We need to import the \verb#List#, \verb#Gates# and \verb#Core# modules. 
We assume that the \verb#List# module contains the following function, 
with the given type:
\begin{verbatim}
val sf_last <: !(list a -> (a, list a))
\end{verbatim}
This function returns the last element of a list, and for linearity reasons 
also the rest of the list. The module \verb#Core# provides some basic integer 
operations like \verb#+ ^ - * ..#. The \verb#Gates# module you already known 
about.

The implementation of the algorithm is as follow:

\begin{verbatim}
import Core
import Gates
import List

-- Apply the nth phase gate to each qbit of the list, controlled by a parameter
let rec appphase n q qn =
  match qn with
   [] -> (q, [])
 | q0:qr ->
     (q, qr) <- appphase (n+1) q qr;
     (q0, q) <-* cphase (2 ^ n);
     (q, q0:qr)
;;

-- Quantum Fourier Transform
let rec qft qreg =
  match qreg with
    [] -> []
  | q:reg ->
      (qn, qn1) <- sf_last (q:reg);
      qn1 <- qft qn1;
      (qn, qn1) <- appphase 1 qn qn1;
      qn <-* hadamard;
      qn:qn1
;;
\end{verbatim}
