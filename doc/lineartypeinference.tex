\title{
	Notes on type linear type inference
}
\author{
        Henri Chataing
}
\date{\today}

\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{bussproofs}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section] % reset theorem numbering for each chapter

\theoremstyle{definition}
\newtheorem{defn}{Definition}[subsection] % definition numbers are dependent on theorem numbers
\newtheorem{exmp}{Example} % same for example numbers
\newtheorem{prop}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]

%% LINEAR LOGIC %%
\def\bang{!\,}
\newcommand{\pair}[2]{\langle #1, #2 \rangle}

\begin{document}
\maketitle

\newpage

\section{Linear logic}

\subsection{Definition of the language LL}

\begin{defn} The terms of the language are defined by the following grammar :
	$$\texttt{Term} ~ t, u ~ ::= ~ x ~ | ~ \lambda x.t ~ | ~ t u ~|~ \pair{t}{u} ~|~ \text{let} ~ \pair{x}{y} = t ~ \text{in} ~ u  $$
	The free variables of a term are calculated by the function $FV$, whose definition is not given.
\end{defn}

\begin{defn} The types of language are defined by the following grammar :
	\begin{center}
	\begin{tabular}{l}
		$\texttt{Variable} ~ \alpha ~ ::= ~ \alpha$ \\
		$\texttt{LinearType} ~ A ~ ::= ~ \alpha ~|~ T \multimap U ~|~ T \otimes U$\\
		$\texttt{Type} ~ T, U       ~ ::= ~ A ~|~ \bang A$
	\end{tabular}
	\end{center}
	This grammar distinguishes between linear types and types to ban expressions doubling the $!$ annotation
	like in $\bang \bang \alpha$. In the rest of the article, we will use the shortened grammar
		$$\texttt{Type} ~ T, U ~ ::= ~ \alpha ~|~ T \multimap U ~|~ T * U ~|~ \bang T$$
	with the understanding that $\bang T$ imply $T$ be a linear type. In general, we will use the names
	$A, B \dots$ for linear types, and $T, U \dots$ for normal types.
	We use the notation $FTV$ for the free type variables of a type.
\end{defn}

\begin{defn}
	The sub-typing relation $<:$ is the smallest relation on LL types satisfying the following rules :
	\begin{prooftree}
  	\AxiomC{}
  	\RightLabel{$(var)$}
  	\UnaryInfC{$!^n \alpha <: ~ !^m \alpha$}
  \end{prooftree}
  \begin{prooftree}	
  	\AxiomC{$A <: B$}
  	\RightLabel{$(!)$}
  	\UnaryInfC{$!^n A <: ~ !^m B$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$T' <: T$}
  	\AxiomC{$U <: U'$}
  	\RightLabel{$(\multimap)$}
  	\BinaryInfC{$T \multimap U <: T' \multimap U'$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$T <: T'$}
  	\AxiomC{$U <: U'$}
  	\RightLabel{$(\otimes)$}
  	\BinaryInfC{$T \otimes U <: T' \otimes U'$}
  \end{prooftree}
  under the condition that $m \le n$, with $n, m$ ranging over $\{ 0, 1 \}$.
\end{defn}

\begin{lemma} \it The sub-typing relation $<:$ is reflexive, transitive.
\end{lemma}

\begin{defn}{\bf Typing rules}
	\begin{prooftree}
		\AxiomC{$T <: U$}
		\RightLabel{$(ax)$}
			\UnaryInfC{$! \Delta, x : T \vdash x : U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma, x : T \vdash t : U$}
		\RightLabel{$(\lambda_1)$}
		\UnaryInfC{$\Gamma \vdash \lambda x.t : T \multimap U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$! \Gamma, x : T \vdash t : U$}
		\RightLabel{$(\lambda_2)$}
		\UnaryInfC{$! \Gamma \vdash \lambda x.t : ~ \bang (T \multimap U)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !\Delta \vdash t : T \multimap U$}
		\AxiomC{$\Gamma_2, !\Delta \vdash u : T$}
		\RightLabel{$(app)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !\Delta \vdash t u : U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !\Delta \vdash t : \, !^nT$}
		\AxiomC{$\Gamma_2, !\Delta \vdash u : \, !^mU$}
		\RightLabel{$(\otimes\text{-i})$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !\Delta \vdash \, \pair{t}{u} \, : \,!^p(\,!^nT * \,!^mU)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !\Delta \vdash t : \, !^n (T * U)$}
		\AxiomC{$\Gamma_2, !\Delta, x : T, y : U \vdash u : V$}
		\RightLabel{$(\otimes\text{-e})$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !\Delta \vdash \, \text{let} \pair{t}{u} = t ~ \text{in} ~ u \, : V$}
	\end{prooftree}
	Where $n, m, p$ range over $\{0, 1\}$, with the condition that $p \le n$ and $p \le m$.
\end{defn}

\subsection{Linear logic adapted to the type inference : LL'}

The terms of the language are unchanged, only the typing system is modified to be closer to the
type inference algorithm. In particular, the indeterminism introduced by the presence of two different
typing rules $(\lambda_1)$ and $(\lambda_2)$ to type $\lambda$-expressions disappears.

\begin{defn} The types of LL' are defined by the following grammar :
	\begin{center}
	\begin{tabular}{l}
		$\texttt{Variable} ~ \alpha ~ ::= ~ \alpha$ \\
		$\texttt{Flag} ~ m, n ::= ~ n ~|~ 0 ~|~ 1$ \\		
		$\texttt{LinearType} ~ A ~ ::= ~ \alpha ~|~ T \multimap U ~|~ T * U$ \\
		$\texttt{Type	} ~	T, U ~ ::= ~ !^n A$
	\end{tabular}
	\end{center}
	The grammar separates linear types and types the same way the grammar of LL types does. Note that the grammar of the types
	of LL' enforces that every type be preceded by a flag annotation.
\end{defn}

\begin{defn}
  The sub-typing relation $<:$ is defined as the smallest relation on LL' types satisfying the rules
  \begin{prooftree}
  	\AxiomC{$m \le n$}
  	\RightLabel{$(var)$}
  	\UnaryInfC{$!^n \alpha <: ~ !^m \alpha$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$m \le n$}
  	\AxiomC{$A <: B$}
  	\RightLabel{$(!)$}
  	\BinaryInfC{$!^n A <: ~ !^m B$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$T' <: T$}
  	\AxiomC{$U <: U'$}
  	\RightLabel{$(\multimap)$}
  	\BinaryInfC{$T \multimap U <: T' \multimap U'$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$T <: T'$}
  	\AxiomC{$U <: U'$}
  	\RightLabel{$(\otimes)$}
  	\BinaryInfC{$T * U <: T' * U'$}
  \end{prooftree}
\end{defn}

\begin{lemma} \it The sub-typing relation $<:$ is reflexive, transitive.
\end{lemma}

\begin{defn} Sub-typing constraints $T <: U$ are defined over LL' types. A constraint $T <: U$ is atomic
  when $T$ and $U$ are both type variables, and composite when both are not type variables. Otherwise, the constraint is
  semi-composite. \\
  Similarly, flag constraints $n \le m$ are defined over flag annotations.
\end{defn}

\begin{defn} A substitution $\sigma$ is the composition of a finite list of mappings $\alpha \mapsto A$ from type variables to
	\textit{linear} types 	by a valuation of the annotation of a type. A substitution is automatically extended by the identity function
	to apply on all the type variables and flags.
	$\bar{\sigma}$ the extension of $\sigma$ to linear and non-linear types is defined as follow :
 		\begin{center}
 		\begin{tabular}{l}
 			$\bar{\sigma}(\alpha) = \sigma(\alpha)$ \\
 			$\bar{\sigma}(T \multimap U) = \bar{\sigma}T \multimap \bar{\sigma}U$ \\
 			$\bar{\sigma}(T * U) = \bar{\sigma}T * \bar{\sigma}U$ \\
 			$\bar{\sigma}(!^n T) = ~ !^{\sigma(n)} \bar{\sigma}T$
 		\end{tabular}
 		\end{center}
 	The notation $|\sigma|$ is used to designate the set of mapped variables, for example
 	$ | \,x \mapsto T, \, y \mapsto U\,| = \{ x, \,y \} $
\end{defn}

\begin{defn} We name $\mathcal{L}$ a set of constraints, which is comprised of sub-typing constraints
  and flag constraints. A constraint set can have the following properties :
  \begin{itemize}
  	\item[]{\bf Atomicity} A set is atomic when all the constraints (typing constraints and flag constraints) forming it are atomic.
  	\item[]{\bf Satisfiability} A set is \textit{tautological} when all the included constraints can be solved by application of one or
  		more of the sub-typing rules (typing constraints) or by transitivity (flag constraints).
  		Following, a set $\mathcal{L}$ is \textit{satisfiable} if there exists a substitution $\sigma$ such that $\sigma \mathcal{L}$
	 		becomes tautological.
	 	\item[]{\bf Derivation} When the validity of a set $\mathcal{L}$ can be deduced from another set $\mathcal{L'}$ by application of
		  the sub-typing rules, we say that $\mathcal{L}$ \textit{derive} from $\mathcal{L'}$, written $\mathcal{L'} \vdash \mathcal{L}$.
  \end{itemize}
\end{defn}

\begin{defn}{\bf Typing rules} A typing judgement is a sequent of the form $\Gamma \vdash_\mathcal{L} t : T$, holding the
	meaning \textit{Under the condition that $\mathcal{L}$ is satisfied, the judgement $\Gamma \vdash t : T$ holds}.
	A sequent is \textit{valid} if a typing derivation can be constructed using the typing rules of LL'.
  In the typing rules, we use the notation $!^I \Gamma$ to designate contexts of the form 
  $!^I \Gamma = x_1 : \,!^{i_1}T_1 \dots x_n : \,!^{i_n}T_n$ and $I = \{i_1 \dots i_n\}$. \\

	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(ax)$}
			\UnaryInfC{$!^I \Gamma, x : T \vdash_{\{T <: U\} \cup \{1 \le I \}} x : U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$!^I\Gamma, x : T \vdash_{\mathcal{L}} t : U$}
		\RightLabel{$(\lambda)$}
		\UnaryInfC{$!^I\Gamma \vdash_{\mathcal{L} \cup \{n \le I\} } \lambda x.t : ~ !^n(T \multimap U)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !^I\Delta \vdash_{\mathcal{L}} t : \, !^n(T \multimap U)$}
		\AxiomC{$\Gamma_2, !^I\Delta \vdash_{\mathcal{L'}} u : T$}
		\RightLabel{$(app)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^I\Delta \vdash_{\mathcal{L \cup L'} \cup \{1 \le I\} } t u : U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !^I\Delta \vdash_{\mathcal{L}} t : \, !^n T$}
		\AxiomC{$\Gamma_2, !^I\Delta \vdash_{\mathcal{L'}} u : \, !^m U$}
		\RightLabel{$(\otimes\text{-i})$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^I\Delta \vdash_{\mathcal{L \cup L'} \cup \{1 \le I, \, p \le n, \, p \le m \} }
			\pair{t}{u}:\, !^p(\,!^nT * \, !^mU)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !^I\Delta \vdash_\mathcal{L} t : \, !^n (T * U)$}
		\AxiomC{$\Gamma_2, !^I\Delta, x : T, y : U \vdash_\mathcal{L'} u : V$}
		\RightLabel{$(\otimes\text{-e})$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^I\Delta \vdash_{\mathcal{L \cup L'} \cup \{ 1 \le I \} }
			\, \text{let} \pair{t}{u} = t ~ \text{in} ~ u \, : V$}
	\end{prooftree}
\end{defn}

\subsection{Soundness and completeness of LL'}

\begin{defn} $\tau$ is the transposition of LL types to LL'.
	A correct definition of $\tau$ needs to distinguish between $\tau_L$ applied to
	linear types and $\tau$ to general types :
  \begin{center}
	\begin{tabular}{l}
		$\tau_L\alpha = ~ \alpha$ \\
		$\tau_L(T \multimap U) ~ = ~ \tau T \multimap \tau U$ \\
		$\tau_L(T * U) ~=~ \tau T * \tau U$ \\
		$\tau(\bang A) ~ = ~ !^1 \tau_L A$ \\
		$\tau A ~ = ~ !^0 \tau_L A$
	\end{tabular}
	\end{center}
	The definition of $\tau$ makes it that the return value of $\tau$ is always a LL' type (not a linear type).
\end{defn}

\begin{lemma} Let $T, U$ be LL types. If $T <: U$ then $\tau T <: \tau U$.

	\begin{proof}
		By induction on the sub-typing derivation :
		\begin{itemize}
			\item If the rule is $(var)$. The application of $\tau$ leaves $!^n \alpha$ and $!^m \alpha$ unchanged.
				The condition $m \le n$ being fulfilled, the application of the sub-typing rule $(var)$ of LL' yields
				$\tau (!^n \alpha) <: \tau (!^m \alpha)$.
				
			\item If the rule is $(!)$. By induction on $A <: B$, we have $\tau_L A <: \tau_L B$. The condition $m \le n$
				is satisfied, and the rule $(!)$ of LL' applied to $\tau_L A$ and $\tau_L B$ yields $!^n \tau_L A <: ~ !^m \tau_L B$.
				Thus, by definition of $\tau$, $\tau (!^n A) <: \tau (!^m B)$.

			\item If the rule is $(\multimap)$ or $(\otimes)$. By induction on $T' <: T$ and $U <: U'$, we have $\tau T' <: \tau T$ and
				$\tau U <: \tau U'$. Hence, by application of the rule $(\multimap)$ (resp. $(\otimes)$) of LL',
				$\tau T \multimap \tau U <: \tau T' \multimap \tau U$ (resp. $\tau T * \tau U <: \tau T' * \tau U$).
				
		\end{itemize}
	\end{proof}
\end{lemma}
	
\begin{prop} Let $t$ be a term, and $\Pi$ a typing derivation of the typing judgement
	$\Gamma \vdash t : T$ is valid :
	\begin{prooftree}
		\AxiomC{$\Pi$}
		\UnaryInfC{$\Gamma \vdash t : T$}
	\end{prooftree}
	Then there exists a tautological set $\mathcal{L}$ such that the following typing derivation holds :
	\begin{prooftree}
		\AxiomC{$\tau\Pi$}
		\UnaryInfC{$\tau\Gamma \vdash_\mathcal{L} t : \tau T$}
	\end{prooftree}
	
	\begin{proof}
		By induction on the typing derivation of $t$ : if the last typing rule used is
			\begin{itemize}
				\item{$(ax)$} The typing derivation
			    \begin{prooftree}
						\AxiomC{$T <: U$}
						\RightLabel{$(ax)$}
						\UnaryInfC{$! \Delta, x : T \vdash x : U$}
					\end{prooftree}
					is transformed by application of $\tau$ into
					\begin{prooftree}
						\AxiomC{$\tau T <: \tau U$}
						\RightLabel{$(ax)$}
						\UnaryInfC{$!^I \tau\Delta, x : \tau T \vdash x : \tau U$}
					\end{prooftree}
					with $I = 1 \dots 1$.
					
					Using the constraint set $\mathcal{L} = \{ \tau T <: \tau U \} \cup \{ 1 \le I \}$,
					the typing derivation becomes valid in LL'. We now need to show that $\mathcal{L}$ is satisfied.
					Since $T <: U$, by application of the lemma, the sub-typing constraint $\tau T <: \tau U$ is satisfied.
					The constraints of $\{ 1 \le I \}$ are all trivially satisfied.
					
				\item{$(\lambda_1)$} The typing derivation
					\begin{prooftree}
						\AxiomC{$\Pi$}
						\noLine
						\UnaryInfC{$\vdots$}
						\noLine
						\UnaryInfC{$\Gamma, x : T \vdash t : U$}
						\RightLabel{$(\lambda_1)$}
						\UnaryInfC{$\Gamma \vdash \lambda x.t : T \multimap U$}
					\end{prooftree}
					is transformed by application of $\tau$ into
					\begin{prooftree}
						\AxiomC{$\tau\Pi$}
						\noLine
						\UnaryInfC{$\vdots$}
						\noLine
						\UnaryInfC{$!^I \tau\Gamma, x : \tau T \vdash t : \tau U$}
						\RightLabel{$(\lambda_1)$}
						\UnaryInfC{$!^I \tau \Gamma \vdash \lambda x.t : ~ !^0(\tau T \multimap \tau U)$}
					\end{prooftree}
					
					The induction hypothesis applied to the typing derivation $\Pi$ produces a tautological constraint set
					$\mathcal{L}$ such that $!^I \tau\Gamma, x : \tau T \vdash_\mathcal{L} t : \tau U$ is valid.
					We now apply the typing rule $(\lambda)$ of LL' with the annotation $n = 0$. The typing judgement
					$!^I \tau\Gamma \vdash_{\mathcal{L} \cup \{ 0 \le I \}} \lambda x.t : ~ !^0 (\tau T \multimap \tau U)$ is valid,
					and since for all flag $n$, $0 \le n \le 1$, the constraints $\{ 0 \le I \}$ are all satisfied.
					
				\item{$(\lambda_2)$} The typing derivation
					\begin{prooftree}
						\AxiomC{$\Pi$}
						\noLine
						\UnaryInfC{$\vdots$}
						\noLine
						\UnaryInfC{$!\Gamma, x : T \vdash t : U$}
						\RightLabel{$(\lambda_1)$}
						\UnaryInfC{$!\Gamma \vdash \lambda x.t : ~ !(T \multimap U)$}
					\end{prooftree}
					is transformed by application of $\tau$ into
					\begin{prooftree}
						\AxiomC{$\tau\Pi$}
						\noLine
						\UnaryInfC{$\vdots$}
						\noLine
						\UnaryInfC{$!^I \tau\Gamma, x : \tau T \vdash t : \tau U$}
						\RightLabel{$(\lambda_1)$}
						\UnaryInfC{$!^I \tau \Gamma \vdash \lambda x.t : ~ !^1 ( \tau T \multimap \tau U)$}
					\end{prooftree}
					with $I = 1 \dots 1$.
					The induction hypothesis applied to the typing derivation $\Pi$ produces a tautological constraint set
					$\mathcal{L}$ such that $!^I \tau\Gamma, x : \tau T \vdash_\mathcal{L} t : \tau U$ is valid.
					We now apply the typing rule $(\lambda)$ of LL' with the annotation $n = 1$. The typing judgement
					$!^I \tau\Gamma \vdash_{\mathcal{L} \cup \{ 1 \le I \}} \lambda x.t : ~ !^1 (\tau T \multimap \tau U)$ is valid.
					Since $I = 1 \dots 1$, all the constraints in $\{ 1 \le I \}$ are satisfied.
					
				\item{$(app)$} The typing derivation
					\begin{prooftree}
						\AxiomC{$\Pi_1$}
						\noLine
						\UnaryInfC{$\vdots$}
						\noLine
						\UnaryInfC{$\Gamma_1, !\Delta \vdash t : T \multimap U$}
						\AxiomC{$\Pi_2$}
						\noLine
						\UnaryInfC{$\vdots$}
						\noLine
						\UnaryInfC{$\Gamma_2, !\Delta \vdash u : T$}
						\RightLabel{$(app)$}
						\BinaryInfC{$\Gamma_1, \Gamma_2, !\Delta \vdash t u : U$}
					\end{prooftree}
					is transformed by application of $\tau$ into
					\begin{prooftree}
						\AxiomC{$\tau\Pi_1$} \noLine
						\UnaryInfC{$\vdots$} \noLine
						\UnaryInfC{$\tau\Gamma_1, !^I\tau\Delta \vdash t : \tau T \multimap \tau U$}
						\AxiomC{$\tau\Pi_2$} \noLine
						\UnaryInfC{$\vdots$} \noLine
						\UnaryInfC{$\tau\Gamma_2, !^I\tau\Delta \vdash u : \tau T$}
						\RightLabel{$(app)$}
						\BinaryInfC{$\tau\Gamma_1, \tau\Gamma_2, !^I\tau\Delta \vdash t u : \tau U$}
					\end{prooftree}
					with $I = 1 \dots 1$.
					The induction hypothesis applied to the typing derivations $\Pi_1$ and $\Pi_2$ produces
					two tautological constraint sets $\mathcal{L}$ and $\mathcal{L'}$ such that
					$\tau\Gamma_1, !^I \tau\Delta \vdash_\mathcal{L} t : \tau T \multimap \tau U$ and
					$\tau\Gamma_2, !^I \tau\Delta \vdash_\mathcal{L'} u : \tau T$ are valid.
					Using the constraint set $\mathcal{L''} = \mathcal{L \cup L'} \cup \{ 1 \le I \}$, by application of the typing rule $(app)$ of LL',
					the typing judgement $\tau\Gamma_1, \tau\Gamma_2, !^I \tau\Delta \vdash_\mathcal{L''} t u : \tau U$ is valid.
					Now, since $I = 1 \dots 1$, all the constraints in $\{ 1 \le I \}$ are satisfied.
			\end{itemize}	
	\end{proof}
\end{prop}

\begin{defn} Let $\sigma$ be a substitution, $\tau_\sigma$ is a transposition of LL types to LL', parametrized by $\sigma$.
	A correct definition of $\tau_\sigma$ needs to distinguish between $\tau_{\sigma L}$ applied to
	linear types and $\tau$ to general types :
  \begin{center}
	\begin{tabular}{l}
		$\tau_{\sigma L} \alpha = ~ \sigma (\alpha)$ \\
		$\tau_{\sigma L}(T \multimap U) ~ = ~ \tau_\sigma T \multimap \tau_\sigma U$ \\
		$\tau_\sigma (!^n A) ~ = ~ \text{if} ~ \sigma(n) = 0 ~ \text{then} ~
			\tau_{\sigma L} A ~ \text{else} ~
			\bang \tau_{\sigma L} A $
	\end{tabular}
	\end{center}
	This definition respects the non-doubling property we included in the grammar of LL types.
\end{defn}

\begin{prop} Let $t$ be a term, $\mathcal{L}$ a satisfiable set of constraints and $\Pi$ a typing derivation of the typing judgement
	$\Gamma \vdash_\mathcal{L} t : T$ is valid :
	\begin{prooftree}
		\AxiomC{$\Pi$}
		\UnaryInfC{$\Gamma \vdash_\mathcal{L} t : T$}
	\end{prooftree}
	Then for every substitution $\sigma$ solution of $\mathcal{L}$, the following typing derivation holds :
	\begin{prooftree}
		\AxiomC{$\tau_\sigma\Pi$}
		\UnaryInfC{$\tau_\sigma\Gamma \vdash t : \tau_\sigma T$}
	\end{prooftree}
	
	\begin{proof}
		Let $\sigma$ be such a substitution. By induction on the typing derivation : if the last typing rule used is
			\begin{itemize}
				\item{$(ax)$} The typing derivation is
					\begin{prooftree}
						\AxiomC{$T <: U$}
						\RightLabel{$(ax)$}
						\UnaryInfC{$!^I \Delta, x : T \vdash_\mathcal{L} x : U$}
					\end{prooftree}
					with $\mathcal{L} = \{ T <: U \} \cup \{ 1 \le I \}$.
					By hypothesis, $\sigma$ satisfies $\mathcal{L}$. We have in particular : $\tau_\sigma T <: \tau_\sigma U$ and
					$\sigma I = 1 \dots 1$. Consequently, by application of $\tau_\sigma$, the above typing derivation is transformed into :
					\begin{prooftree}
						\AxiomC{$\tau_\sigma T <: \tau_\sigma U$}
						\RightLabel{$(ax)$}
						\UnaryInfC{$! \tau_\sigma\Delta, x : \tau_\sigma T \vdash x : \tau_\sigma U$}
					\end{prooftree}
					Since the constraint $\tau_\sigma T <: \tau_\sigma U$ is satisfied, the typing derivation is valid in LL.
					
				\item{$(\lambda)$} The typing derivation is
					\begin{prooftree}
						\AxiomC{$\Pi$} \noLine
						\UnaryInfC{$\vdots$} \noLine
						\UnaryInfC{$!^I \Gamma, x : T \vdash_\mathcal{L} t : U$}
						\RightLabel{$(\lambda)$}
						\UnaryInfC{$!^I \Gamma \vdash_\mathcal{L'} \lambda x.t : ~ !^n(T \multimap U)$}
					\end{prooftree}
					with $\mathcal{L'} = \mathcal{L} \cup \{ n \le I \}$. \\
					$\sigma$ being a solution to $\mathcal{L'}$, is also a solution to $\mathcal{L}$.
					The induction hypothesis is applicable, and $\tau_\sigma \Gamma, x : \tau_\sigma T \vdash t : \tau_\sigma U$ is a valid
					typing judgement in LL. \\
					The term $\sigma(n)$ can have the value $0$ or $1$ :\\
						\begin{itemize}
							\item If the value is $0$, then we can apply the typing rule $(\lambda_1)$, and
								\begin{prooftree}
									\AxiomC{$\tau_\sigma\Pi$}
									\noLine
									\UnaryInfC{$\vdots$}
									\noLine
									\UnaryInfC{$\tau_\sigma\Gamma, x : \tau_\sigma T \vdash t : \tau_\sigma U$}
									\RightLabel{$(\lambda_1)$}
									\UnaryInfC{$\tau_\sigma \Gamma \vdash \lambda x.t : ~ \tau_\sigma T \multimap \tau_\sigma U$}
								\end{prooftree}
								is a valid typing derivation in LL.
							\item If the value is $1$, since $\sigma$ satisfies $\mathcal{L'}$, and in
								particular $\{ 1 \le I \}$, $\sigma I = 1 \dots 1$. Then we can apply the typing rule $(\lambda_2)$, and
								\begin{prooftree}
									\AxiomC{$\tau_\sigma\Pi$}
									\noLine
									\UnaryInfC{$\vdots$}
									\noLine
									\UnaryInfC{$!\tau_\sigma\Gamma, x : \tau_\sigma T \vdash t : \tau_\sigma U$}
									\RightLabel{$(\lambda_1)$}
									\UnaryInfC{$!\tau_\sigma \Gamma \vdash \lambda x.t : ~ \bang (\tau_\sigma T \multimap \tau_\sigma U)$}
								\end{prooftree}
								is a valid typing derivation in LL.
						\end{itemize}
						
				\item{$(app)$} The typing derivation is
					\begin{prooftree}
						\AxiomC{$\Pi_1$} \noLine
						\UnaryInfC{$\vdots$} \noLine
						\UnaryInfC{$\Gamma_1, !^I\Delta \vdash_\mathcal{L} t : T \multimap U$}
						\AxiomC{$\Pi_2$} \noLine
						\UnaryInfC{$\vdots$} \noLine
						\UnaryInfC{$\Gamma_2, !^I\Delta \vdash_\mathcal{L'} u : T$}
						\RightLabel{$(app)$}
						\BinaryInfC{$\Gamma_1, \Gamma_2, !^I\Delta \vdash_\mathcal{L''} t u : U$}
					\end{prooftree}
					with $\mathcal{L''} = \mathcal{L \cup L'} \cup \{ 1 \le I \}$. \\
					Since $\sigma$ is a solution to $\mathcal{L''}$, it is also a solution to $\mathcal{L}$ and $\mathcal{L'}$,
					and $\sigma I = 1 \dots 1$.
					
					By induction on $\Pi_1$ and $\Pi_2$, both typing judgements
						$$\tau_\sigma \Gamma_1, !\tau_\sigma \Delta \vdash t : \tau_\sigma T \multimap \tau_\sigma U$$
					and
						$$\tau_\sigma \Gamma_2, !\tau_\sigma \Delta \vdash u : \tau_\sigma T$$
					are valid in LL.
					Thus, by application of the typing rule $(app)$ of LL we get that
						\begin{prooftree}
							\AxiomC{$\tau_\sigma\Pi_1$} \noLine
							\UnaryInfC{$\vdots$} \noLine
							\UnaryInfC{$\tau_\sigma\Gamma_1, !\tau_\sigma\Delta \vdash t : \tau_\sigma T \multimap \tau_\sigma U$}
							\AxiomC{$\tau_\sigma\Pi_2$} \noLine
							\UnaryInfC{$\vdots$} \noLine
							\UnaryInfC{$\tau_\sigma\Gamma_2, !\tau_\sigma\Delta \vdash u : \tau_\sigma T$}
							\RightLabel{$(app)$}
							\BinaryInfC{$\tau_\sigma\Gamma_1, \tau_\sigma\Gamma_2, !\tau_\sigma\Delta \vdash t u : \tau_\sigma U$}
						\end{prooftree}
					is a valid typing derivation in LL.
			\end{itemize}
	\end{proof}
\end{prop}
	
\begin{thm}{\bf Soundness and completeness} \it Let $t$ be a term, and $\Gamma$ a typing context in LL. $t$ can be typed
	in the context $\Gamma$ in LL if and 	only if $t$ that can be typed in the context $\tau\Gamma$ in LL'.
	\begin{proof} By application of the propositions.
	\end{proof}
\end{thm}	
	
\section{Constraint typing}

\subsection{Algorithm}

	This is the first part of the type inference algorithm.
	The algorithm takes an incomplete typing judgement of the form :
		$$x_1 : T_1 \dots x_n : T_n ~ \vdash ~ M : T$$
	and outputs a set of linear constraints $\mathcal{L}$ such that the typing judgement
	  $$x_1 : T_1 \dots x_n : T_n ~ \vdash_{\mathcal{L}} ~ M : T$$
	is valid. The algorithm never fails to provide such set, the unification algorithm will tell if this
	set is satisfiable, and so if the term can be typed.
	
	The algorithm proceeds as follow :
	\begin{itemize}
		\item $\text{ConstraintTyping} ~ (~ !^I \Delta, x : T \vdash x : U ~) = $ \\
		  \begin{tabular}{l}
				output $\{ T <: U \} \cup \{ 1 \le I \}$
		  \end{tabular}
		\item $\text{ConstraintTyping} ~ (~ \Gamma \vdash t u : T ~) = $ \\
			\begin{tabular}{l}
				let $\alpha$ be a fresh type variable, and $n$ a fresh flag \\
				let $\mathcal{L} = ~ \text{ConstraintTyping} ~ (~ \Gamma|_{FV(t)} \vdash t : \, !^n\alpha \multimap T ~)$ \\
				let $\mathcal{L'} = ~ \text{ConstraintTyping} ~ ( ~ \Gamma|_{FV(u)} \vdash u : \, !^n\alpha ~)$ \\
				let $!^I\Delta = \Gamma ~ \backslash ~ (FV(t) \oplus FV(u))$ \\
				output $\mathcal{L \cup L'} \cup \{ 1 \le I \}$
			\end{tabular}
		\item $\text{ConstraintTyping} ~ (~ !^I \Gamma \vdash \lambda x.t : T ~) = $ \\
			\begin{tabular}{l}
				let $\alpha$ and $\beta$ be fresh type variables \\
				let $n$, $m$ and $p$ be fresh flags \\
				let $\mathcal{L} = ~ \text{ConstraintTyping} ~ ( \, !^I \Gamma, ~ x : \, !^m \alpha \vdash  t : \, !^n\beta)$ \\
				output $\mathcal{L} \cup \{ p \le I \} \cup \{ \, !^p (!^m \alpha \multimap \, !^n \beta) <: T\}$
			\end{tabular}
	\end{itemize}
	
\subsection{Correction}

\begin{lemma}
	\label{tau-context}
	Let $\sigma$ be a substitution. If the output of the constraint typing algorithm applied to $\Gamma \vdash t : T$ is $\mathcal{L}$,
	and the same applied to $\sigma \Gamma \vdash t : \sigma T$ is $\mathcal{L'}$,
	then $\mathcal{L'} = \sigma \mathcal{L}$.
	
	\begin{proof}
		By induction on the typing derivation.
	\end{proof}
\end{lemma}

\begin{lemma}
	\label{red-context}
	Let $\mathcal{L}$ and $\mathcal{L'}$ be the output of the constraint typing algorithm applied respectively to
	$\Gamma \vdash t : T$ and $\Gamma |_{FV(t)} \vdash t : T$. Then, supposing that $\Gamma = \Gamma |_{FV(t)}, !^I \Delta$,
	the following is true :
		$$ \mathcal{L} = \mathcal{L'} \cup \{ 1 \le I \} $$
		
	\begin{proof}
		By induction on the typing derivation.
	\end{proof}
\end{lemma}

\begin{lemma}
	\label{incl-set}
	Let $\Gamma \vdash_\mathcal{L} t : T$ be a valid typing judgement, and $\mathcal{L}' = ~\text{ConstraintTyping} \,(\Gamma \vdash t : T)$.
	Then there exists a substitution $\sigma$ such that
		\begin{center}
		\begin{tabular}{l}
			$| \sigma | \cap (FTV(\Gamma) \cup FTV(T)) = \varnothing$ \\
			$\mathcal{L} \vdash \sigma \mathcal{L'}$.
		\end{tabular}
		\end{center}
		
	\begin{proof} By induction on the typing derivation. If the last typing rule used is
		\begin{itemize}
			\item $(ax)$. The typing derivation is
				\begin{prooftree}
					\AxiomC{}
					\RightLabel{$(ax)$}
					\UnaryInfC{$!^I \Gamma, x : T \vdash_\mathcal{L} x : U$}
				\end{prooftree}
				with $\mathcal{L} = \{ T <: U \} \cup \{ 1 \le I \}$. The output of the constraint typing algorithm is exactly the
				set $\mathcal{L}$, and $\mathcal{L} \vdash \mathcal{L}$ trivially holds.
				
			\item $(\lambda)$. The typing derivation is
				\begin{prooftree}
						\AxiomC{$\Pi$} \noLine
						\UnaryInfC{$\vdots$} \noLine
						\UnaryInfC{$!^I \Gamma, x : T \vdash_\mathcal{L} t : U$}
						\RightLabel{$(\lambda)$}
						\UnaryInfC{$!^I \Gamma \vdash_{\mathcal{L} \cup \{ n \le I \}} \lambda x.t : ~ !^n(T \multimap U)$}
					\end{prooftree}
				The algorithm makes a recursive call on $!^I \Gamma, x : \, !^q \alpha \vdash t : \, !^r\beta$, with the result $\mathcal{L'}$.
				Following, the output of the algorithm is
					$$\mathcal{L''} = \mathcal{L'} \cup \{p \le I \} \cup \{\, !^p (\,!^q\alpha \multimap \,!^r\beta) <: \, !^n (T \multimap U) \}$$
					
				Let $\sigma$ be the substitution :
					$$ \sigma = [ !^q \alpha \mapsto T, ~ !^r \beta \mapsto U ] $$
				By application of the lemma \ref{tau-context},
					$$ \text{ConstraintTyping} \, (!^I \Gamma, x : T \vdash t : U) = \sigma \mathcal{L'} $$
				The application of the induction hypothesis yields an substitution $\tau$ such that
				$\mathcal{L} \vdash (\tau \circ \sigma) \mathcal{L'}$ and $|\tau| \cap (FTV(\Gamma, x : T) \cup (FTV(U)) = \varnothing$.				
					
				Let $\sigma' = \tau \circ \sigma$. Since $p$ is fresh, $\sigma'$ can be extended with the mapping $[p \mapsto n]$.
				Thence,
					$$\sigma' \mathcal{L''} = \sigma' \mathcal{L'} \cup \{ n \le I \} \cup \{ !^n(T \multimap U) <: \, !^n(T \multimap U) \}$$
				The sub-typing constraint $!^n(T \multimap U) <: \, !^n(T \multimap U)$ can be directly solved by reflexivity. Consequently,
					$$\mathcal{L} \cup \{ 1 \le I \} \vdash \sigma' \mathcal{L''}$$
				Finally, $\alpha, \beta, p, q \notin FTV(\Gamma) \cup FTV(T \multimap U)$, thus the following condition is respected :
					$$ |\sigma'| \cap (FTV(\Gamma) \cup FTV(T \multimap U)) = \varnothing $$
					
			\item $(app)$. The typing derivation is
				\begin{prooftree}
					\AxiomC{$\Pi_1$} \noLine
					\UnaryInfC{$\vdots$} \noLine
					\UnaryInfC{$\Gamma_1, !^I\Delta \vdash_{\mathcal{L}_1} t : T \multimap U$}
					\AxiomC{$\Pi_2$} \noLine
					\UnaryInfC{$\vdots$} \noLine
					\UnaryInfC{$\Gamma_2, !^I\Delta \vdash_{\mathcal{L}_2} u : T$}
					\RightLabel{$(app)$}
					\BinaryInfC{$\Gamma_1, \Gamma_2, !^I\Delta \vdash_\mathcal{L} t u : U$}
				\end{prooftree}
				with $\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$.
				
				With $\Lambda = \Gamma_1, \Gamma_2, !^I \Delta$, the following properties hold :
					\begin{center}
					\begin{tabular}{cl}
						$(a)$ & $ \Gamma_1, !^I\Delta|_{FV(t)} = \Lambda |_{FV(t)} $ \\
						$(b)$ & $ \Gamma_2, !^I\Delta|_{FV(u)} = \Lambda |_{FV(u)} $	\\
						$(c)$ & $ \Gamma_1, \Gamma_2 = \Lambda |_{FV(t) \oplus FV(u)} $ \\
						$(d)$ & $ !^I \Delta = \Lambda \backslash_{FV(t) \oplus FV(u)} $
					\end{tabular}
					\end{center}
			 	All of those properties serve to show that the division of the typing context used by the algorithm in the case of applications
			 	is legitimate. The constraint typing algorithm inputs the non-separated set $\Lambda$, and makes two recursive calls
			 		\begin{center}
			 		\begin{tabular}{l}
			 			$\text{ConstraintTyping} \, (\Lambda |_{FV(t)} \vdash t : \, !^n\alpha \multimap U) = \mathcal{L}_t$ \\
			 			$\text{ConstraintTyping} \, (\Lambda |_{FV(u)} \vdash u : \, !^n\alpha) = \mathcal{L}_u$
			 		\end{tabular}
			 		\end{center}
			 	and returns the set
			 		$$ \mathcal{L''} = \mathcal{L}_t \cup \mathcal{L}_u \cup \{ 1 \le I' \} $$
			 	where $!^{I'} \Delta = \Lambda \backslash_{FV(t) \oplus FV(u)}$.
			 	The property $(d)$ ensures that $I = I'$, and the properties $(a)$ and $(b)$ show that
			 		\begin{center}
			 		\begin{tabular}{l}
			 			$\mathcal{L}_t = \text{ConstraintTyping} \, (\Gamma_1, !^I \Delta |_{FV(t)} \vdash t : \, !^n\alpha \multimap U)$ \\
			 			$\mathcal{L}_u = \text{ConstraintTyping} \, (\Gamma_2, !^I \Delta |_{FV(u)} \vdash u : \, !^n\alpha)$
			 		\end{tabular}
			 		\end{center}
			 	Let $\mathcal{L'}_t$ and $\mathcal{L'}_u$ be
			 		\begin{center}
			 		\begin{tabular}{l}
			 			$\mathcal{L'}_t = \text{ConstraintTyping} \, (\Gamma_1, !^I \Delta \vdash t : \, !^n\alpha \multimap U)$ \\
			 			$\mathcal{L'}_u = \text{ConstraintTyping} \, (\Gamma_2, !^I \Delta \vdash u : \, !^n\alpha)$
			 		\end{tabular}
			 		\end{center}
			 	By application of the lemma \ref{red-context}, $\mathcal{L}_t \subseteq \mathcal{L'}_t$ and $\mathcal{L}_u \subset \mathcal{L'}_u$.
			 	Let $\sigma$ be the substitution $\sigma = [\, !^n\alpha \mapsto T]$. By application of the lemma \ref{tau-context}, 
			 		\begin{center}
			 		\begin{tabular}{l}
			 			$\text{ConstraintTyping} \, (\Gamma_1, !^I \Delta \vdash t : T \multimap U) = \sigma \mathcal{L'}_t$ \\
			 			$\text{ConstraintTyping} \, (\Gamma_2, !^I \Delta \vdash u : T) = \sigma \mathcal{L'}_u$
			 		\end{tabular}
			 		\end{center}
			 	From the induction hypothesis, it follows that there exist $\tau_1$ and $\tau_2$, such that
			 		\begin{center}
			 		\begin{tabular}{l}
			 			$|\tau_1| \cap (FV(\Gamma_1, !^I\Delta) \cup FV(T) \cup FV(U)) = \varnothing$ \\
			 			$|\tau_2| \cap (FV(\Gamma_2, !^I\Delta) \cup FV(T)) = \varnothing$ \\
			 			$\mathcal{L}_1 \vdash (\tau_1 \circ \sigma) \mathcal{L'}_t$ \\
			 			$\mathcal{L}_2 \vdash (\tau_2 \circ \sigma) \mathcal{L'}_u$
			 		\end{tabular}
			 		\end{center}
			 	Thus,
			 		\begin{center}
			 		\begin{tabular}{l}
			 			$\mathcal{L}_1 \vdash (\tau_1 \circ \sigma) \mathcal{L}_t$ \\
			 			$\mathcal{L}_2 \vdash (\tau_2 \circ \sigma) \mathcal{L}_u$
			 		\end{tabular}
			 		\end{center}
			 	Since the sets of variables mapped by $\tau_1$ and $\tau_2$ are distinct from the set of type variables currently used in the context, 
			 	they can be composed without any ambiguity, and
			 		\begin{center}
			 		\begin{tabular}{lcl}
			 			$(\tau_1 \circ \tau_2 \circ \sigma) \mathcal{L}'$ & $=$ & 
				 			$(\tau_1 \circ \tau_2 \circ \sigma) \mathcal{L}_t \cup (\tau_1 \circ \tau_2 \circ \sigma) \mathcal{L}_u \cup \{1 \le I\}$ \\
				 		& $=$ & $(\tau_1 \circ \sigma) \mathcal{L}_t \cup (\tau_2 \circ \sigma) \mathcal{L}_u \cup \{1 \le I\}$
			 		\end{tabular}
			 		\end{center}
			 	Consequently,
			 		$$ \mathcal{L} \vdash (\tau_1 \circ \tau_2 \circ \sigma) \mathcal{L'} $$
		\end{itemize}
	\end{proof}
\end{lemma}

\begin{prop} Let $t$ be a term. If there exists a typing derivation $\Pi$ of the typing judgement
	$\Gamma \vdash_\mathcal{L} t : T$, then for all types $T'$ and contexts $\Gamma'$ such that $\sigma T' = T$ and $\sigma \Gamma' = \Gamma$
	for some substitution $\sigma$, the constraint typing algorithm applied to $\Gamma' \vdash t : T'$ outputs a satisfiable set of
	constraint $\mathcal{L'}$.
	
	\begin{proof}
		Let $\Gamma \vdash_\mathcal{L} t : T$ be a valid typing judgement. Let $T'$, $\Gamma'$ and $\sigma$ be such that
		$\sigma T' = T$ and $\sigma \Gamma' = \Gamma$. By execution of the constraint typing algorithm :
			\begin{center}
			\begin{tabular}{l}
				$\text{ConstraintTyping} \, (\Gamma' \vdash t : T') = \mathcal{L'}$ \\
				$\text{ConstraintTyping} \, (\Gamma \vdash t : T) = \mathcal{L''}$
			\end{tabular}
			\end{center}
		From the lemma \ref{tau-context} we know that $\mathcal{L''} = \sigma \mathcal{L'}$, and from the lemma \ref{incl-set} that
		there exists a substitution $\tau$ such that $\mathcal{L} \vdash \tau \mathcal{L''}$, and
		$|\tau| \cap (FTV(\Gamma) \cup FTV(T)) = \varnothing$. Having a separate domain, the substitutions $\sigma$ and $\tau$ can be composed.
		Thus $\mathcal{L} \vdash (\tau \circ \sigma) \mathcal{L'}$.
		By validity of the typing derivation, the set $\mathcal{L}$ is satisfiable.
		Let $\rho$ be a solution of $\mathcal{L}$. Then $\rho$ is also a solution of $(\tau \circ \sigma) \mathcal{L'}$, and
		$(\rho \circ \tau \circ \sigma)$ is a solution of $\mathcal{L'}$, which is thus satisfiable.
	\end{proof}
\end{prop}

\begin{prop} Let $t$ be a term, $T$ a LL' type and $\Gamma$ a context. If the return set $\mathcal{L}$ of the constraint typing
	algorithm is satisfiable, then there is a typing derivation $\Pi$ of the typing judgement $\Gamma \vdash_\mathcal{L}$.
	
	\begin{proof}
		By induction on the form of the term $t$, we can construct a valid typing derivation of the typing judgement
		$\Gamma \vdash_\mathcal{L} t : T$.
		If the term is
		\begin{itemize}
			\item $x$, the algorithm applied to $!^I \Gamma, x : T \vdash x : U$ produces the set
				$\mathcal{L} = \{ T <: U \} \cup \{ 1 \le I \}$. $\mathcal{L}$ being satisfiable, the typing derivation
				\begin{prooftree}
					\AxiomC{}
					\RightLabel{$(ax)$}
					\UnaryInfC{$!^I \Gamma, x : T \vdash_\mathcal{L} x : U$}
				\end{prooftree}
				holds.
				
			\item $t u$, the algorithm applied to $\Gamma \vdash t u : T$ makes two recursive calls on
				$\Gamma_1, !^I \Delta \vdash t : \alpha \multimap T$ and $\Gamma_2, !^I \Delta \vdash u : \alpha$, where
				$\Gamma_1 = \Gamma |_{FV(t)}$, $\Gamma_2 = \Gamma |_{FV(u)}$ and $!^I \Delta = \Gamma |_{FV(t) \oplus FV(u)}$, and
				$\alpha$ is fresh. If the outputs of the recursive calls are $\mathcal{L}_1$ and $\mathcal{L}_2$, the output of
				the algorithm is $\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$. Since $\mathcal{L}$ is satisfiable, so are
				$\mathcal{L}_1$ and $\mathcal{L}_2$. By induction, we can build two valid typing derivation $\Pi_1$ and $\Pi_2$ of the typing
				judgements $\Gamma_1, !^I \Delta \vdash_{\mathcal{L}_1} t : \alpha \multimap T$ and
				$\Gamma_2, !^I \Delta \vdash_{\mathcal{L}_2} u : \alpha$. Using both derivations $\Pi_1$ and $\Pi_2$ and the typing
				rule $(app)$ of LL, we build a valid typing derivation of $\Gamma \vdash_\mathcal{L} t u : T$
				
			\item $\lambda x.t$, the algorithm makes one recursive call on $!^I \Gamma, x : !^n \alpha \vdash t : \beta$, producing the
				set $\mathcal{L}$. The output of the algorithm is then
					$\mathcal{L'} = \mathcal{L} \cup \{ !^m(!^n \alpha \multimap \beta) <: T \} \cup \{n \le I\}$. Since $\mathcal{L'}$
					is satisfiable, so is $\mathcal{L}$. By the induction hypothesis, we can build a valid typing derivation $\Pi$ of the
					typing judgement $!^I \Gamma, x :\, !^n \alpha \vdash_\mathcal{L} t : \beta$, from which we can derive :
						\begin{prooftree}
							\AxiomC{$\Pi$} \noLine
							\UnaryInfC{$\vdots$} \noLine
							\UnaryInfC{$!^I \Gamma, x :\, !^n \alpha \vdash_\mathcal{L} t : \beta$}
							\RightLabel{$(\lambda)$}
							\UnaryInfC{$!^I \Gamma \vdash_{\mathcal{L} \cup \{1 \le I\}} \lambda x.t :\, !^m(!^n \alpha \multimap \beta)$}
							\RightLabel{sub-typing}
							\UnaryInfC{$!^I \Gamma \vdash_{\mathcal{L} \cup \{1 \le I\} \cup \{ !^m(!^n \alpha \multimap \beta) <: T\}} \lambda x.t : T$}
						\end{prooftree}					
					
		\end{itemize}
	\end{proof}
\end{prop}

\section{Unification}

\begin{defn}{unification algorithm} \\
	The algorithm inputs a set of linear constraints $\mathcal{L}$, and returns
	a substitutions $\sigma$ associated with a set of atomic constraints $\mathcal{L'}$ such that
	$\mathcal{L'} \vdash \sigma \mathcal{L}$.
	
  \begin{itemize}
  	\item{\bf Step 0 : reduction of composite constraints} The following reduction rules are applied recursively to all the composite
  		constraints in $\mathcal{L}$ : if the constraint $c$ is :
  		\begin{itemize}
      	\item $T \multimap U <: T' \multimap U'$, replace $c$ by $T' <: T$ and $U <: U'$
      	\item $!^n T <: \, !^m U$, replace $c$ by $T <: U$ and $m \le n$
      	\item For any other composite constraint, the algorithm fails. Since all the types must be annotated, no constraint
      		$!^n T <: U$ or $U <: !^n T$ may appear, where $U$ is not of the form $!^m U'$.
      \end{itemize}
      When all the composite constraints have been reduced, there remains a set of constraints either atomic ($\alpha <: \beta$) or
      semi-composite ($T <: \alpha$ or $\alpha <: T$).  		
  		
  	\item{\bf Step 1 : variable ordering} The purpose of this step is to sort variables topologically, from youngest to oldest,
  	  so that the youngest variable may not appear in any composite type. This is done by defining an age for every variable, with the
  	  relations :
  	  	\begin{center}
  	  	\begin{tabular}{l}
  	  		For all constraint $\alpha <: T$ or $T <: \alpha$, $\forall \beta \in FV(T), ~ Age (\alpha) < Age (\beta)$ \\
  	  		For all constraint $\alpha <: \beta$, $Age (\alpha) = Age (\beta)$
  	  	\end{tabular}
  	  	\end{center}
  	  This step may fail to attribute an age to a variable, for example with the constraint $\alpha <: \alpha \multimap \beta$, and
  	  in general for all cyclic dependencies.
  	  
  	\item{\bf Step 2} Let $\alpha_1 \dots \alpha_n$ be the the youngest variables, chained together by atomic constraints
  		$\alpha_i <: \alpha_j$. Each variable $\alpha_i$ is associated with non atomic constraints $T_i^1 \dots T_i^{n_i} <: \alpha_i
  		<: U_i^1 \dots U_i^{m_i}$. Let $V$ be one of these composite types.
  		If the type $V$ is
  		\begin{itemize}
  			\item $A \multimap B$ : for all $\alpha_i$, a mapping $\alpha_i \mapsto ~ !^{f_i} (\beta_i \multimap \gamma_i)$ is generated,
  				with $f_i, \beta_i$ and $\gamma_i$ fresh.
  			\item $!^n T$ : for all $\alpha_i$, a mapping $\alpha_i \mapsto ~ !^{f_i} \beta_i$ is generated,
  				with $f_i$ and $\beta_i$ fresh.
  		\end{itemize}
		  $\alpha_1 \dots \alpha_n$ are then replaced in the constraints by their mappings, which constraints are immediately reduced
		  using the rules from step 0. Step 2 is reiterated until all the composite types are reduced.  	
  \end{itemize}

	At the end of the first part, we get a substitution $\sigma$, and the remaining sub-typing constraints are atomic.
	
	The second part of the unification algorithm concentrates on the flag constraints.
	The problem is equivalent to cycle elimination in orientated graphs, where the nodes are the flags
	$n, m \dots$, extended with two nodes $0$ and $1$. The edges are defined by the flag constraints :
	for each constraint $n \le m$, there is a corresponding edge $m \rightarrow n$.
	A loop $n_1 \le \dots \le n_p \le n_1$ gives a set of equal flags. If a loop contains both nodes $0$ and $1$, the
	flag unification fails, else the substitutions $[n_2 \mapsto n_1 \dots n_p \mapsto n_1]$ are added to $\tau$.
	The output of the unification is a substitution $\tau$ and a set of remaining constraints $n \le m$ where neither
	$n$ nor $m$ is $0$ or $1$.

\end{defn}

\end{document}