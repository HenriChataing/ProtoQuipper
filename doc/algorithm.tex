
\subsection{The $\QP'$ Language}

The grammar of core Proto-Quipper is rather extensive, so in the interest of readability, we formalize the type inference algorithm on a smaller fragment of the language. In Section~\ref{ssec-extending-to-QP}, we will explain how to extend type inference to all of core Proto-Quipper. To avoid confusing, we will denote core Proto-Quipper by $\QP$, and the smaller fragment by $\QP'$.

We will introduce the concepts of type inference that are specific to
linear type inference. However, we will presuppose a certain amount of
familiarity with type inference in general.  For a more comprehensive
introduction to type inference, including a discussion of the
significance of type variables and the different understandings of
type inference, please refer to Chapter 22 of Pierce {\cite{pierce02}}.

\begin{defn} The \emph{terms} of $\QP'$ are defined by:
	\begin{center}
	\begin{tabular}{rrl}
		$\texttt{Term}$&$ ~t,u~ ::=$ & $x ~|~ * ~|~ \lambda x.t ~|~ t \, u ~|~ \pair{t}{u} ~|~ \letin{\pair{x}{y}}{t}{u}. $
	\end{tabular}
	\end{center}
\end{defn}

For the purpose of type inference, it would seem natural to define the type system of $\QP'$ by extending the types of $\QP$ with type variables. This would give the following grammar for types:
	\begin{center}
	\begin{tabular}{rrl}
		$\texttt{Type}$&$ ~A,B~ ::=$ & $\alpha ~|~ 1 ~|~ A \multimap B ~|~ A \otimes B ~|~ \bang A$.
	\end{tabular}
	\end{center}
This would have been sufficient if the types were not linear. However, we need to be able to separately discuss the \textit{form} of a type (for example $\qubit$, $\bool \otimes \bool$) and its \textit{linearity} (whether the type is duplicable or not). We therefore introduce a new grammar which, though less intuitive, offers more control over the form of a type.

\begin{defn} The \emph{types} of $\QP'$ are defined by:
	\begin{center}
	\begin{tabular}{rrl}
		$\texttt{Flag}$&$~i~ ::=$ & $n ~|~ 0 ~|~ 1$ \\		
		$\texttt{LinearType}$&$ ~A~ ::=$ & $\alpha ~|~ 1 ~|~ T \multimap U ~|~ T \otimes U$ \\
		$\texttt{Type}$&$ ~T,U~ ::=$ & $!^i A$.
	\end{tabular}
	\end{center}
\end{defn}

Flags, linear types and types are to be interpreted as follows:
\begin{itemize}
	\item $\texttt{LinearType}$ corresponds to the subset of $\QP$ types that are always linear at the outermost level.
	\item $\texttt{Type}$ is set of all types. Depending of the value of its prefixing flag, a $\texttt{Type}$ is duplicable or not.
		In practice, the type of a term will always be represented by a \texttt{Type}, never by a \texttt{LinearType}.
	\item $\texttt{Flag}$ consists of \textit{flag variables} and the constants $0$ and $1$. They parameterize the linearity of a type.
		If the value of $n$ is $1$, then $!^n A$ is duplicable; if it is $0$, then $!^n A$ is linear. This idea is that $!^1A=!A$ and $!^0A=A$. For example, the type
		of any quantum bit will be $!^0 \qubit$.
\end{itemize}
Using a grammar that distinguishes linear types and types also allows us to unambiguously define substitutions as mappings from type variables to \textit{linear} types. This distinction was impossible to make in $\QP$. We will use the following notation:
\begin{itemize}
	\item $\alpha, \beta \dots$ for type variables, taken in the set $\vset$.
	\item $n, m \dots$ for flag variables, taken in the set $\fset$.
	\item $A, B \dots$ for linear types.
	\item $T, U \dots$ for types.
\end{itemize}

\begin{defn} The subtyping relation $<:$ is the smallest relation on types and linear types satisfying the rules given in Figure \ref{subtypingQP'}.
\end{defn}

\begin{figure}[!ht]
\begin{mdframed}
	$$ $$
	$$ \mbox{
  	\AxiomC{}
  	\RightLabel{$(var)$}
	 	\UnaryInfC{$\alpha <: ~ \alpha$}
	 	\DisplayProof
		~~
		~~
		\AxiomC{}
	 	\RightLabel{$(1)$}
	 	\UnaryInfC{$1 <: 1$}
		\DisplayProof
		~~
		~~
	 	\AxiomC{$A <: B$}
	 	\AxiomC{$m \le n$}
	 	\RightLabel{$(!)$}
	 	\BinaryInfC{$!^n A <: ~ !^m B$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
	 	\AxiomC{$T' <: T$}
	 	\AxiomC{$U <: U'$}
	 	\RightLabel{$(\multimap)$}
	 	\BinaryInfC{$T \multimap U <: T' \multimap U'$}
		\DisplayProof
		~~
		~~
	 	\AxiomC{$T <: T'$}
	 	\AxiomC{$U <: U'$}
	 	\RightLabel{$(\otimes)$}
	 	\BinaryInfC{$T \otimes U <: T' \otimes U'$}
		\DisplayProof
	} $$
	$$ $$
\end{mdframed}
\caption{The sub-typing relation rules of $\QP'$.}
\label{subtypingQP'}
\end{figure}

\begin{proposition} \it The subtyping relation is reflexive and transitive.
\end{proposition}

The notion of a typing context, and the extension of the subtyping relation to typing contexts, are straightforwardly adapted from $\QP$. We introduce the following new notations for the typing contexts of $\QP'$. We write $\Gamma|_t$ to represent the context $\Gamma$ where only the bindings $x : T$ with $x \in FV(t)$ appear. Similarly, the notation $\Gamma \backslash_t$ designates the context $\Gamma$ where the bindings $x : T$ for $x \in FV(t)$ have been removed. Finally, we write $!^I \Gamma$ to represent contexts of the form $\Gamma = x_1 : \nbang{i_1} T_1 ~ \dots ~ x_n : \nbang{i_n} T_n$, with $I = \{i_1 \dots i_n\}$.

The typing rules have to be adapted to the new grammar of types.

\begin{defn}
A \emph{typing judgement} is an expression of the form:
\[
\Gamma \vdash t:T
\] 
where $\Gamma$ is a typing context, $t$ is a term and $T$ is a type. A typing judgment is \emph{valid} if it can be inferred from the rules given in Figure \ref{typingQP'}.
\end{defn}

As in $\QP$, a typing judgement should be interpreted as stating that under the assumptions $\Gamma$, the term $t$ has the type $T$. 

\begin{remark} For the most part, the typing rules of $\QP'$ are those of $\QP$ adapted to the different syntax of types. This is not quite the 
	case of the rules for $\otimes$. Recall that the typing rule for $\pair{a}{b}$ in $\QP$ was (omitting the quantum contexts):
		\begin{prooftree}
			\AxiomC{$\Gamma_1, !\Delta \vdash a : \,!^nA$}
			\AxiomC{$\Gamma_2, !\Delta \vdash b : \,!^nB$}
			\RightLabel{$(\otimes.I)$}
			\BinaryInfC{$\Gamma_1, \Gamma_2, !\Delta \vdash \pair{a}{b} : \,!^n(A \otimes B)$}
		\end{prooftree}
	This rule expresses the fact that the pair $\pair{a}{b}$ is duplicable if and only if both $a$ and $b$ are duplicable. However, the grammar of 
	$\QP'$ types doesn't allow us to move the $!$ annotation around. This is why the rule $(\otimes.I)$ of $\QP'$ uses the type 
	$!^p(!^nA \otimes \,!^mB)$ with the condition that $p$ can be $1$ if and only if both $n$ and $m$ are equal to one. This results in 
	the duplicable pair $\pair{a}{b}$ having the type $!^1(!^1 A \otimes \,!^1B)$ rather than $\bang (A \otimes B)$. A similar remark applies 
	to the $(\otimes.E)$ rule.
\end{remark}

\begin{exmp} The term $\lambda x.\pair{x}{x}$ can be typed in the empty context with the type 
	$!^1(!^1 A \multimap \,!^0(!^1A \otimes !^1A)$. The typing derivation is
		\begin{prooftree}
			\AxiomC{$!^1A <: \,!^1A$}
			\RightLabel{$(ax)$}
			\UnaryInfC{$x : \,!^1A \vdash x : \,!^1A$}
			\AxiomC{$!^1A <: \,!^1A$}
			\RightLabel{$(ax)$}
			\UnaryInfC{$x : \,!^1A \vdash x : \,!^1A$}
			\RightLabel{$(\otimes.I)$}
			\BinaryInfC{$x : \,!^1A \vdash \pair{x}{x} : \,!^0(!^1A \otimes !^1A)$}
			\RightLabel{$(\lambda_2)$}
			\UnaryInfC{$\varnothing \vdash \lambda x.\pair{x}{x} : \,!^1(!^1 A \multimap !^1(!^1A \otimes !^1A))$}
		\end{prooftree}
\end{exmp}

\begin{figure}[!ht]
\begin{mdframed}
	$$ $$
	$$ \mbox{
		\AxiomC{$T <: U$}
		\RightLabel{$(ax)$}
		\UnaryInfC{$!^1 \Delta, x : T \vdash x : U$}
		\DisplayProof
		~~
		~~
		~~
		\AxiomC{}
		\RightLabel{$(1)$}
		\UnaryInfC{$!^1 \Delta \vdash * : \,!^n 1$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$\Gamma, x : T \vdash t : U$}
		\RightLabel{$(\lambda_1)$}
		\UnaryInfC{$\Gamma \vdash \lambda x.t : \,!^0 (T \multimap U)$}
		\DisplayProof
		~~
		~~
		\AxiomC{$!^1 \Gamma, x : T \vdash t : U$}
		\RightLabel{$(\lambda_2)$}
		\UnaryInfC{$!^1 \Gamma \vdash \lambda x.t : \,!^1 (T \multimap U)$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$\Gamma_1, !^1\Delta \vdash t : \,!^0(T \multimap U)$}
		\AxiomC{$\Gamma_2, !^1\Delta \vdash u : T$}
		\RightLabel{$(app)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash t u : U$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$\Gamma_1, !^1\Delta \vdash t : \, !^nA$}
		\noLine
		\UnaryInfC{$\Gamma_2, !^1\Delta \vdash u : \, !^mB$}
		\AxiomC{$p \le n, ~ p \le m$}
		\RightLabel{$(\otimes.I)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash \, \pair{t}{u} \, : \,!^p(!^nA \otimes \,!^mB)$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$\Gamma_1, \,!^1\Delta \vdash t : \, !^p (!^nA \otimes \,!^mB)$}
		\noLine
		\UnaryInfC{$\Gamma_2, \,!^1\Delta, x : \,!^nA, y : \,!^nB \vdash u : T$}
		\AxiomC{$p \le n, ~ p \le m$}
		\RightLabel{$(\otimes.E)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash \, \text{let} \pair{t}{u} = t ~ \text{in} ~ u \, : T$}
		\DisplayProof
	} $$
	$$ $$
\end{mdframed}
\caption{The typing rules of $\QP'$.}
\label{typingQP'}
\end{figure}

The correspondence between the type systems for $\QP$ and $\QP'$ is established in the following theorem:

\begin{thm}{\bf (Soundness and completeness).} Let $t$ be a $\QP'$ term. There exists two transformations $\tau$ and
	$\bar \tau$ defined on types as functions respectively from $\QP$ to $\QP'$ types, and $\QP'$ to $\QP$ types, satisfying the properties:
	\begin{enumerate}
		\item If there exist a context $\Gamma$ and a type $T$ such that the typing judgement $\Gamma \vdash t : T$ is valid in $\QP$, then
			$\tau\Gamma \vdash t : \tau T$ is valid in $\QP'$.
		\item If there exist a context $\Gamma$ and a type $T$ such that the typing judgement $\Gamma \vdash t : T$ is valid in $\QP'$, then
			$\bar \tau \Gamma \vdash t : \bar \tau T$ is valid in $\QP$.
	\end{enumerate}
	
	\begin{proofsketch}
		The transformations $\tau$ and $\bar \tau$ can be written as recursive functions on types. Their definition will not be explained
		here. The proof is a simple induction on the typing derivation of $\Gamma \vdash t : T$. The cases of $(\otimes.I)$ and
		$(\otimes.E)$ use the isomorphism $\bang\bang A \equiv \bang A$ of $\QP$-types.
	\end{proofsketch}
\end{thm}

\begin{remark}
	This theorem is necessary to ensure the validity of the type inference algorithm: by proving that
	terms can be typed in either $\QP$ or $\QP'$ with similar judgements, we ensure that:
	\begin{itemize}
		\item If the algorithm infers a typing judgement valid in $\QP'$, then it is possible to derive a typing judgement valid in $\QP$.
		\item Conversely, if the inference fails to produce such a judgement, then $t$ is surely not typeable in $\QP$.
	\end{itemize}
\end{remark}

\begin{lemma} The type system satisfies the following properties:
	\label{QP'prop}
	\begin{enumerate}
		\item Suppose $\Gamma \vdash t : T$ is a valid typing judgement in $\QP'$. Let $\Delta$ and $U$ be such that
			$\Delta <: \Gamma$ and $T <: U$. Then $\Delta \vdash t : U$ is valid.
	
		\item Suppose $\Gamma \vdash t : T$ is a valid typing judgement in $\QP'$. Then for any context $!^1 \Delta$ distinct from $\Gamma$;
			$\Gamma, \,!^1\Delta \vdash t : T$ is valid as well.
	
		\item Suppose $\Gamma, x : \,!^1 T \vdash t : T$ with $x \notin FV(t)$ is a valid typing judgement in $\QP'$.
			Then $\Gamma \vdash t : T$ is valid as well.
	\end{enumerate}
	
	\begin{proof}
		The properties are proved by induction on the typing derivation of $t$.
	\end{proof}
\end{lemma}

\begin{remark}
Note that the weaker statement
``\textit{If $\Gamma \vdash t : T$ and $T <: U$, then $\Gamma \vdash t : U$}'' cannot be proved directly by induction, because the case for
$\lambda x.t$ requires a relation of sub-typing on the context, and thus requires the stronger induction hypothesis.
\end{remark}

\begin{coro} The following typing rules are admissible in $\QP'$ :
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t : T$}
		\AxiomC{$T <: U$}
		\RightLabel{Sub-typing}
		\BinaryInfC{$\Gamma \vdash t : U$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t : T$}
		\AxiomC{$x \notin |\Gamma|$}
		\RightLabel{Weakening}
		\BinaryInfC{$\Gamma, x : \,!^1A \vdash t : T$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma, x : \,!^1A \vdash t : T$}
		\AxiomC{$x \notin FV(t)$}
		\RightLabel{Refining}
		\BinaryInfC{$\Gamma \vdash t : T$}
	\end{prooftree}
\end{coro}

\subsection{Constraint Typing}

Unless otherwise stated, $\QP'$ is the default language for the rest of this section.

\begin{defn} A \textit{substitution} is a finite list of mappings $(\alpha \mapsto A)$ or $(n \mapsto \s{0, 1})$
	from type variables to \textit{linear} types and from flag variables to either $0$ or $1$.
	We write $dom(\sigma)$ for the set of variables appearing on the left-hand sides of the mappings, and $range(\sigma)$ for the set of variables
	appearing on the right-hand sides of pairs in $\sigma$. We also use $vDom$, $vRange$, $fDom$ and $fRange$ for the subsets of $dom$ and $range$
	that contain respectively the type variables and the flag variables.
	The application of a substitution $\sigma$ to types and linear types is defined in the obvious way:
	$$
	\begin{array}{lcl}
		\sigma (\alpha) &=& \left\{ \begin{array}{l}
		                              A \text{ if } (\alpha \mapsto A) \in \sigma \\
      		                        \alpha \text{ if not}
		                            \end{array} \right. \\
		\sigma(1) &=& 1 \\
		\sigma(T \otimes U) &=& \sigma T \otimes \sigma U \\
		\sigma(T \multimap U) &=& \sigma T \multimap \sigma U \\
		\sigma(!^n A) &=& \left\{ \begin{array}{l}
																	!^{0} \sigma A \text{ if } (n \mapsto 0) \in \sigma \\
																	!^{1} \sigma A \text{ if } (n \mapsto 1) \in \sigma \\
																	!^n \sigma A \text{ otherwise}
																\end{array} \right. \\
	\end{array}
	$$
\end{defn}	

Note that variables may appear in both $dom(\sigma)$ and $range(\sigma)$. The intention in such cases is for the mappings of $\sigma$ to
be applied simultaneously. The definition of $\sigma$ ensures that the kind of a type is left untouched: a linear type is mapped to a linear
type, and a type is mapped to a type. The substitution $\sigma$ is extended to contexts by defining
 		$$\sigma (x_1 : T_1 \dots x_n : T_n) = (x_1 : \sigma T_1 \dots x_n : \sigma T_n)$$
 		
\begin{defn} If $\sigma$ and $\tau$ are substitutions, we write $\sigma \circ \tau$ for the composition of $\sigma$ with $\tau$, defined as follows
		$$\tau \circ \sigma = \left[ \begin{array}{ll}
																			\alpha \mapsto \tau A & \text{for each } (\alpha \mapsto A) \in \sigma \\
																			\alpha \mapsto A & \text{for each } (\alpha \mapsto A) \in \tau \text{ with } \alpha \notin vDom(\sigma) \\
																			n \mapsto \sigma(n) & \text{for each } n \in fDom(\sigma) \\
																			n \mapsto \tau(n) & \text{for each } n \in fDom(\tau) \text{ with } n \notin fDom(\sigma) \\
																		\end{array} \right]$$
\end{defn}

The composition is associative: $\sigma \circ (\tau \circ \rho) = (\sigma \circ \tau) \circ \rho$. We say that a substitution
$\sigma$ is \textit{idempotent} if it satisfies $\sigma \circ \sigma = \sigma$. It can be proved in particular that $\sigma \neq Id$ is idempotent if $dom(\sigma) \cap range(\sigma) = \varnothing$. Because working with substitutions $\sigma$ such that
$\sigma \neq \sigma \circ \sigma$ can be really cumbersome, we consider in the following that all substitutions are chosen idempotent.

Substitutions preserve the validity of typing judgements. If a term $t$ is well-typed with the
type $T$ in the context $\Gamma$, then for any substitution $\sigma$, $\sigma \Gamma \vdash t : \sigma T$ is valid.

\begin{thm}
	\label{subs-judgement}
	Suppose a valid typing judgement $\Gamma \vdash t : T$. Then for every substitution $\sigma$, $\sigma \Gamma \vdash t : \sigma T$
	is valid.
\end{thm}

We now formalize the problem of type inference. 
Suppose $\Gamma$ a typing context, $t$ a term and $T$ a type, not necessarily satisfying $\Gamma \vdash t : T$. The purpose of type inference is to answer the question:
 \begin{center}
 	 ``Is \text{some} substitution instance of $t$ well-typed?"
 \end{center}
That is, can we find $\sigma$ such that $\sigma \Gamma \vdash t : \sigma T$ is well typed? Looking for valid instantiations of the
variables of $\Gamma, T$ leads to the problem of type inference. The set of all such substitutions is taken as the set of solutions
for the following problem:

\begin{defn}
	\label{decl_problem}
	Suppose $\Gamma$ a typing context, $t$ a term and $T$ a type. A substitution $\sigma$ is a solution for the problem $(\Gamma, t, T)$ if
	$\sigma \Gamma \vdash t : \sigma T$ is a valid typing judgement.
\end{defn}

\begin{exmp} Let $f$ be $\lambda x.x$ of type $!^n \alpha$, $a$ of type $!^m \beta$ and $t = f \, a$. Then the following 	are solutions for $(\varnothing, t, !^p \gamma)$:
  \[
  \begin{array}{l}\relax
    [{!}^n\alpha \mapsto {!}^1({!}^0\intx \multimap {!}^1\intx),~~ {!}^m\beta \mapsto {!}^1\intx,~~ {!}^p\gamma \mapsto {!}^1\intx], \\\relax
    [{!}^n\alpha \mapsto {!}^0({!}^0\qubit \multimap {!}^0\bit),~~ {!}^m\beta \mapsto {!}^0\qubit,~~ {!}^p\gamma \mapsto {!}^0\qubit], \\\relax
    [{!}^n\alpha \mapsto {!}^0({!}^1\intx \multimap {!}^0({!}^1\intx \otimes {!}^1\intx)),
    ~~ {!}^m\beta \mapsto {!}^1\intx,
    ~~ {!}^p\gamma \mapsto {!}^0({!}^1\intx \otimes {!}^1\intx)].
  \end{array}
  \]
\end{exmp}

\subsubsection{The Constraint Typing Relation}

\begin{defn} We introduce {\em sub-typing constraints} $X \prec: Y$ for $X, Y \in \texttt{Type}$ or $X, Y \in \texttt{LinearType}$.
We say that a constraint $X \prec: Y$ is:
		\begin{center}
		\begin{tabular}{l}
			\textit{atomic} if it is of the form $\alpha \prec: \beta$. \\
			\textit{semi-composite} if it is of the form $\alpha \prec: A$ or $A \prec: \alpha$ with $A \notin \vset$. \\
			\textit{composite} if it is of the form $X \prec: Y$ with $X, Y \notin \vset$.
		\end{tabular}
		\end{center}
  Similarly, flag constraints $n \le m$ are defined over flag variables and the constants $0$ and $1$. Flag constraints are atomic if of the form $n \le m$,
  for $m, n\in \fset$.
  A substitution $\sigma$ solves a constraint $T \prec: U$ ($n \le m$) if and only if $\sigma T <: \sigma U$ ($\sigma(n) \le \sigma(m)$).
\end{defn}

Though all flag constraints are written in the same form $(. \le .)$, they can hold different meanings, for example
	\begin{center}
	\begin{tabular}{ll}
		$n \le 0$ & can be viewed as $n = 0$, \\
 		$1 \le m$ & is the constraint $m = 1$, \\
 		$n \le m$ & can be interpreted as $n = 1 \Rightarrow m = 1$.
 	\end{tabular}
 	\end{center}

\begin{defn} A {\em constraint set} $\lset$ is a set of constraints $\{ A \prec: B \dots, T \prec: U \dots, n \le m \dots\}$
	over linear types, types and flags.
  A constraint set can have the following properties:
  \begin{itemize}
  	\item[]{\bf Atomicity} A set is atomic when all the constraints contained are atomic.
  	\item[]{\bf Satisfiability} A set is \textit{solved} when all the included constraints can be solved by application of one or
  		more of the sub-typing rules (type constraints) or by transitivity (flag constraints).
  		Thus, a set $\lset$ is \textit{solvable} if there exists a substitution $\sigma$ such that $\sigma \lset$ is solved.
	 	\item[]{\bf Derivability} When the validity of a set $\mathcal{L}$ can be deduced from another set $\mathcal{L'}$ by application of
		  the sub-typing rules and the transitivity, we say that $\lset$ is \textit{derivable} from $\lset'$,
		  written $\lset' \vdash \lset$.
  \end{itemize}
\end{defn}

\begin{defn} The \textit{constraint typing relation} $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$ is defined by the constraint typing rules
	of Figure \ref{ctypeQP'}. It it to be interpreted as: \textit{Under the assumptions $\Gamma$, when the constraints $\lset$ are solved,
	the term $t$ has the type $T$}. 
\end{defn}

The set $\chi$ keeps track of the type and flag variables created during the construction of the derivation
of the typing judgement $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$. 

\begin{algorithm}{\bf (ConstraintTyping).}
The constraint typing algorithm is obtained by reading the
constraint typing rules from bottom to top. It can be verified that the algorithm is indeed deterministic, whereas the typing
rules of $\QP'$ were not (see the rules $(\lambda_1)$ and $(\lambda_2)$). 
The function ConstraintTyping applies the constraint
typing algorithm to a typing judgement $\Gamma \vdash t : T$, and either fails, or returns a set $\mathcal{L}$ (and as a by-product the set of
variables $\chi$) such that the relation $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$ holds.
\end{algorithm}	

\begin{figure}[!ht]
\begin{mdframed}
	$$ $$
	$$ \mbox{
		\AxiomC{$\mathcal{L} = \{1 \le I, ~ T \prec: U\}$}
		\RightLabel{$(ax)$}
		\UnaryInfC{$!^I \Delta, x : T \vdash_\mathcal{L} x : U ~|_\varnothing$}
		\DisplayProof
		~~
		~~
		\AxiomC{$\mathcal{L} = \{1 \le I, ~ \,!^1 1 \prec: T \}$}
		\RightLabel{$(\top)$}
		\UnaryInfC{$!^I \Delta \vdash_\mathcal{L} * : T ~|_\varnothing$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$!^I\Gamma, x : \,!^n\alpha \vdash_\mathcal{L'} t : \,!^m\beta ~|_\chi$} \noLine
		\UnaryInfC{$\alpha, \beta, n, m, p \notin \Gamma, T$} \noLine
		\UnaryInfC{$\mathcal{L} = \mathcal{L'} \cup \{ p \le I, ~ !^p(!^n\alpha \multimap \,!^m\beta) \prec: T \}$}
		\RightLabel{$(\lambda)$}
		\UnaryInfC{$\Gamma \vdash_\mathcal{L} \lambda x.t : T ~|_{\chi \cup \{\alpha, \beta, n, m, p \}}$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$\Gamma|_u \vdash_{\mathcal{L}_2} u : \,!^n\alpha ~|_{\chi_2}$} \noLine
		\UnaryInfC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : \,!^0(!^n\alpha \multimap T) ~|_{\chi_1}$} \noLine
		\AxiomC{$\chi_1 \cap \chi_2 = \varnothing$} \noLine
    \UnaryInfC{$\alpha, n \notin \Gamma, T$} \noLine
    \UnaryInfC{$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$} \noLine
    \UnaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$}
		\RightLabel{$(app)$}
		\BinaryInfC{$\Gamma \vdash_\mathcal{L} t \, u : T ~|_{\chi_1 \cup \chi_2 \cup \{ \alpha, n\}}$}
		\DisplayProof
	} $$
	$$ $$	
	$$ \mbox{
		\AxiomC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : \, !^n\alpha ~|_{\chi_1}$} \noLine
		\UnaryInfC{$\Gamma|_u \vdash_{\mathcal{L}_2} u : \, !^m\beta ~|_{\chi_2}$}
		\AxiomC{$\chi_1 \cap \chi_2 = \varnothing$} \noLine
		\AxiomC{$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$} \noLine
		\BinaryInfC{$\alpha, \beta, n, m, p \notin \Gamma, T$} \noLine
		\BinaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I, p \le n, p \le m ~!^p(!^n\alpha \otimes \,!^m\beta) \prec: T \}$}
		\RightLabel{$(\otimes.I)$}
		\UnaryInfC{$\Gamma \vdash_\mathcal{L} \, \pair{t}{u} \, : T ~|_{\chi_1 \cup \chi_2 \cup \{\alpha, \beta, n, m, p \}}$}
		\DisplayProof
	} $$
	$$ $$
	$$ \mbox{
		\AxiomC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : \, !^p (!^n\alpha \otimes \,!^m\beta) ~|_{\chi_1}$} \noLine
		\UnaryInfC{$\Gamma|_u, x : \,!^n\alpha, y : \,!^m\beta \vdash_{\mathcal{L}_2} u : T ~|_{\chi_2}$}
		\AxiomC{$\chi_1 \cap \chi_2 = \varnothing$} \noLine
		\UnaryInfC{$\alpha, \beta, n, m, p \notin \Gamma, T$} \noLine
		\UnaryInfC{$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$} \noLine
		\BinaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ p \le n, p \le m, 1 \le I \}$}
		\RightLabel{$(\otimes.E)$}
		\UnaryInfC{$\Gamma \vdash_\mathcal{L} \, \text{let} \pair{x}{y} = t ~ \text{in} ~ u \, : T ~|_{\chi_1 \cup \chi_2 \cup \{\alpha,\beta,m,n,p \}}$}
		\DisplayProof
	} $$
	$$ $$
\end{mdframed}
\caption{Constraint typing rules.}
\label{ctypeQP'}
\end{figure}

\begin{exmp} The same example term $\lambda x.\pair{x}{x}$ can be typed using the constraint typing rules, with the derivation
	\begin{prooftree}
			\AxiomC{}
			\RightLabel{$(ax)$}
			\UnaryInfC{$x : \,!^{n_1}\beta \vdash_{\{!^{n_1}\beta \prec: \,!^{n_5}\epsilon\}} x : \,!^{n_5}\epsilon$}
			\AxiomC{}
			\RightLabel{$(ax)$}
			\UnaryInfC{$x : \,!^{n_1}\beta \vdash_{\{!^{n_1}\beta \prec: \,!^{n_4}\delta\}} x : \,!^{n_4}\delta$}
			\RightLabel{$(\otimes.I)$}
			\BinaryInfC{$x : \,!^{n_1}\beta \vdash_{\left\{ \scriptsize
			                                          \begin{array}{lll} 
			                                            !^{n_1}\beta \prec: \,!^{n_4}\delta, & n_6 \le n_4 &
			                                            	 !^{n_6}(!^{n_4}\delta \otimes \,!^{n_5}\epsilon) \prec: !^{n_2}\gamma \\
			                                            !^{n_1}\beta \prec: \,!^{n_5}\epsilon, & n_6 \le n_5 & 1 \le n_1
	  		                                        \end{array} \right\}}
			                                        \pair{x}{x} : \,!^{n_2}\gamma$}
			\RightLabel{$(\lambda)$}
			\UnaryInfC{$\varnothing \vdash_{\left\{ \scriptsize
			                                          \begin{array}{lll} 
			                                            !^{n_1}\beta \prec: \,!^{n_4}\delta, & n_6 \le n_4 &
			                                            	 !^{n_6}(!^{n_4}\delta \otimes \,!^{n_5}\epsilon) \prec: !^{n_2}\gamma \\
			                                            !^{n_1}\beta \prec: \,!^{n_5}\epsilon, & n_6 \le n_5 &
			                                              !^{n_3} (!^{n_1} \beta \multimap !^{n_2}\gamma) \prec: \,!^{n_0} \alpha \\
			                                            & 1 \le n_1 &
	  		                                        \end{array} \right\}} \lambda x.\pair{x}{x} : \,!^{n_0} \alpha$}
		\end{prooftree}
	The annotations $\chi$ are omitted to avoid cluttering the notation. Thus, we have
		$$ \text{ConstraintTyping}\,(\varnothing \vdash \lambda x.\pair{x}{x} : \,!^{n_0} \alpha) = \hspace{1in}$$ $$\left\{ \scriptsize
			                                          \begin{array}{lll} 
			                                            !^{n_1}\beta \prec: \,!^{n_4}\delta, & n_6 \le n_4 &
			                                            	 !^{n_6}(!^{n_4}\delta \otimes \,!^{n_5}\epsilon) \prec: !^{n_2}\gamma \\
			                                            !^{n_1}\beta \prec: \,!^{n_5}\epsilon, & n_6 \le n_5 &
			                                              !^{n_3} (!^{n_1} \beta \multimap !^{n_2}\gamma) \prec: \,!^{n_0} \alpha \\
			                                            & 1 \le n_1 &
	  		                                        \end{array} \right\} $$
\end{exmp}

The idea of the constraint typing algorithm is that we can check the existence of a typing derivation of $\Gamma \vdash t : T$ by first
collecting in $\lset$ all the constraints that must be met for it to exist. $\lset$ characterizes the possible valid instantiations of
$\Gamma \vdash t : T$. Then, to find solutions, we look for solutions of $\lset$. If no substitution can be found that solves $\lset$,
then we know that $t$ is not typeable with the type $T$ in the context $\Gamma$. The following definition formalizes this idea.

\begin{defn}
	\label{alg_problem}
	Suppose $\Gamma$ a typing context, $t$ a term, $T$ a type, and $\lset$ a constraint set, such that the constraint typing relation
	$\Gamma \vdash_\lset t : T ~|_\chi$ holds.
	We say that a substitution $\sigma$ is a {\em solution for the problem 	$(\Gamma, t, T, \lset)$} if it is a solution of $\lset$.
\end{defn}

We now have two different ways of characterizing the possible instantiations of $\Gamma \vdash t : T$ as
 	\begin{enumerate}
 		\item The solutions for $(\Gamma, t, T)$, according to Definition \ref{decl_problem}.
 		\item Supposing the relation $\Gamma \vdash_\lset t : T ~|_\chi$, the solutions for $(\Gamma, t, T, \lset)$ in the sense of Definition
 			\ref{alg_problem}.
 	\end{enumerate}

We now have to show that these definitions are equivalent. That is, we need to show that every solution $\sigma$ for $(\Gamma, t, T, \lset)$
is a solution for $(\Gamma, t, T)$. This implication is proved by the Soundness Theorem. Conversely, we also prove that from every solution
for $(\Gamma, t, T)$ we can derive a solution for $(\Gamma, t, T, \lset)$ by adding bindings for the freshly generated variables, as stated
by the Completeness Theorem.

\begin{prop}{\bf (Soundness).} \\
	Suppose that $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$. If $\sigma$ is a solution
	of $\mathcal{L}$, then it is also a solution for $(\Gamma, t, T)$.

	\begin{proof}
 		By induction on the constraint typing derivation. If the term is
 		\begin{itemize}
 		\item $x$. Then, supposing that $\Gamma = \,!^I\Delta, x : U$, $\mathcal{L} = \{ 1 \le I, U \prec: T \}$. By hypothesis, $\sigma$ is a solution
 			of $\mathcal{L}$, which implies that $\sigma I = 1 \dots 1$ and $\sigma U <: \sigma T$.
 			By application of $(ax)$, we obtain $\sigma \Gamma \vdash x : \sigma T$.
 			
 		\item $\lambda x.t$. From the inversion of the rule $(\lambda)$, we have
		 		$$\mathcal{L} = \mathcal{L'} \cup \{p \le I, ~!^p(!^n\alpha \multimap \,!^m\beta) \prec: T\}$$
		 	supposing $\Gamma \equiv \,!^I \Gamma$ and $\Gamma, x : \,!^n\alpha \vdash_\mathcal{L'} t : \,!^m\beta$.
		 	$\sigma$ being a solution of $\mathcal{L}$, it is also a solution of $\mathcal{L'}$, and
		 	by the induction hypothesis, it is a solution for $(\Gamma, x : \,!^n\alpha, \,t, \,!^m\beta)$. Depending on the value
		 	of $\sigma (p)$,
		 	\begin{itemize}
		 		\item If $\sigma(p) = 1$, then $\sigma I = 1 \dots 1$. By the rule $(\lambda_1)$,
		 			$!^1\sigma\Gamma \vdash \lambda x.t : \,!^1(\sigma(!^n \alpha) \multimap \sigma(!^m \beta))$ is a valid typing judgement.
		 			
		 		\item If $\sigma(p) = 0$, then by the rule $(\lambda_2)$,
		 			$\sigma\Gamma \vdash \lambda x.t : \,!^0(\sigma(!^n \alpha) \multimap \sigma(!^m \beta))$ is a valid typing judgement.
		 	\end{itemize}
			In either case, due to the relation $!^{\sigma(p)} (\sigma(!^n\alpha) \multimap \sigma(!^m\beta)) <: \sigma T$, the admissible rule
			(sub-typing) can be applied, and $\sigma \Gamma \vdash \lambda x . t : \sigma T$ is a valid typing judgement.
			This proves that $\sigma$ is a solution for $(\Gamma, \lambda x.t, T)$.
		
		\item $t \, u$. Supposing that
			\begin{center}
			\begin{tabular}{l}
				$\Gamma |_t \vdash_{\mathcal{L}_t} t : \,!^0(!^n\alpha \multimap T)$ \\
				$\Gamma |_u \vdash_{\mathcal{L}_u} u : \,!^n\alpha$ \\
				$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$
			\end{tabular}
			\end{center}
			$\mathcal{L} = \mathcal{L}_t \cup \mathcal{L}_u \cup \{ 1 \le I \}$. By hypothesis, $\sigma$ is a solution of $\mathcal{L}$,
			which means it is also a solution of $\mathcal{L}_t$, $\mathcal{L}_u$ and $\sigma I = 1 \dots 1$.
			Thus, by the induction hypothesis,
				\begin{center}
				\begin{tabular}{lc}
					$\sigma \Gamma|_t \vdash t : \,!^0(\sigma (!^n\alpha) \multimap \sigma T)$ & and \\
			  	$\sigma \Gamma|_u \vdash u : \sigma (!^n\alpha)$ & are both valid.
			  \end{tabular}
			  \end{center}
			By definition, the contexts $\Gamma|_t$ and $\Gamma|_u$ can be written as $\Gamma_1, \Delta|_{t, u}$ and $\Gamma_2, \Delta |_{t, u}$,
			with $\Gamma_1 \cap \Gamma_2 = \varnothing$. By property of $\sigma$ ($\sigma I = 1 \dots 1$),
			$\sigma \Delta|_{t, u} = \,!^1 \sigma \Delta|_{t, u}$. Hence by application of the rule $(app)$,
			the typing judgement $\sigma\Gamma_1, \sigma\Gamma_2, \,!^1\sigma\Delta|_{t, u} \vdash t \, u : \sigma T$ is valid.
			Consequently, using the lemma \ref{weakening} with the set $\sigma\Delta \backslash_{t, u}$, a derivation can be built of the judgement
			$\sigma\Gamma \vdash t \, u : \sigma T$.
			
		\item The same reasoning is used to prove the remaining cases.
		
 		\end{itemize}
	\end{proof}
\end{prop}

\begin{prop}{\bf (Completeness).} \\
	Suppose $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$. If $\sigma$ is a solution for $(\Gamma, t, T)$ such that
	$dom(\sigma) \cap \chi = \varnothing$, then there 	is some solution $\sigma'$ of $\mathcal{L}$ such that
	$\sigma' \backslash \chi = \sigma$.
	
	\begin{proof}
		By induction on the constraint typing derivation. If the last case is
		\begin{itemize}
		\item $x$. The typing judgement $\sigma \Gamma \vdash x : \sigma T$ being valid, $\sigma \Gamma$ must be of the form
			$!^1 \Delta, x : \sigma U$, and $\sigma U <: \sigma T$. Thus, $\sigma$ is a solution of $\mathcal{L} = \{ U <: T, 1 \le I \}$.
			
		\item $\lambda x.t$. Suppose $\Gamma, x : \,!^n\alpha \vdash_\mathcal{L'} t : \,!^m\beta ~|_\chi$, $\mathcal{L} = \mathcal{L'} \cup
			\{ p \le I, \,!^p(!^n\alpha \multimap !^m\beta) \}$.
			Depending on the form taken by $\sigma T$:
			\begin{itemize}
			\item If $\sigma T = \,!^1 (T_1 \multimap T_2)$, then the typing derivation is
				\begin{prooftree}
					\AxiomC{$!^1 \sigma\Gamma, x : T_1 \vdash t : T_2$}
					\RightLabel{$(\lambda_1)$}
					\UnaryInfC{$!^1 \sigma\Gamma \vdash \lambda x.t : \,!^1(T_1 \multimap T_2)$}
				\end{prooftree}
				Since $dom(\sigma) \cap \{\alpha, \beta, m, n, p\} = \varnothing$, $\sigma$ can be extended as $\sigma'$ with
					$$\sigma' = \sigma, [p \mapsto 1, \,!^n\alpha \mapsto T_1, \,!^m\beta \mapsto T_2]$$
				By construction, $\sigma' (\Gamma, x : \,!^n\alpha) \equiv \sigma\Gamma, x : T_1$ and $\sigma' (!^m \beta) = T_2$. Hence
				$\sigma' \Gamma, x : \sigma'(!^n\alpha) \vdash t : \sigma'(!^m \beta)$ is valid. Finally,
				$dom(\sigma') \cap \chi = (dom(\sigma) \cup \{\alpha, \beta, n, m, p\}) \cap \chi = \varnothing$.
				This means $\sigma'$ is a solution for $(\Gamma,x : \,!^n\alpha, t, \,!^m\beta)$ with the right property
				$dom(\sigma') \cap \chi = \varnothing$. By the induction hypothesis, $\sigma^*$ solution of $\mathcal{L'}$ can be constructed
				with the property $\sigma^* \backslash_\chi = \sigma'$.
				$\sigma^*$ also satisfies $\sigma^*\backslash_{\chi \cup \{\alpha, \beta, n, m , p\}} =
				\sigma' \backslash_{\{\alpha, \beta, n, m, p \}} = \sigma$ and $\sigma^* \mathcal{L}$ solved. \\
					
			\item If $\sigma T = \,!^0 (T_1 \multimap T_2)$.
				The same reasoning applies, using $\sigma'$ solution for $(\Gamma,x : \,!^n\alpha, t, \,!^m\beta)$
					$$\sigma' = \sigma, [p \mapsto 0, \,!^n\alpha \mapsto T_1, !^m\beta \mapsto T_2]$$
				to construct $\sigma^*$ with the desired properties.
			\end{itemize}
		
		\item $t \, u$. Supposing that
			$$\left\{ \begin{array}{l}
				\Gamma|_t \vdash_{\mathcal{L}_1} t : \,!^0(!^n\alpha \multimap T) ~|_{\chi_1} \\
				\Gamma|_u \vdash_{\mathcal{L}_2} u : \,!^n\alpha ~|_{\chi_2} \\
				\Gamma\backslash_{t \oplus u} = \,!^I\Delta
			\end{array} \right.$$
			we get $\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$ and
			$\chi = \chi_1 \cup \chi_2 \cup \{ \alpha, n\}$. We are given $\sigma$ solution for $(\Gamma, t \, u, T)$ such that
			$dom(\alpha) \cap \chi = \varnothing$.
			The typing derivation for $\sigma \Gamma \vdash t \, u : \sigma T$ must be
				\begin{prooftree}
					\AxiomC{$\sigma\Gamma_1, !^1 \sigma\Delta \vdash t : \,!^0 (U \multimap \sigma T)$}
					\AxiomC{$\sigma\Gamma_2, !^1 \sigma\Delta \vdash u : U$}
					\RightLabel{$(app)$}
					\BinaryInfC{$\sigma\Gamma = \sigma\Gamma_1, \sigma\Gamma_2, !^1 \sigma\Delta \vdash t \, u : \sigma T$}
				\end{prooftree}
			The contexts $\Gamma|_t$ and $\Gamma|_u$ are related to $\Gamma_1$, $\Gamma_2$ and $\Delta$ by the relations
			$\Gamma|_t = \Gamma_1, \Delta|_t$ and $\Gamma|_u = \Gamma_2, \Delta|_u$. More importantly, the context
			$\Delta$ from the constraint typing rule is the same as the one from the regular typing rules. This means
			that by definition $\sigma I = 1 \dots 1$. \\
			By hypothesis, $dom(\sigma) \cap \{ \alpha, n \} = \varnothing$. Thus $\sigma$ can be extended as
			$\sigma' = \sigma, [!^n\alpha \mapsto U]$. \\
			By construction of $\sigma'$, the following properties are satisfied
				$$\left\{ \begin{array}{l}
									   \sigma' \Gamma = \sigma \Gamma \\
									   \sigma'(!^0(!^n \alpha \multimap T)) = \,!^0 (U \multimap \sigma T) \\
									   dom(\sigma') \cap \chi_1 = dom(\sigma) \cap \chi_1 = \varnothing
									 \end{array} \right.$$
		  Consequently, $\sigma'$ is a solution for $((\Gamma_1, \Delta), ~t, ~!^0(!^n \multimap T))$ satisfying $dom(\sigma') \cap \chi_1 = \varnothing$.
			But this statement has to be adjusted to match the problem $(\Gamma|_t, t, \,!^0 (!^n \alpha\multimap T), \mathcal{L}_1)$.
			This is done by applying the lemma \ref{QP'prop} which states that $\sigma'$ is also a solution for
			$(\Gamma_1, \Delta|_t, ~t, ~!^0(!^n\alpha \multimap T)) \equiv (\Gamma|_t, ~t, ~!^0(!^n\alpha \multimap T))$.
			By the induction hypothesis, $\sigma^*$ can be constructed that is solution of $\mathcal{L}_1$, with the property
			$\sigma^* \backslash_{\chi_1} = \sigma'$. We now need to modify $\sigma^*$ to solve $\mathcal{L}_2$ as well.
			By construction of $\sigma^*$, the properties are satisfied
				$$\left\{ \begin{array}{l}
										 \sigma^* \Gamma = \sigma' \Gamma = \sigma \Gamma \\
										 \sigma^* (!^n \alpha) = \sigma' (!^n \alpha) = U \\
										 dom(\sigma^*) \cap \chi_2 = dom(\sigma) \cap \chi_2 = \varnothing ~~(\text{because} ~\chi_1 \cap \chi_2 = \varnothing)
					  			 \end{array}\right.$$
			Thus $\sigma^*$ is a solution for $((\Gamma_2, \Delta), ~u, ~!^n\alpha)$, which means for $(\Gamma|_u, ~u, ~!^n\alpha)$ as well.
			It also satisfies $dom(\sigma^*) \cap \chi_2 = \varnothing$. By the induction hypothesis, there exists $\sigma^{**}$ solution of
			$\mathcal{L}_2$ such that $\sigma^{**} \backslash_{\chi_2} = \sigma^*$. \\
			Overall, $\sigma^{**}$ is a solution of $\mathcal{L}_1$, $\mathcal{L}_2$ and $\{ 1 \le I \}$, which means it solves $\mathcal{L}$.
			Moreover, $\sigma^{**} \backslash_{\chi_1 \cup \chi_2 \cup \{\alpha, n\}} = \sigma^* \backslash_{\chi_1 \cup \{\alpha, n\}} =
			\sigma' \backslash_{\{ \alpha, n\}} = \sigma$.
			
		\item The same approach is used to solve the remaining cases.
		\end{itemize}
	\end{proof}
\end{prop}

\subsection{Unification}

A constraint set can have infinitely many solutions, but some may be better than others. In particular, we will give a privileged status to solutions
that make fewer assumptions about the structure of types. For example, the set $\lset = \{!^n \alpha \prec: !^m \beta\}$ will have
$\sigma = [\alpha \mapsto \beta, n \mapsto 1, m \mapsto 0]$ and $\tau = [\alpha \mapsto {!}^1 A \otimes {!}^1 A, \beta \mapsto {!}^1 A \otimes {!}^1 A,
n \mapsto 1, m \mapsto 0]$ as solutions, but we want to say that $\sigma$ is ``more general" than $\tau$.

\begin{defn} Suppose two substitutions $\alpha$ and $\alpha'$. We say that $\alpha$ is \textit{more general} than $\alpha'$, written
	$\alpha \sqsubseteq \alpha'$ if there exists a substitution $\tau$ such that $\alpha' = \tau \circ \alpha$.
\end{defn}

With this definition, we can now say in the example above that $\sigma \sqsubseteq \tau$. Pierce {\cite{pierce02}} goes even further by stating the existence
of a most general unifier of a constraint set, a substitution solution of a set that is more general that any other solution. However,
while this is true in simply-typed lambda calculus, it is not true $\QP'$. A constraint set $\lset$ doesn't have  most general unifier, at least not according to the definition given
by Pierce. To prove this, it suffices to consider the set $\{ m \le n \}$. Three solutions of this constraint set exist:
	$$ \begin{array}{ccl}
		   \sigma_1 & = & [m \mapsto 0, n \mapsto 0] \\
			 \sigma_2 & = & [m \mapsto 0, n \mapsto 1] \\
			 \sigma_3 & = & [m \mapsto 1, n \mapsto 1]
			\end{array} $$
and it is easy to verify that none is more general than the others.
We adapt the definition of the most general unifier to be:

\begin{defn} A \textit{most general unifier} of a constraint set $\lset$ is a pair of a substitution $\sigma$ and an atomic
	constraint set $\lset'$ such that:
		\begin{itemize}
			\item For every solution $\tau$ of $\lset	'$, $\tau \circ \sigma$ is a solution of $\lset$.
			\item For every solution $\rho$ of $\lset$, there exists a substitution $\tau$ solution of $\lset'$ such that $\rho = \tau \circ \sigma$.
		\end{itemize}
\end{defn}

This definition is only useful if such most general unifiers actually exist. Thus we need to prove the theorem:
\begin{thm}
	\label{existence-MGU}
	Suppose a constraint $\lset$ that has at least one solution $\sigma$. Then $\lset$ has a most general unifier.
\end{thm}

This notion of most general unifier is analogous to the one defines for the purpose of unification in the simply-typed lambda calculus.
The unification algorithm proceeds in two steps:
	\begin{enumerate}
		\item Type unification. The algorithm reduces and solves the sub-typing constraints of the input set $\lset$.
			The output is a substitution $\sigma$, and a residual constraint set $\lset'$ which contains only atomic sub-typing constraints and
			flag constraints.
			
		\item Flag unification. This step reduces the flag constraints. It inputs the constraint set $\lset'$ left by the type unification,
			and returns a complementary substitution $\tau$, along with an atomic constraint set.
	\end{enumerate}

\subsubsection{Type Unification}

\begin{algorithm}{\bf (Reduction).}
  Given a constraint set $\lset$, we define its {\em reduction} $\lset^*$ by repeated application of the following rules.
  If any constraint $c$ in the set is:
  	\begin{itemize}
      \item $T \multimap U \prec: T' \multimap U'$, replace $c$ by $T' \prec: T$ and $U \prec: U'$;
      \item $T \otimes U \prec: T' \otimes U'$, replace $c$ by $T \prec: T'$ and $U \prec: U'$;
      \item $!^n A \prec: \, !^m B$, replace $c$ by $A \prec: B$ and $m \le n$;
      \item $1 \prec: 1$, remove the constraint;
      \item For any other composite type constraint, the algorithm fails.
    \end{itemize}
  When all the composite constraints have been reduced, there remains a set of constraints either atomic ($\alpha \prec: \beta$) or
  semi-composite ($T \prec: \alpha$ or $\alpha \prec: T$).
\end{algorithm}

\begin{lemma} \label{reductionQP'}
	Let $\lset$ be a constraint set, and $\lset^*$ the reduction of $\lset$. Then $\sigma$ is a solution of $\lset$ if and only if it is
	a solution of $\lset*$.
	
	\begin{proof}
		The right to left implication is proved by application of the sub-typing relation rules defined in Figure \ref{subtypingQP'}.
		The fact that all these rules are invertible gives the left to right implication.
	\end{proof}
\end{lemma}

Before we can define the type unification algorithm (Algorithm~\ref{alg-type-uni} below), we need an ordering of type variables that ensures termination and gives an upper
bound of its complexity (even though the limit itself is exponential).

\begin{defn} Given a constraint set $\lset$, let $\vset_\lset$ be the set of the free type variables of $\lset$. Every equivalence relation
	on the elements of $\vset_\lset$ defines a partition $\mathcal{C}$ of $\vset_\lset$ whose elements are the equivalence classes.
	Let $\equiv$ be a smallest equivalence relation on type variables such that for all $\alpha,\beta$:
		\begin{center}
			If $\exists \gamma_1 \dots \gamma_n$, s.t. $\alpha \prec: \gamma_1 \dots
				\gamma_n \prec: \beta$, then $\alpha \equiv \beta$.
		\end{center}
	For all variables $\alpha \in \vset_\lset$, we write $c_\alpha$ for the the equivalence class of $\alpha$.
	We also equip the set $\mathcal{C}$ with the partial relation $\ll$ defined as follows:
  	\begin{center}
  	  For all constraints $\alpha \prec: T$ or $T \prec: \alpha$, $\forall \beta \in FV(T), c_\alpha \ll c_\beta$
  	\end{center}
\end{defn}

Informally, if $\alpha\ll\beta$, we say that the variable $\alpha$ is
{\em younger} than $\beta$. The intuition behind this terminology is
that in a constraint $\alpha \prec: T$,
we see that $\alpha$ can only be defined after the introduction of all the variables $\beta$ of $T$. This is analogous to the topological sorting.

Note that the set $\mathcal{C}$ equipped with the partial relation
$\ll$ may be inconsistent. For example, let $\bullet$ be any binary type
operator (i.e., $\otimes$ or $\loli$). Any set with
a constraint like $\alpha \prec: \,!^*\beta ~\bullet~ \,!^*\alpha$ gives the relation $c_\alpha \ll c_\alpha$. More generally,
an inconsistent set is the symptom of an infinite type definition $\alpha = \alpha \bullet \alpha$. As infinite types are not included
in the definition of the type system, such cases will lead the algorithm to failure.
  
\begin{algorithm}{\bf (Variable ordering).}
  Here is a sketch of an algorithm for computing the relations $\equiv$ and $\ll$. 
  The first step is to sort out all the atomic constraints $\alpha \prec: \beta$, which we use to build the set of equivalence classes
  $\mathcal{C}$. The relation $\ll$ on classes is then defined using the remaining constraints and the above definition.
  Suppose this poset is implemented as a graph, whose vertices are the equivalence classes, and where each edge
  $c_\alpha \rightarrow c_\beta$ corresponds an relation $c_\beta \ll c_\alpha$. An in-depth exploration of this graph starting from any
  vertex will either:
  	\begin{itemize}
  		\item Reach a vertex $c_\alpha$ that has no outgoing edges. Then $c_\alpha$ is a minimum class of the poset.
  		\item Reach a vertex $c_\alpha$ that has already been explored. This means the poset is inconsistent, and the algorithm fails.
  	\end{itemize}
  Since each class is explored at most once, this algorithm is linear in the number of vertices (and by extension in the number of type
  variables).
\end{algorithm}

We are now ready to state the type unification algorithm. 
In the definition of the algorithm, the notation $\{ A_k \prec: B_k \}_k$ denotes the set $\bigcup_{k} \{ A_k \prec: B_k \}$.

\begin{algorithm}{\bf (Type Unification).}\label{alg-type-uni}
 \\
	The algorithm TypeUnification inputs a set of linear constraints $\mathcal{L}$, and returns
	a substitutions $\sigma$ associated with a set $\mathcal{L'}$ whose only sub-typing constraints are atomic.
	The algorithm proceeds as follows: \\
	\\
  Let $\alpha_1 \dots \alpha_n$ be the the youngest variables under the $\ll$ ordering. The constraint set $\mathcal{L}$ is formed of the constraints
  $\mathcal{L'} \cup \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k \cup \{ \alpha_{i_l} \prec: B_l \}_l
	\cup \{ A_m \prec: \alpha_{j_m} \}_m$.
  The set $\mathcal{L'}$ contains all the constraints unrelated to $\alpha_1 \dots \alpha_n$,
  and the linear types $A_m, B_l$ are all composite.
  		
  Depending on the types $\{A_m, B_l\}_{l, m}$:
	\begin{itemize}
		\item If this set is empty, then \\
			\begin{tabular}{l}
				let $\sigma, \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L'})$ \\
				return $\sigma, \mathcal{L''} \cup \{ \alpha_{i_k} <: \alpha_{j_k} \}_k$
			\end{tabular}
	  
	  \item If not, it contains an element $C$, which can be either $1$ or $C^1 \,\bullet \, C^2$, with $\bullet$ one in $\{ \otimes, \multimap \}$.
		  The algorithm proceeds as follow:\\
	  	\begin{tabular}{l}
	  		for each $\alpha_i$ \\
	  		~~ if $C = 1$ then \\
	  		~~ ~~ map $\alpha_i$ to $1$ \\
	  		~~ else \\
	  		~~ ~~ let $n_i, m_i, \beta_i, \gamma_i$ be fresh \\
	  		~~ ~~ map $\alpha_i$ to $!^{n_i} \beta_i ~\bullet~ !^{m_i}\gamma_i$ in $\sigma$ \\
	  		substitute $\alpha_1 \dots \alpha_n$ in $\mathcal{L}$ \\
	  		reduce $\mathcal{L}$ \\
	  		let $\sigma', \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L})$ \\
	  		return $\sigma' \circ \sigma, \mathcal{L''}$
	  	\end{tabular}
  \end{itemize}

  Of course, if the set of sub-typing constraints is empty, the algorithm stops.
  TypeUnification can fail in two different ways: either it attempts to construct an infinite
  type, and the variable ordering fails, or the reduction encounters an absurd composite constraint (such as $A\otimes B <: C\loli D$).
\end{algorithm}

\begin{defn} Let $\mathcal{L}$ be a constraint set. The following notations are introduced:
	\begin{itemize}
		\item[$\#\mathcal{L}$] for the complexity of $\mathcal{L}$, given by the number of connectives $\multimap$,
			$\otimes$ and symbols $1$ used in the types of the sub-typing constraints.
		\item[$|\mathcal{L}|$] for the number of constraints (sub-typing and flag) of $\mathcal{L}$.
	\end{itemize}
	Sets $\mathcal{L}$ are indexed by the pair $(\#\mathcal{L}, |\mathcal{L}|)$, equipped with the lexicographical order.
\end{defn}

\begin{thm}{\bf (Termination).} \\
	\textit{For all constraint sets $\mathcal{L}$, the unification algorithm applied to $\mathcal{L}$ terminates. }
	\begin{proof}
		By induction on indexed sets (see definition above). The induction hypothesis is this: \textit{if for all sets of index $I^{-} \lneq I$ the
		algorithm terminates, then for all sets of index $I$ TypeUnification terminates}. The initial case corresponds to sets of index $(0, N)$.
		If the index of the set is
		\begin{itemize}
			\item $(0, N_\lset)$, then $\mathcal{L}$ is only composed of atomic constraints, and TypeUnification returns
				immediately when applied to $\mathcal{L}$.
				
			\item $(C_\lset, N_\lset)$ and $\lset = \lset' \cup \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k$, where $\alpha_1 \dots \alpha_n$ are
				the youngest variables. Since $\mathcal{L'} \subsetneq \mathcal{L}$, it ensues that $N_\lset' = |\mathcal{L'}| < N_\lset$.
				Moreover, because all the constraints of $\mathcal{L} \,\backslash\, \mathcal{L'}$ are atomic, $C_\lset' = \#\mathcal{L'} = C_\lset$.
				Consequently, the index $(C_\lset', N_\lset')$ of $\mathcal{L'}$ is such that $(C_\lset', N_\lset') \lneq (C_\lset, N_\lset)$.
				Thus, the induction hypothesis applies, and thus we know that the function call $\text{TypeUnification}\,(\mathcal{L'})$ terminates, and the same
				for $\text{TypeUnification}\,(\mathcal{L})$.
			
			\item $(C_\lset, N_\lset)$ and $\lset = \lset' \cup \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k \cup \{ \alpha_{i_l} \prec: B_l \}_l
				\cup \{ A_m \prec: \alpha_{j_m} \}_m$, where $\alpha_1 \dots \alpha_n$ are the youngest variables.

				If $\{A_m, B_l\}_{l, m}$ contains $C = 1$. Each variable $\alpha_i$ is mapped in $\sigma$ to $1$.
				The result of the application of the new mappings to $\mathcal{L}$ is:
			  	$$\sigma \mathcal{L} = \mathcal{L'} \cup \{1 \prec: 1\}_k \cup \{ 1 \prec: B_l \}_l \cup \{ A_m \prec: 1 \}_m$$
       	The reduction of the constraints $\{ 1 \prec: B_l \}_l \cup \{ A_m \prec: 1 \}_m$ can only finish with either an error or the empty set.
       	Thence, what remains after reduction of the composite constraints is only $\mathcal{L'}$.
       	The complexity of the reduced constraint set $\sigma \mathcal{L}$ is:
			  	$$C_\lset' = \#\sigma\mathcal{L} = \#\mathcal{L'} $$
			  which is strictly less than $C_\lset$, meaning $(C_\lset',|\sigma\mathcal{L}|) \lneq (C_\lset, N_\lset)$.
			  The induction hypothesis holds, and the function call $\text{TypeUnification}\,(\sigma \mathcal{L})$ terminates,
			  giving the termination of the call $\text{TypeUnification}\,(\mathcal{L})$. \\
							
				If it contains $C = C_1 \,\bullet\, C_2$. Since the variable ordering did not fail, we know for sure that
						$$\alpha_1 \dots \alpha_n ~ \notin ~ \bigcup_{l} FV(B_l) \cup \bigcup_{m} FV(A_m)$$
				Each $\alpha_i$ is mapped in $\sigma$ to $!^{p_i} \beta_i ~ \bullet ~ !^{q_i}\gamma_i$.
				The result of the application of the new mappings $\sigma$ to $\mathcal{L}$ is:
			  	\begin{center}
			  	\begin{tabular}{lcl}
			  		$\sigma \mathcal{L}$ & $ = $ & $\mathcal{L'}$ \\
				  	& $ \cup $ & $\{!^{p_{i_k}} \beta_{i_k} ~ \bullet ~ !^{q_{i_k}}\gamma_{i_k} \prec: \,
				  	              \,!^{p_{j_k}} \beta_{j_k} ~ \bullet ~ !^{q_{j_k}}\gamma_{j_k} \}_k$ \\
				  	& $ \cup $ & $\{!^{p_{i_l}} \beta_{i_l} ~ \bullet ~ !^{q_{i_l}}\gamma_{i_l} \prec: B_l \}_l$ \\
				  	& $ \cup $ & $\{ A_m \prec: \,!^{p_{i_m}} \beta_{i_m} ~ \bullet ~ !^{q_{i_m}}\gamma_{i_m} \}_m$
				  \end{tabular}
				  \end{center}
       	What remains after reduction of the composite constraints is
					\begin{center}
			  	\begin{tabular}{lcl}
			  		$\sigma \mathcal{L}$ & $ = $ & $\mathcal{L'}$ \\
			  		& $ \cup $ & $\{q_{j_k} \le q_{i_k}, ~p_{j_k} \le p_{i_k}, ~\beta_{i_k} \prec: \beta_{j_k}, ~\gamma_{i_k} \prec: \gamma_{j_k} \}_k$ \\
			  		& $ \cup $ & $\{ \beta_{i_l} \prec: B^1_l, ~ \gamma_{i_l} \prec: B^2_l \}_l$ \\
			  		& $ \cup $ & $\{ A^1_m \prec: \beta_{j_m}, ~ A^2_m \prec: \gamma_{j_m} \}_m$ \\
			  		& $ \cup $ & $\{$ some flag constraints $\}$
			  	\end{tabular}
			  	\end{center}
				depending on the connective $\bullet$, the orientation of the constraints $\beta_{i_k} \prec: \beta_{j_k}$,
				$A^1_m \prec: \beta_{j_m}$ and $\beta_{i_l} \prec: B^1_l$ may be reversed, though it is of no consequence to the proof.
			  In the reduction of the constraints with $A_m$ and $B_l$, it is assumed that the types $A_m$ and $B_l$ are of the form
			  $!^*A^1_m ~\bullet~ !^*A^2_m$ and $!^*B^1_l ~\bullet~ !^*B^2_l$. The value of the flags doesn't really matter here. \\
			  Following, the complexity of the reduced constraint set $\sigma \mathcal{L}$ compared to that of the original set $\mathcal{L}$ is:
			  	$$C_\lset' = \#\sigma\mathcal{L} = \#\mathcal{L'} + \sum_{l} (\#B_l - 1) + \sum_{m} (\#A_m - 1) $$
			  which is strictly inferior to $C_\lset$, meaning $(C_\lset',|\sigma\mathcal{L}|) \lneq (C_\lset, N_\lset)$.
			  The induction hypothesis holds, and the function call $\text{TypeUnification}\,(\sigma \mathcal{L})$ terminates,
			  giving the termination of the call $\text{TypeUnification}\,(\mathcal{L})$.
			  
		\end{itemize}
	\end{proof}
\end{thm}

\begin{remark} Properties $(a)$ and $(b)$ in the following correctness
  theorem of type unification very much resemble the definition of the
  most general unifier.  However, the constraint set that is returned
  along with the substitution can still have {\em non-atomic flag
    constraints}.  Solving these remaining constraints is the purpose
  of the flag unification algorithm, which will be introduced in
  Section~\ref{sssec-flag}.
\end{remark}


\begin{thm}{\bf (Correctness).} \\
	Let $\mathcal{L}$ be a constraint set. The unification algorithm applied to $\mathcal{L}$ produces
	a substitution $\sigma$ and a set $\mathcal{L'}$ such that:
		\begin{center}
		\begin{tabular}{ll}
			(a) & for every solution $\tau$ of $\mathcal{L'}$, $\tau \circ \sigma$ is a solution of $\mathcal{L}$ \\
			(b) & for every solution $\rho$ of $\mathcal{L}$, there exists $\tau$ solution of $\mathcal{L'}$ such that $\rho = \tau \circ \sigma$ \\
			(c) & $\sigma \mathcal{L'} = \mathcal{L'}$
		\end{tabular}
		\end{center}

	\begin{proof}
		The third property (c) is easier to prove than the other two, and the proof will be omitted. The same case by case arguments are
		used to justify the use of the induction hypothesis as in the proof of termination, so this spares us the trouble of having to write
		them again. By induction on indexed sets. If the index is
		\begin{itemize}
			\item $(0, N_\lset)$. $\lset$ is composed only of atomic constraints, and TypeUnification returns $\varnothing, \lset$.
				The properties (a) and (b) are trivially satisfied.
				
			\item $(C_\lset, N_\lset)$, and $\lset = \lset' \cup \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k$. \\
				Let $\sigma, \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L'})$. By application of the induction hypothesis, $\sigma$ and
				$\mathcal{L''}$ respect the properties (a) and (b).
					\begin{itemize}
						\item[(a)] Let $\tau$ be a solution of $\mathcal{L''} \cup \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k$.
							$\tau$ being a solution of $\mathcal{L''}$, the application of the property (a) with $\tau$, $\mathcal{L''}$ and
							$\sigma$ proves that $\tau \circ \sigma$ is a solution of $\mathcal{L'}$. Overall, $\tau \circ \sigma$ is a
							solution of $\mathcal{L}$.
							
						\item[(b)] Let $\rho$ be a solution of $\mathcal{L}$, and therefore of $\lset'$.
							The property (b) applied with $\mathcal{L''}$ and $\sigma$ ensures the existence
							of $\tau$ solution of $\mathcal{L''}$ such that $\tau \circ \sigma$ is equal to $\rho$. Moreover, it follows from (c) that
							$\sigma \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k = \{\alpha_{i_k} \prec: \alpha_{j_k} \}_k$. Thus,
								$$(\tau \circ \sigma) \{\alpha_{i_k} \prec: \alpha_{j_k} \}_k = \tau \{\alpha_{i_k} \prec: \alpha_{j_k} \}_k$$
							Since $\rho = \tau \circ \sigma$ is a solution of $\{\alpha_{i_k} \prec: \alpha_{j_k} \}_k$, it follows that $\tau$ is a solution of
							$\{\alpha_{i_k} \prec: \alpha_{j_k} \}_k$, and also of $\lset'' \cup \{\alpha_{i_k} \prec: \alpha_{j_k} \}_k$. This completes
							the proof of the property (b).
					\end{itemize}
			
			\item $(C_\lset, N_\lset)$, and $\mathcal{L} = \mathcal{L'} \cup \{ \alpha_{i_k} \prec: \alpha_{j_k} \}_k \cup
				\{ \alpha_{i_l} \prec: B_l \}_l \cup \{ A_m \prec: \alpha_{j_m} \}_m$.
				The case where the composite types $\{ A_m, B_l \}_{l, m}$ are all equal to $1$ is solved easily, as the mappings
				$[\alpha_i \mapsto 1]_i$ give the only solution for $\alpha_1 \dots \alpha_n$.
				By applying the induction hypothesis, the properties (a) and (b) are easily proved. \\
				
				Otherwise, let $\sigma$ be the substitution $\sigma = [\alpha_i \mapsto !^{p_i}\beta_i \,\bullet\, !^{q_i}\gamma_i]_i$, and
				$\mathcal{L}^*$ the reduced set $\sigma \mathcal{L}$. Finally, let $\sigma', \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L}^*)$.
				The induction hypothesis applied to $\mathcal{L}^*$ proves that $\sigma', \mathcal{L''}$ respect the properties (a) and (b).
					\begin{itemize}
						\item[(a)] Let $\tau$ be a solution of $\mathcal{L''}$. By application of (a), $\tau \circ \sigma'$ is a solution of $\mathcal{L}^*$.
							Since the solutions of $\mathcal{L}^*$ and $\sigma \mathcal{L}$ are the same, $\tau \circ \sigma'$ is also a solution of
							$\sigma \mathcal{L}$. Thence, $\tau \circ \sigma' \circ \sigma$ is a solution of $\mathcal{L}$.
							
						\item[(b)] Let $\rho$ be a solution of $\mathcal{L}$. In particular, since $\rho$ is assumed to be idempotent,
							it contains the mappings:
								$$\rho = \rho', [\alpha_i \mapsto T_i \,\bullet\, U_i]_i$$
							Thus it can be modified to be:
								$$\rho = (\rho',[!^{p_i}\beta_i \mapsto T_i]_i, [!^{q_i}\gamma_i \mapsto U_i]_i) \circ
									[\alpha_i \mapsto \,!^{p_i}\beta_i \,\bullet\, !^{q_i}\gamma_i]_i$$
							Using the notation $\rho^* = \rho' ,[!^{p_i}\beta_i \mapsto T_i]_i,[!^{q_i}\gamma_i \mapsto U_i]_i$,
							$\rho = \rho^* \circ \sigma$. By application of the sub-typing relation rules on $\mathcal{L}^*$, it can be proved
							that $\rho^*$ is a solution of $\mathcal{L}^*$. By application of the induction hypothesis and (b), there exists
							$\tau$ solution of $\mathcal{L''}$, such that $\rho^* = \tau \circ \sigma'$. Hence $\rho = (\tau \circ \sigma') \circ \sigma =
							\tau \circ (\sigma' \circ \sigma)$.
					\end{itemize}
		\end{itemize}
	\end{proof}
\end{thm}

\subsubsection{Flag Unification}\label{sssec-flag}

\begin{algorithm}{\bf (Flag unification).} \\
	The algorithm inputs a set of constraints that contains only atomic type constraints, and returns a substitution
	$\sigma$ on flags, along with the remaining constraints (all atomic).
	
	The algorithm looks for constraints of the form
	\begin{itemize}
		\item $n \le 1$ or $0 \le n$, those constraints don't affect the set of solutions of the constraint set, and thus can be removed
			without any consequences.
		\item $1 \le n$, in which case it removes the constraint, and sets $n$ to $1$.
		\item $n \le 0$, in which case it removes the constraint, and sets $n$ to $0$.
	\end{itemize}	
	When setting a flag to a value, the algorithm also needs to replace the instances of this flag in the constraint set.
	If no such constraint remains, it returns. The algorithm fails if and only if it encounters an absurdity,
	as in the case of the set $\{ 1 \le 0 \}$.
	The termination of FlagUnification is obvious because the number of constraints strictly diminishes each step.
	The correctness is also straightforward.
\end{algorithm}

We now can connect TypeUnification and FlagUnification, to build the unification algorithm.

\begin{defn} {\bf (Unification).} \\
	The algorithm inputs a constraint set $\lset$ and successively applies TypeUnification and FlagUnification:
		\begin{center}
		\begin{tabular}{l}
			Unification($\lset$) = do \\
			~~ ~~ let $(\sigma, \lset') = \text{ TypeUnification} \,(\lset)$ \\
			~~ ~~ let $(\sigma', \lset'') = \text{ FlagUnification} \,(\lset')$ \\
			~~ ~~ return $(\sigma' \circ \sigma, \lset'')$
		\end{tabular}
		\end{center}
\end{defn}

\begin{lemma} Suppose $\lset$ a solvable constraint set. Then Unification$(\lset)$ returns the most general unifier of $\lset$.
	\begin{proof}
		Using the properties $(a)$ and $(b)$ of the correctness of TypeUnification, and the correctness of FlagUnification.
	\end{proof}
\end{lemma}

\subsubsection{Approximations}

Algorithm~\ref{alg-type-uni} gives an exact, and most general solution to the type unification algorithm. However, this result is obtained at the cost of a high complexity:
the application of the unification algorithm to the set
{ \small
	$$\lset = \{\alpha_0 \prec: (!^{n_1}\alpha_1 ~\bullet~ !^{n_1}\alpha_1), ~~ 
	\alpha_1 \prec: (!^{n_2}\alpha_2 ~\bullet~ !^{n_2}\alpha_2) ~~ \dots ~~ \alpha_{i-1} \prec: (!^{n_i}\alpha_i ~\bullet~ !^{n_i}\alpha_{i}) \}$$ }
potentially leads to the creation of an exponential number of variables, and the resulting set also contains an exponential number of
constraints.
This is why it may be interesting to make some concessions to lower the cost of the algorithm. Also, the goal of the algorithm is
often only to determine the {\em existence} of solutions, and not necessarily find all the possible ones.
We propose some approximations that keep the satisfiability of the constraint set, but restrict the set of inferred solutions:
	
\begin{itemize}
	\item In the case where $\mathcal{L} = \mathcal{L'} \cup \{\alpha_{i_k} \prec: \alpha_{j_k} \}_k$,
		make the approximation ${[\alpha_i \mapsto \alpha_1]_{i \in \{2 \dots n\}}}$.
		
	\item In the case where $\mathcal{L} = \mathcal{L'} \cup \{T \prec: \alpha_1 \prec: \dots \prec: \alpha_n \prec: U\}$, make the
		approximation $\sigma = [\alpha_i \mapsto T]_i$, and then apply TypeUnification to $\mathcal{L'} \cup \{ T \prec: U \}$.
		
	\item In the case where $\mathcal{L} = \mathcal{L'} \cup \{\alpha_{i_k} \prec: \alpha_{j_k}\}_k \cup
		\{T_{i, 1} \dots \{T_l \prec: \alpha_{j_l} \}_l$, make the substitution $\sigma = {[\alpha_i \mapsto \alpha_1]_{i \in \{2 \dots n\}}}$,
		and apply the algorithm to $\mathcal{L'} \cup \{T_l \prec: \alpha_1\}_l$.
		
	\item The same for the case $\mathcal{L} = \mathcal{L'} \cup \{\alpha_{i_k} \prec: \alpha_{j_k}\}_k \cup \{\alpha_{i_m} \prec: U_m\}_m$.
\end{itemize}

\subsection{Extending Type Inference to Core Proto-Quipper}
\label{ssec-extending-to-QP}

This section gives the additions that have to be made to the grammar of $\QP'$ for the type inference algorithm to perform in the syntax
of core Proto-Quipper.
We now consider that all the terms of Proto-Quipper have been added to $\QP'$. First, we need to include the types $\bool, \qubit, \Circ(T, U)$
in the rule of $\texttt{LinearType}$, along with the typing rules from Figure \ref{exttypeQP'}

\begin{figure}[!ht]
\begin{mdframed}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(\rev)$}
		\UnaryInfC{$!^1 \Gamma \vdash \rev : ~!^1 (!^1\Circ(T, U) \multimap~ !^1\Circ(U, T))$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(\unbox)$}
		\UnaryInfC{$!^1\Gamma \vdash \unbox : ~!^1 (!^1\Circ(T, U) \multimap~ !^1(T \multimap U))$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(\boxx)$}
		\UnaryInfC{$!^1\Gamma \vdash \boxx^T : ~!^1(!^1(T \multimap U) \multimap~ !^1\Circ (T, U))$}
	\end{prooftree}
	$$ \mbox{
		\AxiomC{}
		\RightLabel{$(\textit{true})$}
		\UnaryInfC{$!^1 \Gamma \vdash \texttt{True} : ~!^1 \bool$}
		\DisplayProof
		~~
		~~
		\AxiomC{}
		\RightLabel{$(\textit{false})$}
		\UnaryInfC{$!^1 \Gamma \vdash \texttt{False} : ~!^1 \bool$}
		\DisplayProof
	} $$
	\begin{prooftree}
		\AxiomC{$\Gamma_1, ~!^1\Delta \vdash t : ~!^0 \bool$}
		\AxiomC{$\Gamma_2, ~!^1\Delta \vdash u : T$}		\noLine
		\UnaryInfC{$\Gamma_2, ~!^1\Delta \vdash v : T$}
		\RightLabel{$(\textit{if})$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash \ifthenelse{t}{u}{v} : T$}
	\end{prooftree}
\end{mdframed}
\caption{Additional typing rules.}
\label{exttypeQP'}
\end{figure}
In the same way, the constraint typing relation has to be extended to cover the new terms. The additional typing rules are developed in Figure \ref{extctypeQP'}.

\begin{figure}[!ht]
\begin{mdframed}
	\begin{prooftree}
	  \AxiomC{$\alpha, \beta, n, m \notin \Gamma, T$} \noLine
		\UnaryInfC{$\mathcal{L} = \{1 \le I, ~ !^1 (!^1\Circ(!^n\alpha, \,!^m\beta) \multimap~ !^1 \Circ(!^n\beta, \,!^m\alpha)) \prec: T\}$}
		\RightLabel{$(\rev)$}
		\UnaryInfC{$!^I \Gamma \vdash_\mathcal{L} \rev : T ~|_{\{\alpha, \beta, m, n\}}$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\alpha, \beta, n, m \notin \Gamma, T$} \noLine
		\UnaryInfC{$\mathcal{L} = \{1 \le I, ~ !^1 (!^1\Circ(!^n\alpha, \,!^m\beta) \multimap~ !^1 (!^n\alpha \multimap \,!^m\beta)) \prec: T\}$}
		\RightLabel{$(\unbox)$}
		\UnaryInfC{$!^I\Gamma \vdash_\mathcal{L} \unbox : T ~|_{\{\alpha, \beta, m, n\}}$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\alpha, n \notin \Gamma, T, U$} \noLine
		\UnaryInfC{$\mathcal{L} = \{1 \le I, ~ !^1(!^1(T \multimap \,!^n\alpha) \multimap~ !^1 \Circ (T, !^n\alpha)) \prec: U\}$}
		\RightLabel{$(\boxx)$}
		\UnaryInfC{$!^I\Gamma \vdash \boxx^T : U ~|_{\{\alpha, n\}}$}
	\end{prooftree}
	$$ \mbox{
		\AxiomC{$\mathcal{L} = \{1 \le I, ~ !^1 \bool \prec: T\}$}
		\RightLabel{$(\textit{true})$}
		\UnaryInfC{$!^I \Gamma \vdash \texttt{True} : T ~|_\varnothing$}
		\DisplayProof
                \quad
		\AxiomC{$\mathcal{L} = \{1 \le I, ~ !^1 \bool \prec: T\}$}
		\RightLabel{$(\textit{false})$}
		\UnaryInfC{$!^I \Gamma \vdash \texttt{False} : T ~|_\varnothing$}
		\DisplayProof
	} $$
	\begin{prooftree}
		\AxiomC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : ~!^0 \bool ~|_{\chi_1}$} \noLine
		\UnaryInfC{$\Gamma|_{u, v} \vdash_{\mathcal{L}_2} u : T ~|_{\chi_2}$}	 \noLine
		\UnaryInfC{$\Gamma|_{u, v} \vdash_{\mathcal{L}_3} v : T ~|_{\chi_3}$}
		\AxiomC{$\chi_1$, $\chi_2$, $\chi_3$ mutually disjoint} \noLine
		\UnaryInfC{$\Gamma \backslash_{t \oplus (u,v)} = \,!^I \Delta$} \noLine
		\UnaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \mathcal{L}_3 \cup \{ 1 \le I \}$}
		\RightLabel{$(\textit{if})$}
		\BinaryInfC{$\Gamma \vdash_\mathcal{L} \ifthenelse{t}{u}{v} : T ~|_{\chi_1 \cup \chi_2 \cup \chi_3}$}
	\end{prooftree}
\end{mdframed}
\caption{Additional constraint typing relation rules.}
\label{extctypeQP'}
\end{figure}

The reader may have noticed that, although the circuits $(t, C, a)$ have been included in the extended $\QP'$ syntax, no associated typing rule or
constraint typing relation rules were specified. The reason for this is that the type inference algorithm is designed to infer the
types of the terms coded by a programmer. However, the constructor $(t, C, a)$ has never been intended to be directly accessible.
More specifically, the programmer can access a built-in collection of basic gate circuits, whose types are already known at compile time.
