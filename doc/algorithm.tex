\title{
	Notes on linear type inference
}
\author{
	Henri Chataing
}
\date{\today}

\documentclass[10pt]{article}

\usepackage[margin=1.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{bussproofs}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section] % reset theorem numbering for each chapter

\theoremstyle{definition}
\newtheorem{defn}{Definition}[subsection] % definition numbers are dependent on theorem numbers
\newtheorem{exmp}{Example} % same for example numbers
\newtheorem{prop}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{coro}{Corollary}[]

%% LINEAR LOGIC %%
\def\bang{\,!\,}
\newcommand{\pair}[2]{\langle #1, #2 \rangle}
\newcommand{\nbang}[1]{\,!^{#1}}

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\section{Linear type lambda calculus}

\subsection{Definition of LL}

\begin{defn} The terms of the language are defined by the following grammar :
	$$\texttt{Term} ~ t, u ~ ::= ~ x ~ | ~ 1 ~ | ~\lambda x.t ~ | ~ t u ~|~ \pair{t}{u} ~|~ \text{let} ~ \pair{x}{y} = t ~ \text{in} ~ u  $$
	We write $FV(t)$ for the free term variables of a term $t$.
\end{defn}

\begin{defn} The types of LL are defined by the following syntax :
	\begin{center}
	\begin{tabular}{l}
		$\texttt{Flag} ::= ~ n ~|~ 0 ~|~ 1$ \\		
		$\texttt{LinearType} ~ A ~ ::= ~ \alpha ~|~ \top ~|~ T \multimap U ~|~ T \otimes U$ \\
		$\texttt{Type	} ~	T, U ~ ::= ~ !^n A$
	\end{tabular}
	\end{center}
	The variables $n, m \dots$ are flag variables, and can take either the value $0$ or $1$.
	Note that the syntax forces every type to be preceded by a flag annotation.
	In the rest of these notes, the names $A$, $B \dots$ we will be used to designate linear types, and
	$T$, $U \dots$ types.
\end{defn}

\begin{defn}
	The sub-typing relation $<:$ is the smallest relation on LL types satisfying the following rules :
	\begin{prooftree}
  	\AxiomC{}
  	\RightLabel{$(var)$}
  	\UnaryInfC{$\alpha <: ~ \alpha$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{}
  	\RightLabel{$(\top)$}
  	\UnaryInfC{$\top <: \top$}
  \end{prooftree}
  \begin{prooftree}	
  	\AxiomC{$A <: B$}
  	\AxiomC{$m \le n$}
  	\RightLabel{$(!)$}
  	\BinaryInfC{$!^n A <: ~ !^m B$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$T' <: T$}
  	\AxiomC{$U <: U'$}
  	\RightLabel{$(\multimap)$}
  	\BinaryInfC{$T \multimap U <: T' \multimap U'$}
  \end{prooftree}
  \begin{prooftree}
  	\AxiomC{$T <: T'$}
  	\AxiomC{$U <: U'$}
  	\RightLabel{$(\otimes)$}
  	\BinaryInfC{$T \otimes U <: T' \otimes U'$}
  \end{prooftree}
\end{defn}

\begin{lemma} \it The sub-typing relation $<:$ is reflexive, transitive.
\end{lemma}

\begin{defn} A typing context is a list of mappings $x : T$ associating a variable to a type.
	Each variable $x$ may only appear once in the same context. The \textit{support} of $\Gamma$, written $|\Gamma|$, is the list
	of term variables present in $\Gamma$.
	The notation $!^I \Gamma$ is used to represent contexts of the form
	$\Gamma = x_1 : \nbang{i_1} T_1 ~ \dots ~ x_n : \nbang{i_n} T_n$, with $I = \{i_1 \dots i_n\}$.
	By extension, the sub-typing relation $\Gamma <: \Delta$ on contexts is used with the meaning :
		\begin{center}
			$\Gamma <: \Delta \equiv \left\{ \begin{array}{l}
																						\Gamma = x_1 : T_1 \dots x_n : T_n \\
																						\Delta = x_1 : U_1 \dots x_n : U_n \\
																						\forall i, T_i <: U_i
																					\end{array}	 \right.$
		\end{center}
	Finally, we write $\Gamma|_t$ to represent the context $\Gamma$ where only the bindings $x : T$ with $x \in FV(t)$ appear.
	Similarly, the notation $\Gamma \backslash_t$ designates the context $\Gamma$ where the bindings $x : T$ for $x \in FV(t)$ have been
	removed.
\end{defn}

\begin{defn}{\bf Typing rules} 
	\begin{prooftree}
		\AxiomC{$T <: U$}
		\RightLabel{$(ax)$}
			\UnaryInfC{$!^1 \Delta, x : T \vdash x : U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(\top)$}
			\UnaryInfC{$!^1 \Delta \vdash 1 : \,!^n\top$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma, x : T \vdash t : U$}
		\RightLabel{$(\lambda_1)$}
		\UnaryInfC{$\Gamma \vdash \lambda x.t : \,!^0 (T \multimap U)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$!^1 \Gamma, x : T \vdash t : U$}
		\RightLabel{$(\lambda_2)$}
		\UnaryInfC{$!^1 \Gamma \vdash \lambda x.t : \,!^1 (T \multimap U)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !^1\Delta \vdash t : \,!^0(T \multimap U)$}
		\AxiomC{$\Gamma_2, !^1\Delta \vdash u : T$}
		\RightLabel{$(app)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash t u : U$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, !^1\Delta \vdash t : \, !^nA$}
		\noLine
		\UnaryInfC{$\Gamma_2, !^1\Delta \vdash u : \, !^mB$}
		\AxiomC{$p \le n, ~ p \le m$}
		\RightLabel{$(\otimes.I)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash \, \pair{t}{u} \, : \,!^p(!^nA \otimes \,!^mB)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, \,!^1\Delta \vdash t : \, !^p (!^nA \otimes \,!^mB)$}
		\noLine
		\UnaryInfC{$\Gamma_2, \,!^1\Delta, x : \,!^nA, y : \,!^nB \vdash u : T$}
		\AxiomC{$p \le n, ~ p \le m$}
		\RightLabel{$(\otimes.E)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^1\Delta \vdash \, \text{let} \pair{t}{u} = t ~ \text{in} ~ u \, : T$}
	\end{prooftree}
\end{defn}

\begin{lemma}
	\label{sub-judgement}
	Suppose $\Gamma \vdash t : T$ is a valid typing judgement in LL. Let $\Delta$ and $U$ be such that
	$\Delta <: \Gamma$ and $T <: U$. Then $\Delta \vdash t : U$ is valid.
	
	\begin{proof}
		By induction on the derivation of the typing judgement $\Gamma \vdash t : T$, it is possible to build
		a derivation of $\Delta \vdash t : U$.
	\end{proof}
\end{lemma}

\begin{coro} The following typing rule is admissible in LL
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t : T$}
		\AxiomC{$T <: U$}
		\RightLabel{Sub-typing}
		\BinaryInfC{$\Gamma \vdash t : U$}
	\end{prooftree}
\end{coro}

\begin{lemma}
	\label{weakening}
	Suppose $\Gamma \vdash t : T$ is a valid typing judgement in LL. Then for any context $!^1 \Delta$ distinct from $\Gamma$ ;
	$\Gamma, \,!^1\Delta \vdash t : T$ is valid as well.
	
	\begin{proof}
		By a simple induction on the typing derivation.
	\end{proof}
\end{lemma}

\begin{coro} The typing rule
	\begin{prooftree}
		\AxiomC{$\Gamma \vdash t : T$}
		\AxiomC{$x \notin |\Gamma|$}
		\RightLabel{Weakening}
		\BinaryInfC{$\Gamma, x : \nbang{1} U \vdash t : T$}
	\end{prooftree}
	is admissible in LL.	
\end{coro}

\begin{lemma}
	\label{contraction}
	Suppose $\Gamma, x : \,!^1 T \vdash t : T$ with $x \notin FV(t)$ is a valid typing judgement in LL.
	Then $\Gamma \vdash t : T$ is valid as well.
	
	\begin{proof}
		By a induction on the typing derivation.
	\end{proof}
\end{lemma}

\section{ConstraintTyping}	

\subsection{Definitions}

\begin{defn} Sub-typing constraints $T \prec: U$ and $A \prec: B$ are defined over LL types and linear types.
	A constraint $A \prec: B$ or $T \prec: U$ is atomic when $A$ and $B$ are both type variables (only linear type constraints can be atomic),
	composite when both are not, and semi-composite otherwise. \\
  Similarly, flag constraints $n \le m$ are defined over flag variables. Though all flag constraints are written in the same
  form, they can hold different meanings, for example $n \le 0$ can be viewed as $n = 0$, $1 \le m$ is the constraint
  $m = 1$, and $n \le m$ can be interpreted as $n = 1 \Rightarrow m = 1$.  
\end{defn}

\begin{defn} A substitution $\sigma$ is a pair of a finite list of mappings $\alpha \mapsto A$ from type variables to
	\textit{linear} types 	and a finite list of mappings from flag variables to either $0$ or $1$.
	A substitution is automatically extended with identity mappings to apply on all type and flag variables.
	$\bar{\sigma}$ the extension of $\sigma$ to linear types and types is defined as follow :
 		\begin{center}
 		\begin{tabular}{l}
 			$\bar{\sigma}(\alpha) = \sigma(\alpha)$ \\
			$\bar{\sigma}(1) = 1$ \\
 			$\bar{\sigma}(T \multimap U) = \bar{\sigma}T \multimap \bar{\sigma}U$ \\
 			$\bar{\sigma}(T \otimes U) = \bar{\sigma}T \otimes \bar{\sigma}U$ \\
 			$\bar{\sigma}(!^n A) = ~ !^{\sigma(n)} \bar{\sigma}A$
 		\end{tabular}
 		\end{center}
 	With this definition, it is always true that $\bar\sigma A$ is linear for every linear type $A$, and $\bar\sigma T$ is not.
 	For more clarity, the bar over $\sigma$ will be dropped in the rest of these notes. \\
 	A substitution $\sigma$ is $\textit{complete}$ with regard to a set of flag variables $\mathcal{F}$ if for every flag $n \in \mathcal{F}$,
 	$\sigma (n) = 0$ or $\sigma (n) = 1$. \\
 	The notation $vDom(\sigma)$ (resp. $fDom(\sigma)$) is used to designate the set of mapped type (resp. flag) variables, and
 	$vRange(\sigma)$ (resp. $fRange(\sigma)$) the set of type (resp. flag) variables appearing in the right-hand sides of the mappings
 	of $\sigma$. We also define $dom(\sigma) = vDom(\sigma) \cup fDom(\sigma)$ and $range(\sigma) = vRange(\sigma) \cup fRange (\sigma)$. \\
 	A substitution $\sigma$ solves a constraint $T \prec: U$ ($n \le m$) if and only if $\sigma T <: \sigma U$ ($\sigma(n) \le \sigma(m)$).
\end{defn}

\begin{defn} A constraint set $\mathcal{L}$ is a set of constraints $\{ T \prec: U, n \le m \}$ over types and flags.
  A constraint set can have the followin(g properties :
  \begin{itemize}
  	\item[]{\bf Atomicity} A set is atomic when all the \textit{type} constraints contained are atomic.
  	\item[]{\bf Satisfiability} A set is \textit{solved} when all the included constraints can be solved by application of one or
  		more of the sub-typing rules (type constraints) or by transitivity (flag constraints).
  		Following, a set $\mathcal{L}$ is \textit{solvable} if there exists a substitution $\sigma$ that solves $\sigma \mathcal{L}$, and
  		a substitution $\sigma$ is a solution of $\mathcal{L}$ if it solves all the constraints in $\mathcal{L}$.
	 	\item[]{\bf Derivation} When the validity of a set $\mathcal{L}$ can be deduced from another set $\mathcal{L'}$ by application of
		  the sub-typing rules and the transitivity, we say that $\mathcal{L}$ \textit{derives} from $\mathcal{L'}$,
		  written $\mathcal{L'} \vdash \mathcal{L}$.
  \end{itemize}
\end{defn}

\subsection{Algorithm}

\begin{defn} The \textit{constraint typing relation} $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$ is defined by the constraint typing rules
	listed below. It can be interpreted as : the term $t$ has the type $T$ under the assumptions $\Gamma$ when the constraints $\mathcal{L}$
	are solved. The set $\chi$ keeps track of the type and flag variables used in the derivation of a typing judgement
	$\Gamma \vdash_\mathcal{L} t : T ~|_\chi$, so as to be able to choose variables that are fresh, distinct from the ones used in the sub-derivation. \\
  The constraint typing algorithm is obtained by reading the constraint typing rules from bottom to top. It can be verified that the algorithm
  is indeed deterministic, whereas the typing rules of LL were not (see the rules $(\lambda_1)$ and $(\lambda_2)$).
  The function ConstraintTyping applies the constraint typing algorithm to a typing judgement $\Gamma \vdash t : T$, and returns a set
  $\mathcal{L}$ (and as a by-product the set of variables $\chi$) such that the relation $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$ holds.
\end{defn}
	
\begin{defn}{Constraint typing rules}
	\begin{prooftree}
		\AxiomC{$\mathcal{L} = \{1 \le I, ~ T \prec: U\}$}
		\RightLabel{$(ax)$}
			\UnaryInfC{$!^I \Delta, x : T \vdash_\mathcal{L} x : U ~|_\varnothing$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\mathcal{L} = \{1 \le I, ~ \,!^1 \top \prec: T \}$}
		\RightLabel{$(\top)$}
		\UnaryInfC{$!^I \Delta \vdash_\mathcal{L} 1 : T ~|_\varnothing$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$!^I\Gamma, x : \,!^n\alpha \vdash_\mathcal{L'} t : \,!^m\beta ~|_\chi$} \noLine
		\UnaryInfC{$\alpha, \beta, n, m, p \notin \chi, \Gamma, T$} \noLine
		\UnaryInfC{$\mathcal{L} = \mathcal{L'} \cup \{ p \le I, ~ !^p(!^n\alpha \multimap \,!^m\beta) \prec: T \}$}
		\RightLabel{$(\lambda)$}
		\UnaryInfC{$\Gamma \vdash_\mathcal{L} \lambda x.t : T ~|_{\chi \cup \{\alpha, \beta, n, m, p \}}$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma|_u \vdash_{\mathcal{L}_2} u : \,!^n\alpha ~|_{\chi_2}$} \noLine
		\UnaryInfC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : \,!^0(!^n\alpha \multimap T) ~|_{\chi_1}$} \noLine
		\AxiomC{$\chi_1 \cap \chi_2 = \varnothing$} \noLine
    \UnaryInfC{$\alpha, n \notin \chi_1, \chi_2, \Gamma, T$} \noLine
    \UnaryInfC{$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$} \noLine
    \UnaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$}
		\RightLabel{$(app)$}
		\BinaryInfC{$\Gamma \vdash_\mathcal{L} t \, u : T ~|_{\chi_1 \cup \chi_2 \cup \{ \alpha, n\}}$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : \, !^n\alpha ~|_{\chi_1}$} \noLine
		\UnaryInfC{$\Gamma|_u \vdash_{\mathcal{L}_2} u : \, !^m\beta ~|_{\chi_2}$}
		\AxiomC{$\chi_1 \cap \chi_2 = \varnothing$} \noLine
		\AxiomC{$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$} \noLine
		\BinaryInfC{$\alpha, \beta, n, m, p \notin \chi_1, \chi_2, \Gamma, T$} \noLine
		\UnaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I, p \le n, p \le m ~!^p(!^n\alpha \otimes \,!^m\beta) \prec: T \}$}
		\RightLabel{$(\otimes.I)$}
		\BinaryInfC{$\Gamma \vdash_\mathcal{L} \, \pair{t}{u} \, : T ~|_{\chi_1 \cup \chi_2 \cup \{\alpha, \beta, n, m, p \}}$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma|_t \vdash_{\mathcal{L}_1} t : \, !^p (!^n\alpha \otimes \,!^m\beta) ~|_{\chi_1}$} \noLine
		\UnaryInfC{$\Gamma|_u, x : \,!^n\alpha, y : \,!^m\beta \vdash_{\mathcal{L}_2} u : T ~|_{\chi_2}$}
		\AxiomC{$\chi_1 \cap \chi_2 = \varnothing$} \noLine
		\UnaryInfC{$\alpha, \beta, n, m, p \notin \chi_1, \chi_2$} \noLine
		\UnaryInfC{$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$} \noLine
		\UnaryInfC{$\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$}
		\RightLabel{$(\otimes.E)$}
		\BinaryInfC{$\Gamma \vdash_\mathcal{L} \, \text{let} \pair{t}{u} = t ~ \text{in} ~ u \, : T ~|_{\chi_1 \cup \chi_2 \cup \{\alpha,\beta,m,n,p \}}$}
	\end{prooftree}
\end{defn}

\begin{defn} A solution for $(\Gamma, t, T)$ is a substitution $\sigma$ such that $\sigma \Gamma \vdash t : \sigma T$.
	Suppose that $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$. A solution for $(\Gamma, t, T, \mathcal{L})$ is a substitution
	$\sigma$ that satisfies $\mathcal{L}$.

\end{defn}

\begin{prop}{\bf Soundness} \\
	Suppose that $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$. If $\sigma$ is a solution
	of $\mathcal{L}$ that is complete, then it is also a solution for $(\Gamma, t, T)$.

	\begin{proof}
 		By induction on the constraint typing derivation. If the term is
 		\begin{itemize}
 		\item $x$. Then, supposing that $\Gamma = \,!^I\Delta, x : U$, $\mathcal{L} = \{ 1 \le I, U \prec: T \}$. By hypothesis, $\sigma$ is a solution
 			of $\mathcal{L}$, which implies that $\sigma I = 1 \dots 1$ and $\sigma U <: \sigma T$.
 			By application of $(ax)$, we obtain $\sigma \Gamma \vdash x : \sigma T$.
 			
 		\item $\lambda x.t$. From the inversion of the rule $(\lambda)$, we have
		 		$$\mathcal{L} = \mathcal{L'} \cup \{p \le I, ~!^p(!^n\alpha \multimap \,!^m\beta) \prec: T\}$$
		 	supposing $\Gamma \equiv \,!^I \Gamma$ and $\Gamma, x : \,!^n\alpha \vdash_\mathcal{L'} t : \,!^m\beta$.
		 	$\sigma$ being a solution of $\mathcal{L}$, it is also a solution of $\mathcal{L'}$, and
		 	by the induction hypothesis, it is a solution for $(\Gamma, x : \,!^n\alpha, \,t, \,!^m\beta)$. Depending on the value
		 	of $\sigma (p)$,
		 	\begin{itemize}
		 		\item If $\sigma(p) = 1$, then $\sigma I = 1 \dots 1$. By the rule $(\lambda_1)$,
		 			$!^1\sigma\Gamma \vdash \lambda x.t : \,!^1(\sigma(!^n \alpha) \multimap \sigma(!^m \beta))$ is a valid typing judgement.
		 			
		 		\item If $\sigma(p) = 0$, then by the rule $(\lambda_2)$,
		 			$\sigma\Gamma \vdash \lambda x.t : \,!^0(\sigma(!^n \alpha) \multimap \sigma(!^m \beta))$ is a valid typing judgement.
		 	\end{itemize}
			In either case, due to the relation $!^{\sigma(p)} (\sigma(!^n\alpha) \multimap \sigma(!^m\beta)) <: \sigma T$, the admissible rule
			(sub-typing) can be applied, and $\sigma \Gamma \vdash \lambda x . t : \sigma T$ is a valid typing judgement.
			This proves that $\sigma$ is a solution for $(\Gamma, \lambda x.t, T)$.
		
		\item $t \, u$. Supposing that
			\begin{center}
			\begin{tabular}{l}
				$\Gamma |_t \vdash_{\mathcal{L}_t} t : \,!^0(!^n\alpha \multimap T)$ \\
				$\Gamma |_u \vdash_{\mathcal{L}_u} u : \,!^n\alpha$ \\
				$\Gamma \backslash_{t \oplus u} = \,!^I \Delta$
			\end{tabular}
			\end{center}
			$\mathcal{L} = \mathcal{L}_t \cup \mathcal{L}_u \cup \{ 1 \le I \}$. By hypothesis, $\sigma$ is a solution of $\mathcal{L}$,
			which means it is also a solution of $\mathcal{L}_t$, $\mathcal{L}_u$ and $\sigma I = 1 \dots 1$.
			Thus, by the induction hypothesis,
				\begin{center}
				\begin{tabular}{lc}
					$\sigma \Gamma|_t \vdash t : \,!^0(\sigma (!^n\alpha) \multimap \sigma T)$ & and \\
			  	$\sigma \Gamma|_u \vdash u : \sigma (!^n\alpha)$ & are both valid.
			  \end{tabular}
			  \end{center}
			By definition, the contexts $\Gamma|_t$ and $\Gamma|_u$ can be written as $\Gamma_1, \Delta|_{t, u}$ and $\Gamma_2, \Delta |_{t, u}$,
			with $\Gamma_1 \cap \Gamma_2 = \varnothing$. By property of $\sigma$ ($\sigma I = 1 \dots 1$),
			$\sigma \Delta|_{t, u} = \,!^1 \sigma \Delta|_{t, u}$. Hence by application of the rule $(app)$,
			the typing judgement $\sigma\Gamma_1, \sigma\Gamma_2, \,!^1\sigma\Delta|_{t, u} \vdash t \, u : \sigma T$ is valid.
			Consequently, using the lemma \ref{weakening} with the set $\sigma\Delta \backslash_{t, u}$, a derivation can be built of the judgement
			$\sigma\Gamma \vdash t \, u : \sigma T$.
			
		\item The other cases are similar
		
 		\end{itemize}
	\end{proof}
\end{prop}

\begin{prop}{\bf Completeness}
	Suppose $\Gamma \vdash_\mathcal{L} t : T ~|_\chi$. If $\sigma$ is a solution for $(\Gamma, t, T)$ such that
	$dom(\sigma) \cap \chi = \varnothing$, then there 	is some solution $\sigma'$ of $\mathcal{L}$ such that
	$\sigma' \backslash \chi = \sigma$.
	
	\begin{proof}
		By induction on the constraint typing derivation. If the last case is
		\begin{itemize}
		\item $x$. The typing judgement $\sigma \Gamma \vdash x : \sigma T$ being valid, $\sigma \Gamma$ must be of the form
			$!^1 \Delta, x : \sigma U$, and $\sigma U <: \sigma T$. Thus, $\sigma$ is a solution of $\mathcal{L} = \{ U <: T, 1 \le I \}$.
			
		\item $\lambda x.t$. Supposing $\Gamma, x : \,!^n\alpha \vdash_\mathcal{L'} t : \,!^m\beta ~|_\chi$, $\mathcal{L} = \mathcal{L'} \cup
			\{ p \le I, \,!^p(!^n\alpha \multimap !^m\beta) \}$.
			Depending on the form taken by $\sigma T$ :
			\begin{itemize}
			\item If $\sigma T = \,!^1 (T_1 \multimap T_2)$, then the typing derivation is
				\begin{prooftree}
					\AxiomC{$!^1 \sigma\Gamma, x : T_1 \vdash t : T_2$}
					\RightLabel{$(\lambda_1)$}
					\UnaryInfC{$!^1 \sigma\Gamma \vdash \lambda x.t : \,!^1(T_1 \multimap T_2)$}
				\end{prooftree}
				Since $dom(\sigma) \cap \{\alpha, \beta, m, n, p\} = \varnothing$, $\sigma$ can be extended as $\sigma'$ with
					$$\sigma' = \sigma, [p \mapsto 1, \,!^n\alpha \mapsto T_1, \,!^m\beta \mapsto T_2]$$
				By construction, $\sigma' (\Gamma, x : \,!^n\alpha) \equiv \sigma\Gamma, x : T_1$ and $\sigma' (!^m \beta) = T_2$. Hence
				$\sigma' \Gamma, x : \sigma'(!^n\alpha) \vdash t : \sigma'(!^m \beta)$ is valid. Finally,
				$dom(\sigma') \cap \chi = dom(\sigma) \cup \{\alpha, \beta, n, m, p\} \cap \chi = \varnothing$.
				This means $\sigma'$ is a solution for $(\Gamma,x : \,!^n\alpha, t, \,!^m\beta)$ with the right property
				$dom(\sigma') \cap \chi = \varnothing$. By the induction hypothesis, $\sigma^*$ solution of $\mathcal{L'}$ can be constructed
				with the property $\sigma^* \backslash_\chi = \sigma'$.
				$\sigma^*$ also verifies $\sigma^*\backslash_{\chi \cup \{\alpha, \beta, n, m , p\}} =
				\sigma' \backslash_{\{\alpha, \beta, n, m, p \}} = \sigma$ and $\sigma^* \mathcal{L}$ solved. \\
					
			\item If $\sigma T = \,!^0 (T_1 \multimap T_2)$.
				The same reasoning applies, using $\sigma'$ solution for $(\Gamma,x : \,!^n\alpha, t, \,!^m\beta)$
					$$\sigma' = \sigma, [p \mapsto 0, \,!^n\alpha \mapsto T_1, !^m\beta \mapsto T_2]$$
				to construct $\sigma^*$ with the desired properties.
			\end{itemize}
		
		\item $t \, u$. Supposing that
			$$\left\{ \begin{array}{l}
				\Gamma|_t \vdash_{\mathcal{L}_1} t : \,!^0(!^n\alpha \multimap T) ~|_{\chi_1} \\
				\Gamma|_u \vdash_{\mathcal{L}_2} u : \,!^n\alpha ~|_{\chi_2} \\
				\Gamma\backslash_{t \oplus u} = \,!^I\Delta
			\end{array} \right.$$
			we get $\mathcal{L} = \mathcal{L}_1 \cup \mathcal{L}_2 \cup \{ 1 \le I \}$ and
			$\chi = \chi_1 \cup \chi_2 \cup \{ \alpha, n\}$. We are given $\sigma$ solution for $(\Gamma, t \, u, T)$ such that
			$dom(\alpha) \cap \chi = \varnothing$.
			The typing derivation for $\sigma \Gamma \vdash t \, u : \sigma T$ must be
				\begin{prooftree}
					\AxiomC{$\sigma\Gamma_1, !^1 \sigma\Delta \vdash t : \,!^0 (U \multimap \sigma T)$}
					\AxiomC{$\sigma\Gamma_2, !^1 \sigma\Delta \vdash u : U$}
					\RightLabel{$(app)$}
					\BinaryInfC{$\sigma\Gamma = \sigma\Gamma_1, \sigma\Gamma_2, !^1 \sigma\Delta \vdash t \, u : \sigma T$}
				\end{prooftree}
			The contexts $\Gamma|_t$ and $\Gamma|_u$ are related to $\Gamma_1$, $\Gamma_2$ and $\Delta$ by the relations
			$\Gamma|_t = \Gamma_1, \Delta|_t$ and $\Gamma|_u = \Gamma_2, \Delta|_u$. More importantly, the context
			$\Delta$ from the constraint typing rule is the same as the one from the regular typing rules. This means
			that by definition $\sigma I = 1 \dots 1$. \\
			By hypothesis, $dom(\sigma) \cap \{ \alpha, n \} = \varnothing$. Thus $\sigma$ can be extended as
			$\sigma' = \sigma, [!^n\alpha \mapsto U]$. \\
			By construction of $\sigma'$,the following properties are verified
				$$\left\{ \begin{array}{l}
									   \sigma' \Gamma = \sigma \Gamma \\
									   \sigma'(!^0(!^n \alpha \multimap T)) = \,!^0 (U \multimap \sigma T) \\
									   dom(\sigma') \cap \chi_1 = dom(\sigma) \cap \chi_1 = \varnothing
									 \end{array} \right.$$
		  Consequently, $\sigma'$ is a solution for $(\Gamma_1, \Delta, ~t, ~!^0(!^n \multimap T))$ verifying $dom(\sigma') \cap \chi_1 = \varnothing$.
			But this statement has to be adjusted to match the problem $(\Gamma|_t, t, \,!^0 (!^n \alpha\multimap T), \mathcal{L}_1)$.
			This is done by applying the lemma \ref{contraction} which states that $\sigma'$ is also a solution for
			$(\Gamma_1, \Delta|_t, ~t, ~!^0(!^n\alpha \multimap T)) \equiv (\Gamma|_t, ~t, ~!^0(!^n\alpha \multimap T))$.
			By the induction hypothesis, $\sigma^*$ can be constructed that is solution of $\mathcal{L}_1$, with the property
			$\sigma^* \backslash_{\chi_1} = \sigma'$. We now need to modify $\sigma^*$ to solve $\mathcal{L}_2$ as well.
			By construction of $\sigma^*$, the properties are satisfied
				$$\left\{ \begin{array}{l}
										 \sigma^* \Gamma = \sigma' \Gamma = \sigma \Gamma \\
										 \sigma^* (!^n \alpha) = \sigma' (!^n \alpha) = U \\
										 dom(\sigma^*) \cap \chi_2 = dom(\sigma) \cap \chi_2 = \varnothing ~~(\text{because} ~\chi_1 \cap \chi_2 = \varnothing)
					  			 \end{array}\right.$$
			Thus $\sigma^*$ is a solution for $(\Gamma_1, \Delta, ~u, ~!^n\alpha)$, which means for $(\Gamma|_u, ~u, ~!^n\alpha)$ as well.
			It also verifies $dom(\sigma^*) \cap _chi_2 = \varnothing$. By the induction hypothesis, there exists $\sigma^{**}$ solution of
			$\mathcal{L}_2$ such that $\sigma^{**} \backslash_{\chi_2} = \sigma^*$. \\
			Overall, $\sigma^{**}$ is a solution of $\mathcal{L}_1$, $\mathcal{L}_2$ and $\{ 1 \le I \}$, which means it solves $\mathcal{L}$.
			Moreover, $\sigma^{**} \backslash_{\chi_1 \cup \chi_2 \cup \{\alpha, n\}} = \sigma^* \backslash_{\chi_1 \cup \{\alpha, n\}} =
			\sigma' \backslash_{\{ \alpha, n\}} = \sigma$.
		\end{itemize}
	\end{proof}
\end{prop}

\section{Unification}

\subsection{Algorithm}

The unification process is divided into two parts, one addressing the problem of unifying the sub-typing constraints,
the latter aiming to solve the remaining flag constraints.

\begin{defn}{Reduction of composite constraints}
	All the composite constraints produced by either the constraint typing
  algorithm or the unification algorithm are automatically reduced, using the following reduction rules.
  If the constraint $c$ is :
  	\begin{itemize}
      \item $T \multimap U <: T' \multimap U'$, replace $c$ by $T' <: T$ and $U <: U'$
      \item $T \otimes U <: T' \otimes U'$, replace $c$ by $T <: T'$ and $U <: U'$
      \item $!^n T <: \, !^m U$, replace $c$ by $T <: U$ and $m \le n$
      \item $\top <: \top$, remove the constraint
      \item For any other composite constraint, the algorithm fails
    \end{itemize}
  When all the composite constraints have been reduced, there remains a set of constraints either atomic ($\alpha <: \beta$) or
  semi-composite ($T <: \alpha$ or $\alpha <: T$).
  This automated reduction is justified in the sense that, due to the sub-typing relation rules, a set and its reduced version
  have the exactly the same solutions.
\end{defn}

\begin{defn}{Variable Ordering}
	The type unification relies on an ordering of the type variables, that ensures the termination of the algorithm, and gives a upper
	bound to its complexity (even though the limit itself is exponential).
	The goal is to sort variables topologically, from youngest to oldest. In particular,
  the youngest variable may not appear in any composite type. This is done by defining an age for every variable, with the
  relations :
  	\begin{center}
  	\begin{tabular}{l}
  	  For all constraint $\alpha <: T$ or $T <: \alpha$, $\forall \beta \in FV(T), ~ Age (\alpha) < Age (\beta)$ \\
  	  For all constraint $\alpha <: \beta$, $Age (\alpha) = Age (\beta)$
  	\end{tabular}
  	\end{center}
  	The algorithm may fail to attribute an age to each variable, for example with the constraint $\alpha <: \alpha \multimap \beta$, which gives the
  	relation in the age of $\alpha$ : $A(\alpha) < A(\alpha)$. This is true for all infinite types.
  	There exists an algorithm that gives the minimum (or maximum) of such a poset in linear time in the number of variables and relations
  	(that relies upon a in-depth exploration of the associated graph).
\end{defn}

\begin{defn}{Type Unification} \\
	The algorithm TypeUnification inputs a set of linear constraints $\mathcal{L}$, and returns
	a substitutions $\sigma$ associated with a set of atomic constraints $\mathcal{L'}$.
	The algorithm proceeds as follow : \\
	\\
  Let $\alpha_1 \dots \alpha_n$ be the the youngest variables. The constraint set $\mathcal{L}$ is formed of the constraints
  $\mathcal{L'} \cup \{ \alpha_i <: \alpha_j \} \cup \{ T_{i, 1} \dots T_{i, k_i} <: \alpha_i <: U_{i, 1} \dots U_{i, l_i} \}$.
  The set $\mathcal{L'}$ contains all the constraints unrelated to $\alpha_1 \dots \alpha_n$,
  and the linear types $T_{1, 1} \dots U_{n, l_n}$ are all composite.
  		
  Depending on the types $T_{1, 1} \dots U_{n, l_n}$ :
	\begin{itemize}
		\item If this set is empty, then \\
			\begin{tabular}{l}
				let $\sigma, \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L'})$ \\
				return $\sigma, \mathcal{L''} \cup \{ \alpha_i <: \alpha_j \}$
			\end{tabular}
	  
	  \item If not, it contains an element $V$, which can be either $V^1 \,\bullet \, V^2$, with $\bullet$ one in $\{ \otimes, \multimap \}$, or
	  	$\top$. The algorithm proceeds as follow :\\
	  	\begin{tabular}{l}
	  		for each $\alpha_i$ \\
	  		~~ if $V = \top$ then \\
	  		~~ ~~ map $\alpha_i$ to $\top$ \\
	  		~~ else \\
	  		~~ ~~ let $n_i, m_i, \beta_i, \gamma_i$ be fresh \\
	  		~~ ~~ map $\alpha_i$ to $!^{n_i} \beta_i ~\bullet~ !^{m_i}\gamma_i$ in $\sigma$ \\
	  		substitute $\alpha_1 \dots \alpha_n$ in $\mathcal{L}$ \\
	  		reduce $\mathcal{L}$ \\
	  		let $\sigma', \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L})$ \\
	  		return $\sigma' \circ \sigma, \mathcal{L''}$
	  	\end{tabular}
  \end{itemize}

  Of course, if the set of sub-typing constraint is empty, then the algorithm stops.
  TypeUnification can fail in two different ways : either it attempted to construct an infinite
  type, and the variable ordering failed, or the reduction encountered an absurd composite constraint.
\end{defn}

\begin{defn}{Flag unification}
	The algorithm inputs a set of atomic constraints, and returns a substitution $\sigma$ on flags, along with
	the remaining constraints (all atomic).
	
	The algorithm looks for constraints of the form
	\begin{itemize}
		\item $1 \le n$, in which case it removes the constraint, and sets $n$ to $1$
		\item $n \le 0$, in which case it removes the constraint, and sets $n$ to $0$
	\end{itemize}	
	When setting a flag to a value, it also needs to replace the instances of this flag in the constraint set.
	If no such constraints remains, it returns. The algorithm fails if and only if it encounters a absurdity,
	as in the case of the set $\{ 1 \le n, n \le 0 \}$.
\end{defn}

\subsection{Termination and correctness}

\begin{defn} Let $\mathcal{L}$ be a constraint set. For the purpose of the proof of termination, the following notations are introduced :
	\begin{itemize}
		\item[$\#\mathcal{L}$] for the complexity of $\mathcal{L}$, given by the number of connectives $\multimap$,
			$\otimes$ and symbols $\top$ used in the types of the sub-typing constraints
		\item[$|\mathcal{L}|$] for the number of constraints (sub-typing and flag) of $\mathcal{L}$
	\end{itemize}
	The index of $\mathcal{L}$ is defined as pair $(\#\mathcal{L}, |\mathcal{L}|)$, equipped with the lexicographical order.
\end{defn}

\begin{lemma}{Termination}
	\textit{For all constraint sets $\mathcal{L}$, the unification algorithm applied to $\mathcal{L}$ terminates. }
	\begin{proof}
		By induction on indexed sets (see definition above)
		\begin{itemize}
			\item If the index is $(0, N)$, then $\mathcal{L}$ is only composed of atomic constraints, and TypeUnification returns
				immediately when applied to $\mathcal{L}$.
				
			\item If the index is $(C, N)$.
				Let $\alpha_1 \dots \alpha_n$ be the youngest variables of $\mathcal{L}$. The set $\mathcal{L}$ can
				be split as $\mathcal{L'} \cup \{\alpha_i <: \alpha_j \} \cup \{ T_{i, 1} \dots T_{i, k_i} <: \alpha_i <: U_{i, 1} \dots U_{i, l_i} \}$.
				Depending on the types $T_{1, 1} \dots U_{n, l_n}$ : \\

				If $T_{1, 1} \dots U_{n, l_n}$ is empty, since $\mathcal{L'} \subsetneq \mathcal{L}$, it ensues $N' = |\mathcal{L'}| < N$.
				Moreover, because all the constraints of $\mathcal{L} \,\backslash\, \mathcal{L'}$ are atomic, $C' = \#\mathcal{L'} = C$.
				Consequently, the index $(C', N')$ of $\mathcal{L'}$ is such that $(C', N') \lneq (C, N)$.
				Thus, the induction hypothesis applies, and the function call $\text{TypeUnification}\,(\mathcal{L'})$ terminates, and the same
				for $\text{TypeInference}\,(\mathcal{L})$. \\
							
				If it contains $V = \top$. Each variable $\alpha_i$ is mapped in $\sigma$ to $\top$.
				The result of the application of the new mappings $\sigma$ to $\mathcal{L}$ is :
			  	$$\sigma \mathcal{L} = \mathcal{L'} \cup \{\top <: \top\} \cup \{ T_{i, 1} \dots T_{i, k_i} <: \top <: U_{i, 1} \dots U_{i, l_i} \}$$
       	What remains after reduction of the composite constraints is only $\mathcal{L'}$.
       	The complexity of the reduced constraint set $\sigma \mathcal{L}$ is :
			  	$$C' = \#\sigma\mathcal{L} = \#\mathcal{L'} $$
			  which is strictly inferior to $C$, meaning $(C',|\sigma\mathcal{L}|) \lneq (C, N)$. The induction hypothesis holds, and the function
			  call $\text{TypeUnification}\,(\sigma \mathcal{L})$ terminates, giving the termination of the call
			  $\text{TypeUnification}\,(\mathcal{L})$. \\
							
				If it contains $V = V_1 \,\bullet\, V_2$. Since that the variable ordering did not fail, we know for sure that
						$$\alpha_1 \dots \alpha_n ~ \notin ~ \bigcup_{i, k} FV(T_{i, k}) \cup \bigcup_{i, l} FV(U_{i, l})$$
				Each $\alpha_i$ is mapped in $\sigma$ to $!^{n_i} \beta_i ~ \bullet ~ !^{m_i}\gamma_i$.
				The result of the application of the new mappings $\sigma$ to $\mathcal{L}$ is :
			  	\begin{center}
			  	\begin{tabular}{lcl}
			  		$\sigma \mathcal{L}$ & $ = $ & $\mathcal{L'}$ \\
				  	& $ \cup $ & $\{!^{n_i} \beta_i ~ \bullet ~ !^{m_i}\gamma_i <: \,!^{n_j} \beta_j ~ \bullet ~ !^{m_j}\gamma_j \}$ \\
				  	& $ \cup $ & $\{ T_{i, 1} \dots T_{i, k_i} <: \,!^{n_i} \beta_i ~ \bullet ~ !^{m_i}\gamma_i <: U_{i, 1} \dots U_{i, l_i} \}$
				  \end{tabular}
				  \end{center}
       	What remains after reduction of the composite constraints is
					\begin{center}
			  	\begin{tabular}{lcl}
			  		$\sigma \mathcal{L}$ & $ = $ & $\mathcal{L'}$ \\
			  		& $ \cup $ & $\{m_j \le m_i, ~n_j \le n_i, ~\beta_i <: \beta_j, ~\gamma_i <: \gamma_j \}$ \\
			  		& $ \cup $ & $\{ T^1_{i, 1} \dots T^1_{i, k_i} <: \beta_i <: U^1_{i, 1} \dots U^1_{i, l_i} \}$ \\
			  		& $ \cup $ & $\{ T^2_{i, 1} \dots T^2_{i, k_i} <: \gamma_i <: U^2_{i, 1} \dots U^2_{i, l_i} \}$ \\
			  		& $ \cup $ & $\{$ some flag constraints $\}$
			  	\end{tabular}
			  	\end{center}
				depending on the connective $\bullet$, the orientation of the constraints $\beta_i <: \beta_j$ and $T^1_{i, k} <: \beta_i <: U^1_{i, l}$
			  may be reversed, though it is of no consequence to the proof.
			  In the reduction of the constraints $T_{i, 1} \dots T_{i, k_i} <: \alpha_i <: U_{i, 1} \dots U_{i, l_i}$, it is assumed that
			  the types $T_{i, k}$ and $U_{i, l}$ are of the form $T^1_{i, k} ~\bullet~ T^2_{i, k}$ and $U^1_{i, l} ~\bullet~ U^2_{i, l}$. \\
			  Following, the complexity of the reduced constraint set $\sigma \mathcal{L}$ compared to that of the original set $\mathcal{L}$ is :
			  	$$C' = \#\sigma\mathcal{L} = \#\mathcal{L'} + \sum_{i, k} \#T_{i, k} - 1 + \sum_{i, l} \#U_{i, l} - 1 $$
			  which is strictly inferior to $C$, meaning $(C',|\sigma\mathcal{L}|) \lneq (C, N)$. The induction hypothesis holds, and the function
			  call $\text{TypeUnification}\,(\sigma \mathcal{L})$ terminates, giving the termination of the call
			  $\text{TypeUnification}\,(\mathcal{L})$.
			  
		\end{itemize}
	\end{proof}
\end{lemma}

\begin{lemma}{Correctness}
	\textit{Let $\mathcal{L}$ be a constraint set. The unification algorithm applied to $\mathcal{L}$ produces a
		set $\mathcal{L'}$ and a substitution $\sigma$ such that :
			\begin{center}
			\begin{tabular}{ll}
				(a) & for every solution $\tau$ of $\mathcal{L'}$, $\tau \circ \sigma$ is a solution of $\mathcal{L}$ \\
				(b) & for every solution $\rho$ of $\mathcal{L}$, there exists $\tau$ solution of $\mathcal{L'}$ such that $\rho = \tau \circ \sigma$ \\
				(c) & $\sigma \mathcal{L'} = \mathcal{L'}$
			\end{tabular}
			\end{center}}

	\begin{proof}
		The third property (c) is easier to prove than the other two, and the proof will be omitted.
		By induction on indexed sets. If the index is
		\begin{itemize}
			\item $(0, N)	$. $\mathcal{L}$ is composed only of atomic constraints, and TypeUnification returns $\varnothing, \mathcal{L}$.
				The properties (a) and (b) are trivially satisfied.
				
			\item $(C, N)$, and $\mathcal{L} = \mathcal{L'} \cup \{ \alpha_i <: \alpha_j \}$. \\
				Let $\sigma, \mathcal{L''} = ~\text{TypeInference}\,(\mathcal{L'})$. By application of the induction hypothesis, $\sigma$ and
				$\mathcal{L''}$ respect the properties (a) and (b).
					\begin{itemize}
						\item[(a)] Let $\tau$ be a solution of $\mathcal{L''} \cup \{ \alpha_i <: \alpha_j \}$. $\tau$ being a solution of $\mathcal{L''}$,
							the application of the property (a) with $\tau$, $\mathcal{L''}$ and $\sigma$ proves that $\tau \circ \sigma$ is a solution of
							$\mathcal{L'}$. Overall, $\tau \circ \sigma$ is a solution of $\mathcal{L}$.
							
						\item[(b)] Let $\rho$ be a solution of $\mathcal{L}$. The property (b) applied with $\mathcal{L''}$ and $\sigma$ ensures the existence
							of $\tau$ solution of $\mathcal{L''}$ such that $\tau \circ \sigma$ is equal to $\rho$. Moreover, it follows from (c) that
							$\sigma \{ \alpha_i <: \alpha_j \} = \{\alpha_i <: \alpha_j \}$. Thus,
								$$\tau \circ \sigma \{\alpha_i <: \alpha_j \} = \tau \{\alpha_i <: \alpha_j \}$$
							Since $\rho = \tau \circ \sigma$ is a solution of $\{\alpha_i <: \alpha_j \}$, it follows that $\tau$ is a solution of
							$\{\alpha_i <: \alpha_j \}$, and also of $\mathcal{L''} \cup \{\alpha_i <: \alpha_j \}$. This proves the property (b).
					\end{itemize}
			
			\item $(C, N)$, and $\mathcal{L} = \mathcal{L'} \cup \{ \alpha_i <: \alpha_j \} \cup
				\{ T_{i, 1} \dots T_{i, k_i} <: \alpha_i <: U_{i, 1} \dots U_{i, l_i} \}$.
				The case where the composite types $T_{1, 1} \dots U_{n, l_n}$ is solved easily, as the mappings $[\alpha_i \mapsto]$ give the
				only solution for $\alpha_1 \dots \alpha_n$. By applying the induction hypothesis, the properties (a), (b) and (c) are easily
				proved. \\
				
				Otherwise, let $\sigma$ be the substitution $\sigma = [\alpha_i \mapsto !^{n_i}\beta_i \,\bullet\, !^{m_i}\gamma_i]$, and
				$\mathcal{L}^*$ the reduced set $\sigma \mathcal{L}$. Finally, let $\sigma', \mathcal{L''} = ~\text{TypeUnification}\,(\mathcal{L}~*)$.
				The induction hypothesis applied to $\mathcal{L}^*$ proves that $\sigma', \mathcal{L''}$ respect the properties (a), (b) and (c).
					\begin{itemize}
						\item[(a)] Let $\tau$ be a solution of $\mathcal{L''}$. By application of (b), $\tau \circ \sigma$ is a solution of $\mathcal{L}^*$.
							Since the solutions of $\mathcal{L}^*$ and $\sigma \mathcal{L}$ are the same, $\tau \circ \sigma'$ is also a solution of
							$\sigma \mathcal{L}$. Thence, $\tau \circ \sigma' \circ \sigma$ is a solution of $\mathcal{L}$.
							
						\item[(b)] Let $\rho$ be a solution of $\mathcal{L}$. In particular, $\rho$ contains the mappings :
								$$\rho = \rho' \cup [\alpha_i \mapsto V_i \,\bullet\, W_i]$$
							Thus it can be modified to be :
								$$\rho = (\rho' \cup [!^{n_i}\beta_i \mapsto V_i] \cup [!^{m_i}\gamma_i \mapsto W_i]) \circ
									[\alpha_i \mapsto \,!^{n_i}\beta_i \,\bullet\, !^{m_i}\gamma_i]$$
							Using the notation $\rho^* = \rho' \cup [!^{n_i}\beta_i \mapsto V_i] \cup [!^{m_i}\gamma_i \mapsto W_i]$,
							$\rho = \rho^* \circ \sigma$. By application of the sub-typing relation rules on $\mathcal{L}^*$, it can be proved
							that $\rho^*$ is a solution of $\mathcal{L}^*$. By application of the induction hypothesis and (b), there exists
							$\tau$ solution of $\mathcal{L''}$, such that $\rho^* = \tau \circ \sigma'$. Hence $\rho = \tau \circ \sigma' \circ \sigma$.
					\end{itemize}
		\end{itemize}
	\end{proof}
\end{lemma}

\subsection{Approximations}

The previous algorithm gives an exact, and in a sense most general solution, because every possible type is represented by the
pair $\sigma, \mathcal{L}$ returned by the algorithm (as enforced by the property (b)). However, the exact unification is highly
inefficient as it can as much as double the number of variables each step (giving an exponential limit at the worst for the algorithm), and
sometimes only the solvability of the set is needed. \\
That is why it is possible, at the cost of a weakened property (b'), to make some approximations during the unification.
Some possible approximations are listed below, which respect the property (b') :
  \begin{center}
		\textit{if there exists a solution $\rho$ of $\sigma$, then the unification returns a solution without failing}
 	\end{center}
	
\begin{itemize}
	\item In the case where $\mathcal{L} = \mathcal{L'} \cup \{\alpha_i <: \alpha_j \}$, instead of sparing the constraints
		$\{\alpha_i <: \alpha_j \}$, make the substitution $[\alpha_i \mapsto \alpha_1]$ with $i \in \{2 \dots n\}$.
		
	\item In the case where $\mathcal{L} = \mathcal{L'} \cup \{T <: \alpha_1 <: \dots <: \alpha_n <: U\}$, make the substitution
		$\sigma = [\alpha_i \mapsto T]$, and then apply TypeUnification to $\mathcal{L'} \cup \{ T <: U \}$.
		
	\item In the case where $\mathcal{L} = \mathcal{L'} \cup \{\alpha_i <: \alpha_j\} \cup \{T_{i, 1} \dots T_{i, k_i} <: \alpha_i \}$,
		make the substitution $\sigma = [\alpha_i \mapsto \alpha_1]$ for $i \in \{2 \dots n\}$, and apply the algorithm to
		$\mathcal{L'} \cup \{T_{1, 1} \dots T_{n, k_n} <: \alpha_1\}$.
		
	\item The same for the case $\mathcal{L} = \mathcal{L'} \cup \{\alpha_i <: \alpha_j\} \cup \{\alpha_i <: U_{i, 1} \dots U_{i, l_i}\}$
\end{itemize}

\section{Proto-quipper}

\subsection{Additions to the language}

The terms and types of the language are already listed in the paper on proto-quipper. The only modification to make is to adapt
the typing rules for the purpose of the algorithm, meaning modify them to fit in LL'.
The rule for typing circuits is omitted, as the term will not be generally used in written programs.

\begin{defn}{\bf Additional typing rules}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(rev)$}
			\UnaryInfC{$!^I \Gamma \vdash_{\{1 \le I \}} rev : ~!^1 (!^1Circ(T, U) \multimap~ !^1Circ(U, T)$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(unbox)$}
		\UnaryInfC{$!^I\Gamma \vdash_{\{1 \le I\}} unbox : ~!^1(!^1Circ(T, U) \multimap~ !^n(T \multimap U))$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(box)$}
		\UnaryInfC{$!^I\Gamma \vdash_\varnothing box^T : ~!^1(!^1(T \multimap U) \multimap~ !^1Circ (T, U))$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(\texttt{True})$}
			\UnaryInfC{$!^I \Gamma \vdash_{\{1 \le I \}} \texttt{True} : ~!^n bool$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{$(\texttt{False})$}
			\UnaryInfC{$!^I \Gamma \vdash_{\{1 \le I \}} \texttt{False} : ~!^n bool$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$\Gamma_1, ~!^I\Delta \vdash_\mathcal{L} t : ~!^nbool$}
		\AxiomC{$\Gamma_2, ~!^I\Delta \vdash_\mathcal{L'} u : T$}
		\noLine
		\UnaryInfC{$\Gamma_2, ~!^I\Delta \vdash_\mathcal{L''} v : T$}
		\RightLabel{$(if)$}
		\BinaryInfC{$\Gamma_1, \Gamma_2, !^I\Delta \vdash_{\mathcal{L} \cup \mathcal{L'} \cup \mathcal{L''} \cup \{1 \le I\}}
			\text{if}~ t ~\text{then}~ u ~\text{else}~ v : T$}
	\end{prooftree}
\end{defn}

\subsection{Algorithms}

\begin{defn}{Constraint typing}
	The following cases are added to the constraint typing algorithm :
	\begin{itemize}
		\item $\text{ConstraintTyping} ~ (~ !^I \Delta \vdash \texttt{True} ~|~ \texttt{False} : T ~) = $ \\
		  \begin{tabular}{l}
		  	let $n$ be fresh \\
				output $\{ !^n bool <: T \} \cup \{ 1 \le I \}$
		  \end{tabular}
		
		\item $\text{ConstraintTyping} ~ (~ \Gamma \vdash \text{if}~ t ~\text{then}~ u ~\text{else}~ v : T ~) = $ \\
			\begin{tabular}{l}
				let $n$ be fresh \\
				let $\mathcal{L} = ~ \text{ConstraintTyping} ~ (~ \Gamma|_t \vdash t : \, !^nbool ~)$ \\
				let $\mathcal{L'} = ~ \text{ConstraintTyping} ~ ( ~ \Gamma|_{u, v} \vdash u : T)$ \\
				let $\mathcal{L''} = ~ \text{ConstraintTyping} ~ ( ~ \Gamma|_{u, v} \vdash v : T)$ \\
				let $!^I\Delta = \Gamma ~ \backslash ~ (FV(t) \oplus FV(u), FV(v))$ \\
				output $\mathcal{L \cup L' \cup L''} \cup \{ 1 \le I \}$
			\end{tabular}

		\item $\text{ConstraintTyping} ~ (~ !^I \Delta \vdash rev : T ~) = $ \\
		  \begin{tabular}{l}
		  	let $\alpha, \beta$ be fresh type variables and $n, m$ fresh flags \\
				output $\{ \,!^1 (!^1Circ (!^n\alpha, ~!^m\beta) \multimap ~!^1Circ (!^n\beta, ~!^m\alpha)) <: T \} \cup \{ 1 \le I \}$
		  \end{tabular}
		  
		\item $\text{ConstraintTyping} ~ (~ !^I \Delta \vdash unbox : T ~) = $ \\
		  \begin{tabular}{l}
		  	let $\alpha, \beta$ be fresh type variables and $n, m$ fresh flags \\
				output $\{ \,!^1 (!^1Circ (!^n\alpha, ~!^m\beta) \multimap ~!^1(!^n\alpha \multimap ~!^m\beta)) <: T \} \cup \{ 1 \le I \}$
		  \end{tabular}

		\item $\text{ConstraintTyping} ~ (~ !^I \Delta \vdash box : T ~) = $ \\
		  \begin{tabular}{l}
		  	let $\alpha, \beta$ be fresh type variables and $n, m$ fresh flags \\
				output $\{!^1(!^n\alpha \multimap ~!^m\beta) \multimap \,!^1Circ (!^n\alpha, ~!^m\beta)) <: T \} \cup \{ 1 \le I \}$
		  \end{tabular}
	\end{itemize}
\end{defn}

\begin{defn}{Unification}
	The unification algorithm does not in the principle. The only additions are the new types $qbit$, $bool$ which behave the same
	as $\top$ ; and the new connective $Circ$ comparable to $\multimap$ and $\otimes$.
\end{defn}

\begin{defn}{Linearity check} Neither the constraint typing algorithm nor the unification actively enforces the linearity of the qbit type.
	This means a linearity check has to be performed after the typing and the unification. The risk would be to reject
	perfectly typeable terms, which use qbits in a linear way, because of an approximative typing. However, it has been proved that
	the unification, as well as the constraint typing, always give all the solutions. This means that if the unification states that
	a type must be duplicable, so it is. Then, during the linearity check, if a type $!^1 qbit$ is encountered, this means the term is
	certainly not typeable, else there is a solution that type the said term with $!^0 qbit$.

\end{defn}

\end{document}