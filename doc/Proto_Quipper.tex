\documentclass{article}


\input{Proto_Quipper.sty}


% ----------------------------------------------------------------------
% General Information.
\title{\textbf{Report on Proto-Quipper 0.1}}
\date{}
\author{}


% ----------------------------------------------------------------------
\begin{document}


\maketitle


\tableofcontents


\section{Introduction}

Quipper is currently implemented as an embedded language, within 
the host language Haskell. This has many advantages, for example, 
the ability to implement a large-scale system very rapidly. However, 
there are also a few disadvantages. One of these is that the Haskell 
type system, while providing many  type-safety properties, is not in 
general strong enough to ensure full type-safety of the quantum 
programs. In the current implementation, it is therefore the 
programmer's responsibility to ensure that quantum components are 
plugged together in physically meaningful ways. This means that 
certain types of programming errors will not be prevented by the 
compiler; in the worst case, this may lead to ill-formed output or 
run-time errors in other parts of the tool chain.

We have developed a type-safe version of Quipper as a standalone 
(non-embedded) programming language, which we call Proto-Quipper. 
The Proto-Quipper language is designed to ``enforce the physics'', 
in the sense that it will detect, at compile-time, programming 
errors that could lead to ill-formed or undefined circuits. 

We distinguish between the \emph{core} of Proto-Quipper, which 
represents the proved type-safe fragment of the language, and 
the \emph{extensions} of the language, containing newly 
implemented features of Proto-Quipper that are currently under 
development. In what follows, we provide an introduction to 
Proto-Quipper, prove the type safety of the core language and 
describe its type inference algorithm. We then discuss already 
available extensions to the core language and future 
developments. We conclude with an introduction to programming 
in Proto-Quipper.


\section{Design Rationale}

Our approach was to start with a limited (but still expressive) 
fragment of the Quipper language and make it completely type-safe. 
This provides a basis for extension to the full language in the 
future. The current version of Proto-Quipper (0.1) was designed 
with two goals in mind: 
\begin{itemize}
  \item incorporate Quipper's ability to generate and act on 
  quantum circuits, and 
  \item provide a linear type system to guarantee that the 
  produced circuits are physically meaningful (in particular, 
  properties like no-cloning are respected).
\end{itemize}
To achieve these goals, we based Proto-Quipper on the Quantum 
Lambda Calculus (QLC, see \cite{SeVa09}). In the QLC, the execution 
of programs is modelled by the so-called reduction relation. This 
relation is defined on \emph{closures}, which are 
essentially pairs $[C,t]$ consisting of a term of the language 
$t$ and a quantum state $C$. The state is a unit vector in a 
complex Hilbert space and $t$ is a term whose free variables are 
linked to the qubits composing $C$. The quantum state is held in 
a quantum device capable of performing certain operations 
(applying unitaries, measuring qubits,\ldots). The reduction in 
the QLC is then defined as a probabilistic rewrite procedure on 
these closures. Typically, the reduction will be classical until 
a redex involving a quantum constant is reached. At this point, 
the quantum device will be instructed to perform the appropriate 
quantum operation. For example: ``Apply a Hadamard gate to qubit 
number 3''. 

The reduction in Proto-Quipper is similarly defined on closures. 
However, a closure $[C,t]$ now consists of a term $t$ and a 
\emph{circuit state} $C$. This state represents the circuit being 
currently built. Instead of having a quantum device capable of 
performing quantum operations, we assume that we have a 
\emph{circuit constructor} capable or performing certain circuit 
building operations (appending gates,\ldots). The reduction is 
then defined as a non-probabilistic rewrite procedure on closures. 
As in the QLC, some redexes will affect the state by sending 
instructions to the circuit constructor. For example: ``Append a 
Hadamard gate to wire number 3''.


\section{The Core Language}

In this section, we define the core of Proto-Quipper. We 
present in details the syntax, type system and 
operational semantics of the language.

\subsection{Types and Terms}
\label{ssec-types-and-terms}

\begin{definition} 
The \emph{types} of Proto-Quipper are defined by:
\begin{center}
\begin{tabular}{rl}
$\type~A,B~\bnf$ & $ qubit \bor 1 \bor Bool \bor A\tensor B \bor 
A\loli B \bor !A \bor Circ (T,U).$\\
\end{tabular}
\end{center}
Among the types, we single out the subset of \emph{QData types}:
\begin{center}
\begin{tabular}{rcl}
$\qdatatype~T,U$ & $\bnf$ & $qubit \bor 1 \bor T \tensor U.$
\end{tabular}
\end{center}
\end{definition}

The type system of Proto-Quipper, like the type system of the QLC, 
is based on intuitionistic linear logic (see \cite{Gir87}). 
It can be helpful to think of types as sets of values. Under this 
interpretation, the types can be understood as follows. $Bool$ is 
the set of booleans, $1$ is the unit type, $A\x B$ is the set of 
pairs composed of a left member of type $A$ and of right member 
of type $B$ and $A\loli B$ is the set of functions from $A$ to 
$B$. The type $!A$ can be understood as the subset of $A$ 
consisting of values that have the additional property of being 
\emph{duplicable} or \emph{reusable}. We will sometimes write 
$!^nA$, with $n\in\N$, to mean: 
\[
\underbrace{!\ldots !}_{n} A.
\]
The remaining types are specific to Proto-Quipper. The elements 
of $qubit$ are (quantum) wire identifiers. A $qubit$ is essentially 
a reference to a  logical qubit within a computation. It can be 
thought of as a reference to a quantum bit on some physical device, 
or simply as a  reference to a quantum wire within a circuit being 
generated. The QData types are circuit endpoints, which consist of 
tuples of wire identifiers. Finally, the type $Circ(T,U)$ is the 
set of all circuits having $T$-type input and $U$-type output. 

\begin{definition}
Assume three countable sets: a set $\vset$ of \emph{variables}, a 
set $\qset$ of \emph{quantum addresses} and a set $\cset$ of 
\emph{circuit constants}. The \emph{terms} of Proto-Quipper are 
defined by:
\begin{center}
\begin{tabular}{rcl}
$\term~a,b,c$ & $\bnf$ & $x \bor q \bor (t,C,a) \bor \true 
  \bor \false \bor \p{a,b} \bor * \bor$ \\[0.05in]
& & $ab \bor \lambda x.a \bor box^T \bor unbox \bor rev 
    \bor $\\[0.05in]
& & $\ifthenelse{a}{b}{c} \bor \letin{\p{x,y}}{a}{b}.$
\end{tabular}
\end{center}
Among the terms, we single out the subset of \emph{QData terms}:
\begin{center}
\begin{tabular}{rcl}
$\qdataterm~t,u$ & $\bnf$ & $q \bor * \bor \p{t,u}.$
\end{tabular}
\end{center}
Moreover, we assume that $\cset$ is equipped with two functions 
$In,Out\from \cset\to\pset_f(\qset)$ and that $\qset$ is 
well-ordered.
\end{definition}

The meaning of most terms is intended to be the standard 
one. For example $\p{a,b}$ is the pair of $a$ and $b$, 
$\true$ and $\false$ are the booleans and $\lambda x.a$ 
is the function which assigns $a$ to $x$. For the more 
unusual terms we have:
\begin{itemize}
  \item $q$ is a wire identifier,
  \item $(t,C,a)$ is a circuit with $t$ as an input and $a$ as an 
        output,
  \item $box^T$ is a constant used to turn a circuit-producing 
        function into a circuit,
  \item $unbox$ is a constant used to turn a circuit into a 
        circuit-producing function and
  \item $rev$ is a constant used to reverse circuits.
\end{itemize}
Note that the term $box^T$ depends on the type $T$. This 
\emph{Church-style} typing of the language is the reason why types 
were introduced before terms. Note also that in the above syntax, 
$box^T$, $unbox$ and $rev$ are terms in their own right. In earlier 
versions of these notes, they were term constructors. The current 
presentation was eventually adopted because it allows for a more 
concise exposition of the operational semantics. Finally, remark 
that in a term like $(t,C,a)$, $t$ is a QData term but $a$ isn't. 
The type system to be introduced later will guarantee that even 
though $a$ is not yet a QData term it will eventually reduce to 
one. 

The \emph{values} are the terms whose execution is finished.

\begin{definition}
The \emph{Values} of Proto-Quipper are defined by:
\begin{center}
\begin{tabular}{rcl}
$\val$ $v,w$ & $\bnf$ & $x \bor q \bor (t,C,u) \bor \true \bor 
  \false \bor \p{v,w} \bor$ \\
& & $* \bor \lambda x.a  \bor box^T \bor unbox \bor rev.$
\end{tabular}
\end{center}
\end{definition}

The notational conventions used throughout these notes are:
\begin{itemize}
  \item $x,y,z,\ldots$ for variables,
  \item $q_1,q_2,q_3,\ldots$ for quantum addresses,
  \item $C,D,\ldots$ for circuit constants,
  \item $A,B,\ldots$ for types,
  \item $a,b,c,\ldots$ for terms,
  \item $S,T,U,\ldots$ for QData types,
  \item $s,t,u,\ldots$ for QData terms and
  \item $v,w,\ldots$ for values.
\end{itemize}
Additions to these conventions will be provided throughout.


\subsection{Operations on Types and Terms}

We now introduce some useful operations on types and terms. 

\begin{definition}
The set of \emph{free variables} of a term $a$, written $FV(a)$, 
is defined inductively as follows:
\begin{itemize}
  \item $FV(x)=\s{x}$,
  \item $FV(\p{a,b})=FV(a)\cup FV(b)$,
  \item $FV(ab)=FV(a)\cup FV(b)$,
  \item $FV(\lambda x.a)=FV(a)\setminus\s{x}$,
  \item $FV(\ifthenelse{a}{b}{c} = FV(a) \cup FV(b) \cup FV(c)$,
  \item $FV(\letin{\p{x,y}}{a}{b}= FV(a)\cup (FV(b)\setminus \s{x,y})$,
  \item $FV((t,C,a))= FV(a)$ and
  \item $FV(a)=\varnothing$ in all remaining cases.
\end{itemize}
\end{definition}

The above definition of free variable extends the usual one. Note 
that the free variables of a term of the form $(t,C,a)$ are the 
free variables of $a$. This is justified since no variables ever 
appear in the QData term $t$. The notions of $\alpha$-equivalence, 
capture-avoiding substitution, etc. are defined in a straightforward 
manner. By analogy with the free variables of a term, we introduce a 
notion of \emph{quantum address of term}.

\begin{definition}
The set of \emph{quantum addresses} of a term $a$, written $FQ(a)$, is 
defined inductively as follows:
\begin{itemize}
  \item $FQ(q)=\s{q}$,
  \item $FQ(\p{a,b})=FQ(a)\cup FQ(b)$,
  \item $FQ(ab)=FQ(a)\cup FQ(b)$,
  \item $FQ(\lambda x.a)=FQ(a)$,
  \item $FQ(\ifthenelse{a}{b}{c}) = FQ(a) \cup FQ(b) \cup FQ(c)$,
  \item $FQ(\letin{\p{x,y}}{a}{b})= FQ(a)\cup FQ(b)$ and
  \item $FQ(a)=\varnothing$ in all remaining cases.
\end{itemize}
\end{definition}

Remark that $FQ((t,C,a))=\varnothing$. This reflects the idea that the 
quantum addresses appearing in $t$ and $a$ are ``bound'' in $(t,C,a)$. 

To append circuits, we will need to be able to express the way in 
which wires should be connected. For this, we use the notion of a 
\emph{binding}.

\begin{definition}
A \emph{binding} is a bijection $\qset\to \qset$.
\end{definition}

% For now it is simply more convenient to have binding be bijections.
% In fact they could be functions and additional conditions could
% be added elsewhere.

Adding to the list of notational conventions above, we will write 
$\binding$ for an arbitrary binding. 

\begin{definition}
If $a$ is a term with $FQ(a)=\s{q_1,\ldots,q_n}$ and $\binding$ is 
a binding, then $\binding(a)$ is the following term:
\[
\binding(a)= a[\binding(q_1)/q_1,\ldots ,\binding(q_n)/q_n].
\]
\end{definition}

\begin{definition}
The partial function $bind: \qdataterm^2\to \pow (\qset^2)$ is 
defined recursively as follows:
\[
bind (t,u)= \left\{
  \begin{array}{ll}
    \varnothing & \mbox{if}~~ t=u=*, \\
    \s{(q_1,q_2)} & \mbox{if}~~ t=q_1 \mbox{ and } u=q_2, \\        
    bind (t_1,u_1) \cup bind (t_2,u_2) & 
      \mbox{if}~~ t=\p{t_1,t_2} \mbox{ and } u=\p{u_1,u_2}, \mbox{ and } \\
    \mbox{undefined} & \mbox{in all remaining cases.}
  \end{array}
\right.
\]
\end{definition}

\begin{remark}
\label{bind_extension}
If $t$ and $u$ are QData terms for which $bind$ is defined, we 
can extend $bind(t,u)$ to a binding $\binding$ by setting 
$\binding (q_1) = q_2$ if $\tuple{q_1,q_2}\in bind (t,u)$ and 
$\binding (q_1) = q_1$ otherwise.
\end{remark}

\begin{definition}
Let $T$ be a QData type and $X$ a proper subset of $\qset$. 
An \emph{$X$-specimen} for $T$ is QData term written $\spec_X(T)$ 
defined by induction as follows:
\begin{itemize}
  \item $\spec_X(1)=*$,
  \item $\spec_X(qubit)=q$ where $q$ is the smallest quantum 
  index of $\qset\setminus X$,
  \item $\spec_X(T\tensor U)=\p{t,u}$ where $t=\spec_X(T)$ 
  and $u=\spec_{X\cup FQ(t)}(U)$.  
\end{itemize}
\end{definition}

% The definition of specimen uses the fact that $\mathcal{Q}$ is 
% well-ordered.

Informally, an $X$-specimen for $T$ is a QData term $t$ that is 
``fresh" with respect to the quantum addresses appearing in $X$.
If $X$ is clear, we simply write $\spec (T)$.


\subsection{The Type System}

The fact that a term is reusable should not prevent us from 
using it exactly once. Intuitively, this should imply that if a 
term has the type $!A$, then it should also have the type $A$. 
To capture this idea, we use a sub-typing relation on types.

\begin{definition}
The \emph{sub-typing relation} $<:$ is the smallest relation on 
types satisfying the rules given in 
figure~\hyperref[subtyping_congruences]{\ref*{subtyping_congruences}}.
\end{definition}

\begin{figure}[!ht]
\begin{mdframed}
\[
  \infer[]{qubit <: qubit}{}
~~~~
  \infer[]{1 <: 1}{}
~~~~
  \infer[]{Bool <: Bool}{}
\]
\[
  \infer[]{ (A_1\x A_2) <:  (B_1 \x B_2)}{A_1<:B_1~~A_2<:B_2}
~~~~
  \infer[]{ (A'\loli B) <: (A\loli B')}{A<:A'~~B<:B'}
\]
\[
  \infer[]{ Circ(A', B) <:  Circ(A, B')}{A<:A'~~B<:B'}
\]
\[
  \infer[]{ !^nA <: !^mB}{
    A<:B
    &
    (m=0)\vee (n\geq 1)
  }
\]
% A not as nice version of the subtping rules:
%
%\[
%  \infer[]{!^nqubit <: !^mqubit}{}
%~~~~
%  \infer[]{!^n1 <: !^m1}{}
%~~~~
%  \infer[]{!^nBool <: !^mBool}{}
%\]
%\[
%  \infer[]{!^n (A_1\x A_2) <: !^m (B_1 \x B_2)}{A_1<:B_1~~A_2<:B_2}
%~~~~
%  \infer[]{!^n (A'\loli B) <: !^m (A\loli B')}{A<:A'~~B<:B'}
%\]
%\[
%  \infer[.]{!^n Circ(A', B) <: !^m Circ(A, B')}{A<:A'~~B<:B'}
%\]
\end{mdframed}
\caption{The sub-typing rules of Proto-Quipper.}
\label{subtyping_congruences}
\end{figure}

\begin{remark}
\label{subtyping_shape}
If $A<:B$ then:
\begin{enumerate}
  \item if $A\in\s{qubit, 1, Bool}$, then $A=B$;
  \item if $A=A_1\x A_2$, then $B=B_1\x B_2$, 
  $A_1<:B_1$ and $A_2<:B_2$;
  \item if $A=A_1\loli A_2$, then $B=B_1\loli B_2$, 
  $B_1<:A_1$ and $A_2<:B_2$;
  \item if $A=Circ(A_1, A_2)$, then $B=Circ(B_1,B_2)$, 
  $B_1<:A_1$ and $A_2<:B_2$;
  \item if $B=!B'$, then $A=!A'$ and $A'<:B'$;\label{subtype_bang}
  \item if $A$ is not of the form $!A'$, then $B$ is not 
  of the form $!B'$.
\end{enumerate}
\end{remark}

\begin{proposition}
The subtyping relation is reflexive and transitive.
\end{proposition}

Note that the following equivalence holds: 
\[
(m=0)\wedge (n\geq 1) 
~\mbox{ iff }~ 
(m\geq 1) \implies (n\geq 1),
\]
so that, as expected, the following rule is derivable:
\[
  \infer[]{!A <: A}{}
  .
\]

\begin{definition}
A \emph{typing context} is a finite set 
$\s{x_1:A_1,\ldots,x_n:A_n}$ of pairs of a variable and 
a type, such that no variable occurs more than once. A 
\emph{quantum context} is a finite set of quantum variables. 
The expressions of the form $x:A$ in a typing context are 
called \emph{type declarations}.	
\end{definition}

We write $\Gamma$ or $\Delta$ for a typing context and $Q$ for 
a quantum context. If $\Gamma =\s{x_1:A_1,\ldots,x_n:A_n}$ is 
a typing context, then $|\Gamma|=\s{x_1,\ldots,x_n}$, 
$\Gamma (x_i)=A_i$ and we write $!\Gamma$ if $\Gamma(x_i)=!A_i'$ 
for every $i$. The union of two contexts 
$|\Gamma|\cap  |\Gamma'|=\varnothing$ is denoted by $\Gamma,\Gamma'$, 
and similarly for quantum contexts. Finally, we extend the subtyping 
relation to typing contexts as follows: $\Gamma <: \Gamma'$ if, and 
only if, $|\Gamma | = |\Gamma'|$ and $\Gamma (x_i)<: \Gamma' (x_i)$ 
for every $i$.

\begin{definition}
Let $T,U$ be QData types and $m,n\in\N$. For each of the constants, 
$box^T$, $unbox$ and $rev$ we introduce a type as follows:
\begin{itemize}
  \item $A_{box^T}(T,U,n)=!(T\loli U)\loli !^nCirc(T,U)$,
  \item $A_{unbox}(T,U,n)=Circ(T,U)\loli !^n(T\loli U)$ and
  \item $A_{rev}(T,U,n)=Circ(T,U) \loli !^nCirc(U,T)$.
\end{itemize}
\end{definition}

\begin{definition}
A \emph{typing judgment} is an expression of the form:
\[
\Gamma ; Q \entails a:A
\] 
where $\Gamma$ is a typing context, $Q$ is a quantum context, 
$a$ is a term and $A$ is a type. A typing judgment is \emph{valid} if 
it can be inferred from the rules given in figure 
\hyperref[trules]{\ref*{trules}}. In the rule $(cst_c)$, 
$c$ ranges over the set $\s{box^T, unbox, rev}$.
\end{definition}

Note that in the typing judgements of Proto-Quipper, quantum addresses 
and variables are kept separate. As a result, we don't have to specify 
that $q:qubit$ for every quantum address $q$ since the typing rules 
implicitly enforce this. However, when Proto-Quipper will be equipped 
with the ability to manipulate quantum \emph{and} classical wires, the 
type of a wire might have to be explicitly stated.

% Another reason for this is because in the reduction rule for
% (t,c,u) we need to be able to construct, e.g., t in a context
% that is empty but for the quantum addresses appearing in t.

\begin{figure}[!ht]
\begin{mdframed}
\[
\infer[(ax_c)]{!\Delta, x:A;\varnothing\entails x:B}{
  A<:B
}
~~~~
\infer[(ax_q)]{!\Delta;\s{q}\entails q:qubit}{
} 
\]
\[
\infer[(cst_c)]{!\Delta;\varnothing \entails c:B}{
  A_{c}(T,U,n)<:B
} 
~~~~
\infer[(unit)]{!\Delta;\varnothing\entails *:!^n 1}{
}
\]
\[
\infer[(\lambda_1)]{\Gamma;Q\entails \lambda x.b:A\loli B}{
  \Gamma,x:A;Q \entails b:B
}
~~~~
\infer[(\lambda_2)]{!\Delta;\varnothing \entails \lambda x.b:~!^{n+1}(A\loli B)}{
  !\Delta, x:A;\varnothing \entails b:B
}
\]
\[
\infer[(app)]{\Gamma_1,\Gamma_2, !\Delta;Q_1,Q_2\entails ca:B}{
  \Gamma_1, !\Delta;Q_1\entails c:A\loli B 
  &
  \Gamma_2, !\Delta ;Q_2\entails a:A 
}
\]
\[
\infer[(\x\mbox{-i})]{\Gamma_1,\Gamma_2, !\Delta;Q_1,Q_2\entails \p{a,b}:!^n(A\x B)}{
  \Gamma_1, !\Delta;Q_1\entails a:!^nA 
  &
  \Gamma_2, !\Delta ;Q_2\entails b:!^nB
}
\]
% Note that in fact the \x intro rule could have equivalently been written with
% a:!^nA b:!^mB and (a,b):!^o(A\x B) where o=min {n,m}
% Indeed the rules are equivalent via the type isomorphism !!A~!A and the 
% subtyping relation !A<:A. The moral here is that a pair is as 
% reusable as its least reusable component.
\[
\infer[(\x\mbox{-e})]{\Gamma_1,\Gamma_2, !\Delta;Q_1,Q_2\entails \letin{\p{x,y}}{b}{a}:A}{
  \Gamma_1, !\Delta;Q_1\entails b:!^n(B_1\x B_2) 
  &
  \Gamma_2, !\Delta, x:!^nB_1, y:!^nB_2 ;Q_2\entails a:A
}
\]
\[
\infer[(\top)]{!\Delta;\varnothing\entails \true:!^n Bool}{
} 
~~~~
\infer[(\bot)]{!\Delta;\varnothing\entails \false:!^n Bool}{
}
\]
\[
\infer[(if)]{\Gamma_1,\Gamma_2, !\Delta;Q_1,Q_2\entails \ifthenelse{b}{a_1}{a_2}:A}{
  \Gamma_1, !\Delta;Q_1\entails b:Bool 
  &
  \Gamma_2, !\Delta;Q_2 \entails a_1:A ~~~ \Gamma_2, !\Delta;Q_2 \entails a_2:A
}
\]
\[
\infer[(circ)]{!\Delta;\varnothing \entails (t,C,a):!^nCirc(T,U)}{
  Q_1\entails t:T 
  &
  !\Delta ; Q_2\entails a:U 
  &
  In(C)=Q_1 
  &
  Out(C)=Q_2
}
\]
\end{mdframed}
\caption{The typing rules of Proto-Quipper.}
\label{trules}
\end{figure}

To illustrate the safety properties of the type system, 
note that the $(\x\mbox{-i})$ rule ensures that 
$\lambda x. \p{x,x}$ cannot be given the type 
$qubit\loli qubit \x qubit$.


\subsection{Circuit Constructors}

As mentioned in Section 2, the reduction relation for 
Proto-Quipper is defined in the presence of a \emph{circuit
constructor}. This is a device capable of 
performing certain basic circuit building operations. It is 
not necessary to have a detailed description of the inner 
workings of this device. In fact, all that is required for 
the definition of Proto-Quipper's operational semantics is 
the existence of some primitive operations. These are wrapped 
in a structure that we take to axiomatize circuit constructors. 

\begin{definition}
\label{circuit_constructor}
A \emph{circuit constructor} consists of a pair of countable sets $\atuple{Q,S}$ 
together with the following maps:
\begin{itemize}
  \item $\mathtt{New}\from \pow_f(Q) \to S$,
  \item $\mathtt{In}\from S\to \pow_f(Q)$,
  \item $\mathtt{Out}\from S\to \pow_f(Q)$,
  \item $\mathtt{Rev}\from S \to S$,
  \item $\mathtt{Encap}\from S \to  S$ and
  \item $\mathtt{Unencap}\from S\times S\times Q^Q \to S \times Q^Q$
\end{itemize}
verifying the following conditions:
\begin{enumerate}
  \item $\mathtt{Rev}\circ\mathtt{Rev}=1_S$,
  \item $\mathtt{In}\circ\mathtt{Rev}= \mathtt{Out}$ and 
        $\mathtt{Out}\circ\mathtt{Rev}= \mathtt{In}$\label{in_out_rev},
  \item $\mathtt{In}\circ\mathtt{New} =1_{\mathcal{P}_f(\mathcal{Q})}$,
  \item $\mathtt{In}\circ \mathtt{Encap} =\mathtt{In}$ and $\mathtt{Out}\circ \mathtt{Encap} =\mathtt{Out}$,
  \item $\mathtt{In}\circ\pi_1\circ\mathtt{Unencap}=\mathtt{In}\circ\pi_1$,\label{Unencap_In}
  \item if $\mathtt{Unencap} (C,D,\binding)=(C',\binding')$ then $b$ and $b'$ are bijective and\label{Unencap_cond}
    \begin{enumerate}
      \item $\binding[\mathtt{In}(D)]\subseteq \mathtt{Out} (C)$,\label{Unencap_cond_1}
      \item $\binding'[\mathtt{Out}(D)]\subseteq\mathtt{Out}(C')$ and\label{Unencap_cond_2}
      \item $\mathtt{Out}(C')=\binding'(\mathtt{Out}(D)),(\mathtt{Out}(C)\setminus\binding^{-1}(\mathtt{In}(D)))$.\label{Unencap_cond_3}
    \end{enumerate}
\end{enumerate}
\end{definition}

If $\p{Q,S}$ is a circuit constructor, we call \emph{circuit states} 
the elements of $S$ and \emph{wire identifiers} the elements of $Q$. 

The functions that equip a constructor represent operations on 
circuits. The definition of circuit used by a particular 
constructor needn't be specified here. However, it can be helpful 
to keep in mind the usual representation of quantum circuits when 
thinking about constructors. For example, one can think of 
$\mathtt{New}(q_1,q_2,q_3)$ as the circuit given in 
figure~\hyperref[rep_new]{\ref*{rep_new}}.

\begin{figure}[!ht]
\[
\mbox{
\Qcircuit @C=1em @R=2.7em {
& \qw & \ustick{q_1} \qw & \qw & \qw \\
& \qw & \ustick{q_2} \qw & \qw & \qw \\
& \qw & \ustick{q_3} \qw & \qw & \qw 
}
}
\]
\caption{A representation of $\mathtt{New}\s{q_1,q_2,q_3}$.}
\label{rep_new}
\end{figure}

The $\mathtt{Unencap}$ function can similarly be explained in terms of 
the usual graphical language for circuits. It inputs two circuit states, 
say $C$ and $D$, together with a map $\binding\from Q\to Q$ and returns 
a new circuit $C'$ together with a new map $\binding'$. The state $C'$ can be 
seen as the composition of $C$ and $D$ along $\binding$. An illustration of 
this is given in figure~\hyperref[rep_unencap]{\ref*{rep_unencap}}. 
The function $\binding$ is used to specify along which wires to compose $C$ 
and $D$ while the function $\binding'$ updates the wire names post composition.

\begin{figure}[!ht]
\[
\mbox{
\Qcircuit @C=.5em @R=2.7em {
& & & & & 
     & & & & & & \push{\binding} & & &
     & & & 
     & & & & & & \push{\binding'} & & & \\
&\qw &\ustick{q_1}\qw &\qw &\qw &\multigate{4}{~~~C~~~} 
     &\qw &\qw &\ustick{q_1}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_1'}\qw
     &\qw &\qw &\multigate{2}{~~~D~~~} 
     &\qw &\qw &\ustick{p_1}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{p_1'}\qw \\
&\qw &\ustick{q_2}\qw &\qw &\qw &\ghost{~~~C~~~}       
     &\qw &\qw &\ustick{q_2}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_2'}\qw
     &\qw &\qw &\ghost{~~~D~~~} 
     &\qw &\qw &\ustick{p_2}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{p_2'}\qw \\     
&\qw &\ustick{q_3}\qw &\qw &\qw &\ghost{~~~C~~~}        
     &\qw &\qw &\ustick{q_3}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_3'}\qw
     &\qw &\qw &\ghost{~~~D~~~} 
     &\qw &\qw &\ustick{p_3}\qw &\qw &\qw &\qw &\qw &\qw &\ustick{p_3'}\qw \\     
&\qw &\ustick{q_4}\qw &\qw &\qw &\ghost{~~~C~~~}       
     &\qw &\qw &\ustick{q_4}\qw &\qw &\qw &\qw &\qw &\qw &\qw
     &\qw &\qw &\qw 
     &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_4}\qw \\     
&\qw &\ustick{q_5}\qw &\qw &\qw &\ghost{~~~C~~~}     
     &\qw &\qw &\ustick{q_5}\qw &\qw &\qw &\qw &\qw &\qw &\qw
     &\qw &\qw &\qw 
     &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\qw &\ustick{q_5}\qw     
     \gategroup{2}{3}{6}{8}{3.3em}{--}
     \gategroup{2}{16}{4}{20}{3.3em}{--}     
     \gategroup{2}{23}{5}{24}{4.5em}{^\}}     
     \gategroup{2}{11}{5}{13}{4.5em}{^\}}     
}}
\]
\caption{A representation of $\mathtt{Unencap} (C,D,\binding)$.}
\label{rep_unencap}
\end{figure}

Note that a gate, is a (very basic) circuit.
The operation of appending a gate to a circuit is therefore subsumed 
by the more general operation of composing circuits. This is why no 
primitive gate-appending operations are specified. Of course, a 
``usable" circuit constructor would come equipped with circuit 
states for each element of some chosen universal gate set.

The function $\mathtt{Encap}$ stores a circuit for later use.
We also say that it \emph{boxes} that circuit. The remaining functions 
are relatively straightforward. The function $\mathtt{In}$ 
(resp. $\mathtt{Out}$) returns the identifiers of the input 
(resp. output) wires of a circuit, while $\mathtt{Rev}$ reverses 
a circuit. 

Proto-Quipper's quantum addresses and circuit constants are supposed 
to be the syntactic representatives of a circuit constructor's wire 
identifiers. This idea is formalized in the following definition.

\begin{definition}
A circuit constructor $\atuple{Q,S}$ is \emph{adequate} if it can 
be equipped with bijections $\mathtt{Address}\from \mathcal{Q} \to Q$ 
and $\mathtt{Name}\from \mathcal{C} \to S$ such that:
\[In=\mathtt{Address}' \circ\mathtt{In}\circ \mathtt{Name} 
~\mbox{ and }~ 
Out=\mathtt{Address}'\circ\mathtt{Out}\circ \mathtt{Name}
\]
where $\mathtt{Address}'$ denotes the lifting of $\mathtt{Address}^{-1}$ 
from $\mathcal{Q}$ to $\mathcal{P}(\mathcal{Q})$.
\end{definition}

\begin{remark}
\label{structure-transfer}
The existence of the bijections $\mathtt{Address}$ and $\mathtt{Name}$ has 
the following consequences:
\begin{itemize}
  \item $\mathcal{C}$ can be equipped with an involution:
\[
(.)^{-1} = \mathtt{Name}\circ \mathtt{rev} \circ \mathtt{Name}^{-1}
           \from \mathcal{C}\to\mathcal{C}
\]
such that $In(C^{-1})=Out(C)$ and 
$Out(C^{-1})=In(C)$.
  \item If $\binding$ is a binding obtained from QData terms $t,u$ in the 
  way described in Remark~\hyperref[bind_extension]{\ref*{bind_extension}}, 
  we can use it to define the following map (which we call by the same name):
  \[
  \binding = \mathtt{Address}\circ \binding\circ \mathtt{Address}^{-1}\from Q\to Q
  \]
\end{itemize}

From now on, we always assume an adequate circuit constructor. Moreover, we work 
under the simplifying assumptions that $\mathcal{Q}=Q$, $\mathtt{Address}=1_Q$ 
and $\mathtt{Encap}=1_Q$.
\end{remark}


\subsection{Operational Semantics}

We are now in a position to define Proto-Quipper's operational 
semantics.

\begin{definition}
Let $\atuple{Q,S}$ be an adequate circuit constructor. A 
\emph{closure} is a pair $[C,a]$ where $C\in S$, $a$ is a 
term and $FQ(t)\subseteq\mathtt{Out}(C)$. 
\end{definition}

% We require $FQ(t)\subseteq\mathtt{Out}(C)$ and not $FQ(t)=\mathtt{Out}(C)$
% because the reduction is defined by induction on the terms. For
% example, to reduce a pair, one must first reduce the left component
% in the context of the current circuit. If we required an equality 
% we couldn't simply do this.

\begin{definition}
The \emph{one-step reduction relation}, written $\to$, is defined 
on closures by the rules given in tables~\hyperref[cong_rules]{\ref*{cong_rules}}, 
\hyperref[classical_rules]{\ref*{classical_rules}} 
and \hyperref[circ_gen_rules]{\ref*{circ_gen_rules}}. 
In the $(box)$ rule, the $C,v$ in $\spec_{C,v}$ stands for $In(C),Out(C),FQ(v)$.
The \emph{reduction relation}, 
written $\to^*$, is defined to be the reflexive and transitive closure of $\to$.
\end{definition}

\begin{figure}[!ht]
\begin{mdframed}
\[
  \infer[(fun)]{[C,ab]\to[C',a'b]}{
    [C,a]\to[C',a']
  }
~~~~~~
  \infer[(arg)]{[C,vb]\to [C',vb']}{
    [C,b]\to [C',b']
  }
\]
\[
  \infer[(right)]{[C,\langle a,b\rangle]\to [C',\langle a,b'\rangle]}{
    [C,b]\to [C',b']
  }
~~~~~~
  \infer[(left)]{[C,\langle a,v\rangle]\to [C',\langle a',v\rangle]}{
    [C,a]\to [C',a']
  }
\]
\[
  \infer[(let)]{[C,\letin{\p{x,y}}{a}{b}]\to 
                [C', \letin{\p{x,y}}{a'}{b}]}{
    [C,a]\to [C',a']
  }
\]
\[
  \infer[(cond)]{[C, \ifthenelse{a}{b}{c}]\to [C', \ifthenelse{a'}{b}{c}]}{
    [C,a]\to [C',a']
  }
\]
\[
  \infer[(circ)]{[C, (t,D,a)]\to [C, (t,D',a')]}{
    [D,a]\to [D',a']
  }
\]
\end{mdframed}
\caption{The congruence rules.}
\label{cong_rules}
\end{figure}

\begin{figure}[!ht]
\begin{mdframed}
\[
  \infer[(\beta)]{[C,(\lambda x.a)v]\to [C, a[v/x]]}{}
\]
\[
  \infer[(pair)]{[C,\letin{\p{x,y}}{\p{v,w}}{a}]\to[C,a[v/x,w/y]]}{}
\]
\[
  \infer[(if\mbox{-}\mathtt{F})]{[C,\ifthenelse{\mathtt{False}}{a}{b}] \to [C, b]}{}
\]
\[
  \infer[(if\mbox{-}\mathtt{T})]{[C,\ifthenelse{\mathtt{True}}{a}{b}] \to [C, a]}{}
\]
\end{mdframed}
\caption{The classical rules.}
\label{classical_rules}
\end{figure}

\begin{figure}[!ht]
\begin{mdframed}
\[
  \infer[(box)]{[C,box^T(v)]\to [C,(t,D,a)]}{
    \spec_{C,v}(T)=t
    &
    [\mathtt{new}(FQ(t)), vt] \to [D,a]
  }
\]
\[
  \infer[(unbox)]{[C,(unbox~(u,D,u'))v]\to [C',\binding'(u')]}{
    bind(v,u)=\binding 
    &
    \mathtt{Unencap}(C,D,\binding) = (C',\binding') 
  }
\]
\[
  \infer[(rev)]{[C,rev (t,C,t')]\to [C,(t',C^{-1},t)]}{}
\]
\end{mdframed}
\caption{The circuit generating rules.}
\label{circ_gen_rules}
\end{figure}

The classical reduction rules and the congruence rules (minus $(circ)$) 
are standard. They describe the usual call-by-value reduction strategy. 
The $(rev)$ rule is straightforward. We briefly discuss the remaining 
rules. The $(box)$ rule is to be understood as follows. Start by 
generating a specimen of type $T$. Then apply the function $v$ on the 
input $t$ in the context of an empty circuit of the appropriate arity. 
Note that while this computation is taking place, the state $C$ is not 
accessible. By the $(circ)$ congruence rule, this computation will 
continue until a value is reached, i.e., a term of the form $(t,D,t')$. 
At this point, the construction of $C$ can resume. Remark that it was 
necessary to know the type $T$ in order to generate the appropriate 
specimen. This explains the choice of a Church-style typing of the 
language. The $(unbox)$ rule will first generate a binding from $v$ 
and the input $u$ of $D$. Then, it will compose $C$ and $D$ along that 
binding and update the names of the wire identifiers appearing in $u'$ 
according to $\binding'$.

The inductive nature of the reduction rule explains why closures are 
not required to satisfy $FQ(a)=\mathtt{Out}(C)$. The requirement that 
$FQ(a)\subseteq \mathtt{Out}(C)$ is justified by the idea that a term 
should not affect a wire outside of $C$. But if we also asked for the 
opposite inclusion, it wouldn't be possible to define an inductive 
reduction in a straightforward way. For example, the reduction of a 
pair is done component-wise: to reduce $\p{a,b}$ one first reduces $b$. 
The simplest way to express this in terms of closures is to carry the 
whole circuit state along. This implies that if both $a$ and $b$ 
contain wire identifiers, then the equality $FQ(a)=\mathtt{Out}(C)$ 
cannot be satisfied.

Proto-Quipper's reduction is non-probabilistic, in the sense that the 
right member of any reduction rule is a unique closure. The following 
proposition establishes that Proto-Quipper's reduction is moreover  
\emph{deterministic}.

\begin{proposition}
\label{determinicity}
If $[C,a]$ is a closure, then at most one reduction rule applies
to it.
\end{proposition}

\begin{proof}
By case distinction on $a$.
\end{proof}


\section{Type Safety}

In this section, we establish that the core of  Proto-Quipper 
is a \emph{type safe} language. We follow \cite{WrFe94} in 
considering that a language is type safe if it enjoys the 
following two properties: 
\begin{description}
  \item[Subject Reduction:] This property guarantees 
  that the type of a term is stable under reduction.
  As a corollary, it also shows that if a term is 
  well-typed, then it never reduces to an ill-typed 
  term.
  \item[Progress:] This property shows that a 
  well-typed term never reaches an ``error state", 
  which is defined to be a closure $[C,t]$ to which 
  no reduction rule applies but such that 
  $t\notin \mathtt{Val}$. 
\end{description}
Note that the reduction relation is defined on closures 
but the typing rules apply to terms. We therefore extend 
the notions of typing judgement and validity to closures.

\begin{definition}
A \emph{typed closure} is an expression of the form:
\[
\Gamma;Q\entails [C,a]:A,(Q'|Q'')
\]
where $\mathtt{In}(C)=Q'$ and $\mathtt{Out}(C)=Q,Q''$. 
It is \emph{valid} if $\Gamma;Q\entails a:A$ is a valid 
typing judgement.
\end{definition}

\subsection{Properties of the Type System}

Before proving Subject Reduction and Progress, we record 
some properties of the type system, including the important 
\emph{Substitution Lemma}. Note that the typing rules 
enforce a \emph{strict} linearity on variables and quantum 
addresses. In particular, if a quantum address appears in 
the quantum context of a valid typing judgement for a term 
$a$, then it must belong to the quantum addresses of $a$.

\begin{lemma}~
\label{prop_type_syst}
\begin{enumerate}
  \item If $\Gamma; Q \entails a:A$ is valid, 
  then $Q=FQ(a)$.\label{q_context}
  \item If $\Gamma,x:B;Q \entails a:A$ is valid, 
  and $x\notin FV(a)$, then $\Gamma;Q \entails a:A$ is valid.\label{unused_var}
  \item If $\Gamma; Q \entails a:A$ is valid, 
  then $\Gamma, !\Delta ; Q \entails a:A$ is valid.\label{weakening}
  \item If $\Gamma ; Q \entails a:A$ is valid, $\Delta <: \Gamma$
  and $A<:B$, then $\Delta ; Q \entails a:B$ is valid.\label{subtype}
\end{enumerate}
\end{lemma}

\begin{proof}
By induction on the corresponding typing derivation.
\end{proof}

\begin{lemma}
\label{specimen}
If $T$ is a QData type and $X\subset \mathcal{Q}$, then 
$FQ(t)\entails \spec_X(T):T$ is valid.
\end{lemma}

\begin{proof}
We prove the Lemma by induction on $T$.
  \begin{itemize}
    \item If $T=1$, then $\spec_X(T)=*$ and we can use the $(unit)$ rule.
    \item If $T=qubit$, then $\spec_X(T)=q$ for some quantum address $q$ and we can 
          use the $(ax_q)$ rule.
    \item If $T=T_1\x T_2$, then $\spec_X(T)=\p{t_1,t_2}$ where $t_1=\spec_X(T_1)$ 
          and $u=\spec_{X\cup FQ(t_1)}(T_2)$. By the induction hypothesis, both 
          $FQ(t_1)\entails t_1:T_1$ and $FQ(t_2)\entails t_2:T_2$ are valid typing 
          judgements. We can therefore conclude by applying the $(\tensor\mbox{-i})$ rule.
  \end{itemize}
\end{proof}

\begin{lemma}
\label{binding_judgement}
If $\Gamma;Q \entails a:A$ is valid and $\mathfrak{b}$ is a 
binding, then $\Gamma;\binding (Q) \entails \binding(a):A$ is valid.
\end{lemma}

\begin{proof}
By induction on the typing derivation of $\Gamma;Q \entails a:A$.
\end{proof}

\begin{lemma}
\label{context_value}
If $v\in\mathtt{Val}$ and $\Gamma,!\Delta;Q \entails v:!A$ is valid, 
then $\Gamma=Q=\varnothing$.
\end{lemma}

\begin{proof}
By induction on the typing derivation of $\Gamma,!\Delta;Q \entails v:!A$. 
In the case of $(ax_c)$, use Lemma~\hyperref[subtype_bang]{\ref*{subtyping_shape}.\ref*{subtype_bang}}.
\end{proof}

\begin{lemma}
{\bf (Substitution).}
\label{substitution}
If $v\in\mathtt{Val}$ and both $\Gamma',!\Delta;Q' \entails v:B$ and 
$\Gamma,!\Delta,x:B;Q \entails a:A$ are valid typing judgements, 
then $\Gamma,\Gamma',!\Delta;Q,Q' \entails a[v/x]:A$ is also valid.
\end{lemma}

\begin{proof}
Let $\pi_1$ and $\pi_2$ be the typing derivations  of 
$\Gamma,!\Delta,x:B;Q \entails a:A$ and  $\Gamma',!\Delta;Q' \entails v:B$ 
respectively. We prove the Lemma by induction on $\pi_1$.
\begin{itemize}
 \item If the last rule of $\pi_1$ is $(ax_c)$ and $a=x$, then $\pi_1$ is
 \[
   \infer[(ax_c)]{!\Delta, x:B;\varnothing\entails x:A}{
     B<:A
   }
 \]
 with $\Gamma=Q=\varnothing$. Then $a[v/x]=v$ and can conclude by applying 
 Lemma~\hyperref[subtype]{\ref*{prop_type_syst}.\ref*{subtype}} to $\pi_2$.
 \item If the last rule of $\pi_1$ is $(ax_c)$ and $a=y\neq x$, then 
 $\pi_1$ is
 \[
   \infer[(ax_c)]{!\Delta, x:!B',y:A';\varnothing\entails y:A}{
     A'<:A
   }
 \]
 with $B=!B'$, $Q=\varnothing$ and $\Gamma =\s{y:A'}$ or $\Gamma=\varnothing$ 
 depending on whether or not $A'$ is duplicable. Therefore $v$ is a value of 
 type $!B'$ and by Lemma~\hyperref[context_value]{\ref*{context_value}}, 
 we know that $\Gamma'=Q'=\varnothing$. Since $a[v/x]=y$ and $x\notin FV(y)$ 
 we can conclude by applying
 Lemma~\hyperref[unused_var]{\ref*{prop_type_syst}.\ref*{unused_var}} to $\pi_1$.
 \item If the last rule of $\pi_1$ is one of $(ax_q)$, $(cst_c)$, 
 $(unit)$, $(\top)$ and $(\bot)$, and $a$ is the corresponding constant, 
 then $x\notin FV(a)$ and  $x$ must be declared of some type $!B'$.
 We can therefore reason as in the previous case. 
 \item If the last rule of $\pi_1$ is $(\lambda_1)$ and $a=\lambda y.b$, then $\pi_1$ is
  \[
   \infer[(\lambda_1)]{\Gamma,!\Delta,x:B;Q\entails \lambda y.b:A_1\loli A_2}{
     \deduce[]{\Gamma, !\Delta,x:B,y:A_1;Q \entails b:A_2}{
       \vdots
     }
   }
 \]
 with $A=A_1\loli A_2$. By the induction hypothesis, 
 $\Gamma, \Gamma',!\Delta,y:A_1;Q,Q' \entails b[v/x]:A_2$ is valid and we can conclude
 by applying $(\lambda_1)$.
 \item If the last rule of $\pi_1$ is $(\lambda_2)$ and $a=\lambda y.b$, 
 then $\pi_1$ is
 \[
  \infer[(\lambda_2)]{!\Delta, x:!B';\varnothing \entails \lambda y.b:~!^{n+1}(A_1\loli A_2)}{
    \deduce[]{!\Delta, x:!B',y:A_1;\varnothing \entails b:A_2}{
      \vdots
    }
  }
 \]
 with $A=!^{n+1}(A_1\loli A_2)$ and $B=!B'$. Hence $v$ is a value of type $!B'$ and  
 by Lemma~\hyperref[context_value]{\ref*{context_value}}, we know that
 $\Gamma'=Q'=\varnothing$. The induction hypothesis therefore implies that
 $!\Delta,y:A_1;\varnothing \entails b[v/x]:A_2$ is valid and we can conclude
 by applying $(\lambda_2)$.
 \item If the last rule of $\pi_1$ is $(app)$, and $a=ca'$, then $\pi_1$ can 
 be of one of three forms depending on $B$. If $B$ is duplicable, then $\pi_1$ is
 \[
 \infer[(app)]{\Gamma_1,\Gamma_2,!\Delta,x:!B';Q_1,Q_2\entails ca':A}{
    \deduce[]{\Gamma_1, x:!B',!\Delta;Q_1\entails c:A'\loli A}{
      \vdots
    }
    &
    \deduce[]{\Gamma_2, x:!B',!\Delta ;Q_2\entails a':A' }{
      \vdots
    }
 }
 \]
 with $B=!B'$. Using 
 Lemma~\hyperref[context_value]{\ref*{context_value}} again, we 
 know that $\Gamma'=Q'=\varnothing$. The induction hypothesis therefore 
 implies that $\Gamma_1,!\Delta;Q_1\entails c[v/x]:A'\loli A$ and 
 $\Gamma_2,!\Delta ;Q_2\entails a'[v/x]:A'$ are valid and we can conclude 
 by applying $(app)$. If, instead, $B$ is non-duplicable, then the declaration 
 $x:B$ can only appear in one branch of the derivation. This means that $\pi_1$ 
 is either 
  \[
 \infer[(app)]{\Gamma_1,\Gamma_2,!\Delta,x:B;Q_1,Q_2\entails ca':A}{
    \deduce[]{\Gamma_1, x:B,!\Delta;Q_1\entails c:A'\loli A}{
      \vdots
    }
    &
    \deduce[]{\Gamma_2, !\Delta ;Q_2\entails a':A'}{
      \vdots
    }     
 }
 \]
 or
  \[
 \infer[(app).]{\Gamma_1,\Gamma_2,!\Delta,x:B;Q_1,Q_2\entails ca':A}{
    \deduce[]{\Gamma_1, !\Delta;Q_1\entails c:A'\loli A}{ 
      \vdots
    }
    &
    \deduce[]{\Gamma_2, x:B,!\Delta ;Q_2\entails a':A'}{
      \vdots
    }     
 }
 \]
 In the first case, the induction hypothesis implies that 
 $\Gamma_1,\Gamma' !\Delta;Q_1,Q'\entails c[v/x]:A'\loli A$ is valid and 
 we can conclude by $(app)$. The second case is treated analogously.
 \item If the last rule of $\pi_1$ is on of $(\x\mbox{-i})$, $(\x\mbox{-e})$ 
 and $(if)$, and $a$ is the corresponding term, then we can reason as above
 by considering in turn the case where $B$ is duplicable and the case where
 $B$ is non-duplicable.
 \item If the last rule of $\pi_1$ is $(circ)$, and $a=(t,C,a')$, then 
 $\pi_1$ is
 \[
 \infer[(circ)]{!\Delta,x:!B';\varnothing \entails (t,\mathbf{c},a'):!^nCirc(T,U)}{
    \deduce[]{Q_1\entails t:T}{
      \vdots
    }    
    &
    \deduce[]{!\Delta,x:!B' ; Q_2\entails a':U}{
      \vdots
    }     
    &
    In(C)=Q_1 
    &
    Out(C)=Q_2
 }
 \]
 with $A=!^nCirc(T,U)$ and $B=!B'$ for some types $T$, $U$ and $B'$. Using  
 Lemma~\hyperref[context_value]{\ref*{context_value}} again, we know 
 that $\Gamma'=Q'=\varnothing$. The induction hypothesis therefore implies that
 $!\Gamma; Q_2\entails a'[v/x]:U$ is valid and we can conclude
 by applying $(circ)$.
\end{itemize}
\end{proof}


\subsection{Subject Reduction}

\begin{lemma}
\label{Inwires}
If $[C,a]\to[C',a']$ then $\mathtt{In}(C)=\mathtt{In}(C')$.
\end{lemma}

\begin{proof}
By case distinction on the rule used in the reduction $[C,a]\to[C',a']$. 
In all but the $(unbox)$ case, the result follows either from the induction 
hypothesis or from the fact that $C=C'$. In the $(unbox)$ case, use 
Definition~\hyperref[Unencap_In]{\ref*{circuit_constructor}.\ref*{Unencap_In}}.
\end{proof}

\begin{proposition}
\label{subject_red_one_step}
If $\Gamma;FQ(a)\entails [C,a]:A,(Q'|Q'')$ is valid typed closure 
and $[C,a]\to [C',a']$, then $\Gamma;FQ(a')\entails [C',a']:A,(Q'|Q'')$ is 
a valid typed closure.
\end{proposition}

\begin{proof}
We prove the proposition by induction on the derivation of the reduction 
 $[C,a]\to[C',a']$. In each case, we start by reconstructing 
the unique typing derivation $\pi$ of $\Gamma;FQ(a)\entails a:A$ and we use 
it to prove that $\Gamma;FQ(a')\entails [C',a']:A,(Q'|Q'')$ is valid. 
By Lemma~\hyperref[Inwires]{\ref*{Inwires}} we never need to 
verify that $\mathtt{In}(C')=Q'$ so that in each case we only 
need to show:
\begin{itemize}
  \item $\mathtt{Out}(C')=FQ(a'),Q''$ and
  \item $\Gamma;FQ(a')\entails a':A$ is valid.
\end{itemize}
Throughout the proof, we write $IH(\pi)$ to denote the proof obtained by applying 
the induction hypothesis to $\pi$.

\begin{description}
\item[Congruence rules:] These rules are treated uniformly. We illustrate the 
$(fun)$ and $(circ)$ cases.
\begin{itemize}
  \item $(fun)$: the reduction rule is
  \[
    \infer[]{[C,cb]\to[C',c'b]}{
      [C,c]\to[C',c']
    }
  \]
  with $a=cb$ and $a'=c'b$. The typing derivation $\pi$ is therefore
  \[
    \infer[]{\Gamma_1,\Gamma_2, !\Delta;FQ(c),FQ(b)\entails cb:A}{
      \deduce[]{\Gamma_1, !\Delta;FQ(c)\entails c:B\loli A}{
        \vdots~\pi_1
      } 
      &
      \deduce[]{\Gamma_2, !\Delta ;FQ(b)\entails b:B}{
        \vdots~\pi_2
      } 
    }
  \]
  and $\Gamma_1,\Gamma_2;FQ(c),FQ(b)\entails [C, cb],(Q'|Q'')$ is valid.
  It follows that $\Gamma_1, !\Delta;FQ(c)\entails [C,c]:B\loli A,(Q'|FQ(b),Q'')$ 
  is valid and, by the induction hypothesis, this implies that 
  $\Gamma_1, !\Delta;FQ(c')\entails [C',c']:B\loli A,(Q'|FQ(b),Q'')$ is also valid.
  In particular, it follows that $\mathtt{Out}(C')=FQ(c'),FQ(b),Q''$. This, 
  together with the following typing derivation,
  \[
    \infer[]{\Gamma_1,\Gamma_2, !\Delta;FQ(c'),FQ(b)\entails c'b:A}{
      \deduce[]{\Gamma_1, !\Delta;FQ(c')\entails c':B\loli A}{
        \vdots~IH(\pi_1)
      } 
      &
      \deduce[]{\Gamma_2, !\Delta ;FQ(b)\entails b:B}{
        \vdots~\pi_2
      } 
    }
  \]  
  shows that $\Gamma_1,\Gamma_2, !\Delta;FQ(c'),FQ(b)\entails c'b:A,(Q',Q'')$ 
  is valid.
  \item $(circ)$: the reduction rule is
  \[
    \infer[(circ)]{[C, (t,D,b)]\to [C, (t,D',b')]}{
      [D,b]\to [D',b']
    }
  \]  
  with $a=(t,D,b)$ and $a'=(t,D',b')$. The typing derivation $\pi$ is therefore
  \[
  \infer[]{!\Delta;\varnothing\entails (t,D,b):!^nCirc(T,U)}{
    \deduce[]{FQ(t)\entails t:T}{
      \vdots~\pi_1
    } 
    &
    \deduce[]{!\Delta ; FQ(b)\entails b:U}{
      \vdots~\pi_2
    }
    &
    \deduce[]{In(D)=FQ(t)}{
      Out(D)=FQ(b)
    }
  }
  \]  
  and $!\Delta ; \varnothing \entails [C,(t,D,b)]:!^nCirc(T,U),(Q'|Q'')$ is valid. 
  Disregarding $\pi_1$, it follows from the assumptions in the above rule 
  that $!\Delta ; FQ(b)\entails [D,b]:U, (FQ(t)|\varnothing)$ is valid and, 
  by the induction hypothesis, this implies that 
  $!\Delta,FQ(b')\entails [D',b']:U,(FQ(t)|\varnothing)$ is also valid.
  This, together with the following typing derivation,
  \[
  \infer[.]{!\Delta;\varnothing\entails (t,D,b'):!^nCirc(T,U)}{
    \deduce[]{FQ(t)\entails t:T}{
      \vdots~\pi_1
    } 
    &
    \deduce[]{!\Delta ; FQ(b')\entails b':U}{
      \vdots~IH(\pi_2)
    }
    &
    \deduce[]{In(D')=FQ(t)}{
      Out(D')=FQ(b')
    }
  }  
  \]
  shows that $!\Delta;\varnothing\entails [C,(t,D',b')] :!^nCirc(T,U),(Q'|Q'')$ 
  is valid.
\end{itemize}
\item[Classical rules:] These rules are also treated uniformly, we illustrate 
the $(\beta)$ case.
\begin{itemize}
  \item $(\beta)$: the reduction rule is
  \[
    \infer[(\beta)]{[C,(\lambda x.b)v]\to [C, b[v/x]]}{}
  \]  
  with $a=(\lambda x.b)v$ and $a'=b[v/x]$. The typing derivation $\pi$ is 
  therefore
  \[
    \infer[]{\Gamma_1,\Gamma_2,!\Delta;FQ(b),FQ(v)\entails (\lambda x.b)v:A}{
      \infer[]{\Gamma_1,!\Delta;FQ(b)\entails \lambda x.b:B\loli A}{
        \deduce[]{\Gamma_1,!\Delta,x:B;FQ(b) \entails b:A}{
          \vdots~\pi_1
        }
      }
      &
      \deduce[]{\Gamma_2,!\Delta;FQ(v)\entails v:B}{
        \vdots~\pi_2
      }      
    }
  \]  
  and $\Gamma_1,\Gamma_2,!\Delta;FQ(b),FQ(v)\entails (\lambda x.b)v:A,(Q'|Q'')$ 
  is valid. By Lemma \hyperref[substitution]{\ref*{substitution}}, we know that
  $\Gamma_1,\Gamma_2,!\Delta;FQ(b),FQ(v)\entails b[v/x]:A$ is a valid typing 
  judgement which implies that 
  $\Gamma_1,\Gamma_2,!\Delta;FQ(b),FQ(v)\entails [C,b[v/x]]:A,(Q'|Q'')$ is a valid
  typed closure.
\end{itemize}
\item[Circuit generating rules:] These rules represent the most interesting cases. 
We treat them individually.
\begin{itemize}
  \item $(box)$: the reduction rule is
  \[
  \infer[]{[C,box^T(v)]\to [C,(t,D,b)]}{
    \spec(T)=t
    &
    [\mathtt{new}(FQ(t)), vt] \to [D,b]
  }
  \]
  with $a=box^T(v)$ and $a'=(t,D,b)$. Since $v$ is a value, we know by  
  Lemma~\hyperref[context_value]{\ref*{context_value}} that the typing 
  derivation $\pi$ is
  \[
  \infer[]{!\Delta;\varnothing\entails box^T(v):!^nCirc(T,U)}{
    \infer[]{!\Delta;\varnothing \entails box^T:!(T\loli U)\loli !^nCirc(T,U)}{
    }   
    &
    \deduce[]{!\Delta ;\varnothing\entails v:!(T\loli U)}{
     \vdots ~\pi_1
    }
  }
  \]
  and $!\Delta;\varnothing\entails box^T(v):!^nCirc(T,U),(Q'|Q'')$ is valid.
  By Lemma~\hyperref[specimen]{\ref*{specimen}}, there exists 
  a typing derivation $\pi_2$ of $FQ(t)\entails t:T$ and applying 
  Lemma~\hyperref[weakening]{\ref*{prop_type_syst}.\ref*{weakening}} yields a typing 
  derivation $\pi_2'$ of $!\Delta;FQ(t)\entails t:T$. 
  Applying Lemma~\hyperref[subtype]{\ref*{prop_type_syst}.\ref*{subtype}}
  to $\pi_1$ we get a derivation $\pi_1'$ of $!\Delta ;\varnothing\entails v:T\loli U$.
  We can therefore construct the following derivation:
  \[
  \infer[]{!\Delta;FQ(t)\entails vt : U}{
    \deduce[]{!\Delta ;\varnothing\entails v:T\loli U}{
      \vdots ~\pi_1'
    }
    &
    \deduce[]{!\Delta;FQ(t)\entails t:T}{
      \vdots ~\pi_2'
    }
  }
  \]
  Moreover, $FQ(t)=\mathtt{Out}(\mathtt{New}(FQ(t)))=\mathtt{In}(\mathtt{New}(FQ(t)))$. 
  It therefore follows that $!\Delta;FQ(t)\entails [\mathtt{New}(FQ(t)),vt]:U,(FQ(t)|\varnothing)$ 
  is a valid typed closure. By the induction hypothesis, this implies that 
  $!\Delta;FQ(b)\entails [D,b]:U,(FQ(t)|\varnothing)$ is also valid.
  In particular, this means that $\mathtt{In}(D)=FQ(t)$, $\mathtt{Out}(D)=FQ(b)$ 
  and that there exists a typing derivation $\pi_3$ of $!\Delta;FQ(b)\entails b:U$.
  We can therefore construct the following typing derivation:
  \[
  \infer[.]{!\Delta;\varnothing \entails (t,D,b):!^nCirc(T,U)}{
    \deduce[]{FQ(t)\entails t:T}{
      \vdots~\pi_2
    }
    &
    \deduce[]{!\Delta ; FQ(b)\entails b:U}{
      \vdots~\pi_3
    } 
    &
    \deduce[]{In(D)=FQ(t) }{
      Out(D)=FQ(b)
    }
  }
  \]  
  Hence $!\Delta ;\varnothing \entails (t,D,b):!^nCirc(T,U) (Q'|Q'')$ is valid.
  \item $(unbox)$ the reduction rule is
  \[
    \infer[(unbox)]{[C,(unbox~(t,D,t'))v]\to [C',\binding'(t')]}{
      bind(v,t)=\binding 
      &
      \mathtt{Unencap}(C,D,\binding) = (C',\binding') 
    }
  \]
  with $a=(unbox~(t,D,t'))v$ and $a'=\binding'(t')$. Since $v$ is a value of 
  QData type, we know by 
  Lemma~\hyperref[context_value]{\ref*{context_value}}
  that the typing derivation $\pi$ is 
  \begin{changemargin}{-4cm}{-2.3cm}
  \[
  \infer[]{!\Delta; FQ(v)\entails (unbox~(t,D,t'))v :U}{
    \infer[]{!\Delta;\varnothing\entails unbox(t,D,t'):T\loli U}{
      \infer[]{!\Delta;\varnothing \entails unbox:Circ(T,U)\loli (T\loli U)}{
      }   
      &
      \infer[]{!\Delta ;\varnothing\entails (t,D,t'):Circ(T,U)}{
        \deduce[]{FQ(t)\entails t:T}{
          \vdots ~\pi_1
        }
        &
        \deduce[]{!\Delta;FQ(t')\entails t':U}{
          \vdots ~\pi_2     
        }
        &
        \deduce[]{In(D)=FQ(t)}{
          Out(D)=FQ(t')
        }
      }
    }
    &
    \infer[]{!\Delta ; FQ(v)\entails v:T}{
      \vdots~\pi_3
    }
  }
  \]
  \end{changemargin}
  and $!\Delta; FQ(v)\entails (unbox~(t,D,t'))v :U,(Q'|Q'')$ 
  is valid. By applying
  Lemma~\hyperref[binding_judgement]{\ref*{binding_judgement}} 
  to $\pi_2$ we get a typing derivation $\pi_2'$ of 
  $!\Delta;FQ(\binding(t'))\entails \binding(t'):U$.
  Now note that by 
  Definition~\hyperref[Unencap_cond_3]{\ref*{circuit_constructor}.\ref*{Unencap_cond_3}} 
  we have:
  \[
  \begin{array}{rcl}
  \mathtt{Out}(C') & = & \binding(\mathtt{Out}(D)), (\mathtt{Out}(C)\setminus\binding^{-1}(\mathtt{In}(D))) \\
                   & = & \binding(FQ(t')) , ((Q'',FQ(v))\setminus \binding^{-1}(FQ(t))) \\
                   & = & FQ(\binding(t')) , ((Q'',FQ(v))\setminus FQ(v)) \\
                   & = & FQ(\binding(t')),Q''.                   
  \end{array}
  \]
  Hence $!\Delta; FQ(\binding(t'))\entails \binding(t') :U,(Q'|Q'')$  is valid.
  \item $(rev)$ the reduction rule is
  \[
    \infer[(rev)]{[C,rev (t,D,t')]\to [C,(t',D^{-1},t)]}{}
  \]
  with $a=rev(t,D,t')$ and $a'=(t',D^{-1},t)$. The typing derivation $\pi$ 
  is therefore
  \begin{changemargin}{-2.7cm}{-1.6cm}
  \[
  \infer[]{!\Delta;\varnothing\entails rev(t,D,t'):!^nCirc(U,T)}{
    \infer[]{!\Delta;\varnothing \entails rev:Circ(T,U)\loli !^nCirc(U,T)}{
    }   
    &
    \infer[]{!\Delta ;\varnothing\entails (t,D,t'):Circ(T,U)}{
      \deduce[]{FQ(t)\entails t:T}{
        \vdots ~\pi_1
      }
      &
      \deduce[]{!\Delta;FQ(t')\entails t':U}{
        \vdots ~\pi_2     
      }
      &
      \deduce[]{In(D)=FQ(t)}{
        Out(D)=FQ(t')
      }
    }
  }
  \]
  \end{changemargin}
  and $!\Delta;\varnothing\entails rev(t,D,t'):!^nCirc(T,U),(Q'|Q'')$ is 
  valid. Now note that since $t'$ is a QData term, it contains no variables. 
  Applying Lemma~\hyperref[unused_var]{\ref*{prop_type_syst}.\ref*{unused_var}} 
  to $\pi_2$ repeatedly we therefore get a derivation $\pi_2'$ of 
  $FQ(t')\entails t':U$. Moreover, by applying
  Lemma~\hyperref[weakening]{\ref*{prop_type_syst}.\ref*{weakening}} to $\pi_1$ 
  we get a typing derivation $\pi_1'$ of $!\Delta ,FQ(t)\entails t:T$.
  Since, by 
  Remark~\hyperref[structure-transfer]{\ref*{structure-transfer}}, 
  we have $Out(D^{-1})=In(D)=t$ and $In(D^{-1})=Out(D)=t'$, we can construct 
  the following typing derivation:
  \[
  \infer[]{!\Delta ;\varnothing\entails (t',D^{-1},t):Circ(U,T)}{
    \deduce[]{FQ(t')\entails t':U}{
      \vdots ~\pi_2'
    }
    &
    \deduce[]{!\Delta;FQ(t)\entails t:T}{
      \vdots ~\pi_1'     
    }
    &
    \deduce[]{In(D^{-1})=FQ(t')}{
      Out(D^{-1})=FQ(t')
    }
  }  
  \]
  Hence $!\Delta;\varnothing\entails (t',D,t):!^nCirc(T,U),(Q'|Q'')$ 
  is valid.    
\end{itemize}
\end{description}
\end{proof}

\begin{corollary}
{\bf (Subject Reduction).}
If $\Gamma;FQ(a)\entails [C,a]:A,(Q'|Q'')$ is a valid typed closure 
and $[C,a]\to^* [C',a']$, then $\Gamma;FQ(a')\entails [C',a']:A,(Q'|Q'')$ 
is also a valid typed closure.
\end{corollary}

\begin{proof}
By induction on the length of the reduction sequence. The base case is 
provided by Lemma~~\hyperref[subject_red_one_step]{\ref*{subject_red_one_step}}
\end{proof}

This formulation of Subject Reduction explains why a typed closure contains 
information about the input and output wires of the circuit state. Indeed, 
Subject Reduction now guarantees (1) that the input wires of a circuit 
remain unchanged through reduction and (2) that a term can only affect 
wires whose identifiers are among its quantum addresses.

\subsection{Progress}

\begin{lemma}
\label{non_values}
If a term $a$ is not a value then it is of one 
of the following forms: $(t,C,a')$ with $a'\notin \mathtt{Val}$, 
$\p{a_1,a_2}$ with $a_1\notin \mathtt{Val}$ or $a_2\notin \mathtt{Val}$, 
$if ~a_1~ then ~a_2~ else ~a_3$, $let ~\atuple{x,y}=a_1~ in ~a_2$, $a_1a_2$.
\end{lemma}

\begin{lemma}
\label{form_values}
A well-typed value $v$ is either a variable, a quantum address, a constant or one 
of the following case occurs: if it is of type $!^nCirc(T,U)$, it is of the 
form $(t,C,u)$ with $t$ and $u$ values; if it is of type $!^nBool$ it is either 
$\true$ or $\false$; if it is of type $!^n (A\x B)$, it is of the
form $\p{w,w'}$, with $w$ and $w'$ values; if it is of type $!^n1$, it is 
precisely the term $*$; if it is of type $!^n (A\loli B)$, it is a 
lambda-abstraction or a constant.
\end{lemma}

\begin{proof}
By induction on the typing derivation of $v$.
\end{proof}

\begin{proposition}
{\bf (Progress).}
If $FQ(a)\entails [C,a]:A,(Q'|Q'')$ is a valid typed closure then either 
$a\in\mathtt{Val}$ or there exists a closure $[C',a']$ such that 
$[C,a]\to [C',a']$.
\end{proposition}

First, note that Progress is stated for a typed closure whose typing 
context is empty. This is because the Lemma no longer holds if we allow 
for a non-empty typing context. Indeed, consider the following counterexample:
\[
\infer[.]{x:!(!A\loli B), y:!A;\varnothing\entails xy:B}{
 \infer[]{x:!(!A\loli B);\varnothing\entails x:!A\loli B}{ 
 }
 &
 \infer[]{y:!A;\varnothing\entails y:A}{ 
 }
}
\]
We now prove the Proposition.

\begin{proof}
We prove the proposition by induction on the typing derivation $\pi$ of 
$FQ(a)\entails a:A$. If $a$ is a value then there is nothing 
to prove. If $a$ is not a value, then by 
Lemma~\hyperref[non_values]{\ref*{non_values}} there are 5 cases to consider. 
In each case we show that $[C,a]$ is reducible in the sense that there exists a 
closure  $[C,b]$ such that $[C,a]\to[C,b]$
\begin{enumerate}
  \item If $a=(t,D,a')$ with $a'\notin \mathtt{Val}$, then the typing derivation 
  $\pi$ is:
  \[
  \infer[.]{\varnothing\entails (t,D,a'):Circ(T,U)}{
    \deduce[]{FQ(t)\entails t:T}{
      \vdots ~\pi_1
    }
    &
    \deduce[]{FQ(a')\entails a':U}{
      \vdots ~\pi_2     
    }
    &
    \deduce[]{In(D)=FQ(t)}{
      Out(D)=FQ(a')
    }
  }   
  \]
  The typed closure 
  \[
  \begin{array}{rcl}
  FQ(a') & \entails & [D,a']:U,(FQ(t)|\varnothing)
  \end{array}
  \]
  is therefore valid. Since $a'$ 
  is not a value, the induction hypothesis implies that there exists $a''$ such 
  that $[D,a']\to [D',a'']$ and $[C,(t,D,a')]$ therefore reduces to 
  $[C,(t,D',a'')]$ by the $(circ)$ reduction rule.
  \item If $a=\p{a_1,a_2}$ with $a_1\notin \mathtt{Val}$ or $a_2\notin \mathtt{Val}$,
  then the typing derivation $\pi$ is:
  \[
  \infer[.]{FQ(a_1),FQ(a_2)\entails \p{a_1,a_2}:!^n(A_1\x A_2)}{
    \deduce[]{FQ(a_1)\entails a_1:!^nA_1}{
      \vdots~\pi_1
    }
    & 
    \deduce[]{FQ(a_2)\entails a_2:!^nA_2}{
      \vdots~\pi_2
    }
  }
  \] 
  The typed closures 
  \[
  \begin{array}{rcl}
  FQ(a_1) & \entails & [C,a_1]:!^nA_1,(Q'|FQ(a_2),Q'')\\
  FQ(a_2) & \entails & [C,a_2]:!^nA_1, (Q'|FQ(a_1),Q'')
  \end{array}
  \]
  are therefore both valid. 
  Now if $a_2\notin\mathtt{Val}$, then by the induction hypothesis 
  $[C,a_2]\to[C',a_2']$. Hence $[C,\p{a_1,a_2}]$ reduces to $[C',\p{a_1,a_2'}]$ 
  by the $(right)$ reduction rule.
  If on the other hand $a_2\in\mathtt{Val}$, then it must be the case that $a_1\notin\mathtt{Val}$ 
  and we can conclude by reasoning analogously that $[C,\p{a_1,a_2}]$ reduces to 
  some $[C',\p{a_1',a_2}]$ by the $(left)$ reduction rule.. 
  \item If $a=\ifthenelse{a_1}{a_2}{a_3}$, then the typing derivation $\pi$ is:
  \[
  \infer[.]{FQ(a_1),Q\entails \ifthenelse{a_1}{a_2}{a_3}:A}{
    \deduce[]{FQ(a_1)\entails a_1:Bool }{
      \vdots~\pi_1
    }
    &
    \deduce[]{Q \entails a_2:A}{
      \vdots~\pi_2
    }    
    &
    \deduce[]{Q \entails a_3:A}{
      \vdots~\pi_3
    }    
  }
  \]  
  The typed closure
  \[
  \begin{array}{rcl}
  FQ(a_1) & \entails & [C,a_1]:Bool,(Q'|FQ(a_2),FQ(a_3),Q'')
  \end{array}
  \]
  is therefore valid. Now if $a_1\notin\mathtt{Val}$, then by the induction hypothesis 
  $[C,a_1]\to[C',a_1']$ and thus $[C,\ifthenelse{a_1}{a_2}{a_3}]$ reduces 
  to $[C',\ifthenelse{a_1'}{a_2}{a_3}]$ by the $(cond)$ reduction rule. 
  If on the other hand $a_1\in\mathtt{Val}$, then by 
  Lemma~\hyperref[form_values]{\ref*{form_values}} either $a_1=\true$ or $a_1=\false$. 
  Thus $[C,\ifthenelse{a_1}{a_2}{a_3}]$ reduces either to $[C,a_2]$ by the 
  $(if\mbox{-}\mathtt{T})$ reduction rule or 
  to $[C,a_3]$ by the $(if\mbox{-}\mathtt{F})$ reduction rule.
  \item If $a=\letin{\p{x,y}}{a_1}{a_2}$, then we can reason as above to show that 
  if $a_1$ is not a value, then the $(let)$ congruence rule applies and that if 
  $a$ is a value then Lemma~\hyperref[form_values]{\ref*{form_values}} 
  guarantees that the $(pair)$ rule applies.
  \item If $a=a_1a_2$ then the typing derivation $\pi$ is: 
  \[
    \infer[.]{FQ(a_1),FQ(a_2)\entails a_1a_2:A}{
      \deduce[]{FQ(a_1)\entails a_1:B\loli A}{
        \vdots~\pi_1
      }
      &
      \deduce[]{FQ(a_2)\entails a_2:B}{
        \vdots~\pi_2
      }      
    }
  \]  
  The typed closures
  \[
  \begin{array}{rcl}
  FQ(a_1) & \entails & [C,a_1]:B\loli A,(Q'|FQ(a_2),Q'')\\
  FQ(a_2) & \entails & [C,a_2]:B, (Q'|FQ(a_1),Q'')
  \end{array}
  \]
  are therefore valid. There are three cases to treat.
  \begin{itemize}
    \item If $a_1\notin\val$, then $[C,a_1a_2]\to[C',a_1'a_2]$
    by the induction hypothesis and the $(fun)$ rule.
    \item If $a_1\in\val$ and $a_2\notin\mathtt{Val}$, then 
    $[C,ab]\to[C',ab']$ by the induction hypothesis and the $(arg)$ 
    rule.
    \item If $a_1,a_2\in\val$ then by 
    Lemma~\hyperref[form_values]{\ref*{form_values}}, $a_1$ is either 
    an abstraction or a constant. In each case $[]$ by the appropriate 
    rule among $(\beta)$, $(box)$, $(unbox)$ and $(rev)$. 
  \end{itemize}
\end{enumerate}
\end{proof}

\section{Type Inference}

In this section, we describe the type inference algorithm 
for Proto-Quipper. We detail the algorithm and prove its 
correctness for a fragment of the language and explain, 
at the end of the section, how to extend it.

\input{algorithm.tex}


\section{Language extensions}
\label{sec-extensions}

Some features of Proto-Quipper are implemented, and thus available 
to the programmer, but not formalized. This means that the proofs 
of type-safety for these extensions of the core language are 
currently under development. We briefly describe these features 
here. Further explanations and sample code can be found in the 
User Guide of Section \ref{sec-user-guide}.
\begin{description}
  \item[Polymorphism:] Our implementation of Proto-Quipper is 
    equipped with a polymorphic $let$ binder. This means that 
    expressions such as:
    \[
    \letin{a}{x}{b}
    \]
    are valid expressions of the syntax (note that $a$ is not required 
    to be a pair). Moreover, such $let$ expressions are not simply 
    syntactic sugar for $(\lambda x.b)a$. In fact, the expression
    will not be attributed a type but rather a \emph{type schema}.
    This schema can then be instantiated in various ways depending 
    on the context in which the term is used. 
  \item[Algebraic Types, Integers and Lists:] Built-in List and 
    Integer types are provided with our implementation of Proto-Quipper.
    These are accompanied by basic functions such as equality testing, 
    comparison,\ldots Moreover, Proto-Quipper supports custom defined
    recursive types (in fact, lists are defined in this way).
  \item[Recursion:] Our implementation of Proto-Quipper allows 
    recursive function definitions. To do this, we add the following 
    term constructor to the language:
    \[
    let~rec~ a ~x = b~ in~ c
    \]    
    together with the associated typing rule:
    \[
    \infer[(rec)]{!\Delta;Q \entails let~rec~ a ~x = b~ in~ c:C}{
      !\Delta,a:!(A\loli B), x:A;\varnothing \entails b:B
      &
      !\Delta, a:!(A\loli B) ;Q \entails c:C      
    }
    \]
    and reduction rule:
    \[
    \infer[(rec).]{[C,let~rec~ a ~x = b~ in~ c]\to [C, c[\lambda x.(let~rec~ a ~x = b~ in~ b)/a]}{}
    \]
    Preliminary research shows that the core language can be extended 
    with this recursion operator without loosing type-safety. 
\end{description}

\section{Future work}

In this section, we describe some ongoing and future developments 
of Proto-Quipper.
\begin{description}
  \item[Extensions and proof mechanization:] We are 
    currently incorporating the language extensions discussed 
    in the previous section (polymorphism, algebraic data types, 
    \ldots) to the type safe fragment of the language. This 
    progressive augmentation process is inherent to Proto-Quipper 
    since the language was defined to be a type safe 
    reconstruction of Quipper. For every extension, the proofs 
    of type safety have to be rewritten. This is both time-consuming 
    and error-prone. We are therefore investigating the use 
    of theorem provers (such as Coq, Abella, Twelf, \ldots) to assist 
    in establishing meta-properties of future versions of 
    Proto-Quipper. 
  \item[Reversibility and measurements:] In Proto-Quipper 
    0.1, all circuits are reversible. This follows from the 
    definition of the $(rev)$ and $(circ)$ typing rules and will 
    have to be modified to accommodate non-reversible gates such 
    as measurements. Ideally, the type system would ensure that 
    circuits are reversed only if it is meaningful to do so. In 
    particular, if a circuit contains a measurement, then it 
    should not be possible to reverse it. Preliminary research 
    shows this can be attained by extending the language with a 
    new modality $R$ accounting for reversibility. 
  \item[Dependent types and parametrized families of circuits:] 
    A circuit generating function that inputs a list of qubits does not 
    define a particular circuit but a family of circuits parametrized 
    by the integer $n$ corresponding to the length of the input list.
    To box such a function, a particular value of $n$ has to be given. 
    This is also true of other higher-order functions acting on circuits, 
    such as reversing. In Quipper, this is handled by asking the user 
    to provide a ``shape" specifying the instance of the family on 
    which to act. An alternative solution to this user-specified shape 
    would be to make Proto-Quipper's type system dependent in order to 
    store shape information at the type level.
  \item[Lingering arguments:] In the current version of 
    Proto-Quipper, all the wires manipulated in the body of a function 
    must be explicitly returned. It is not possible to implicitly 
    return the wires that have not been terminated. We plan to 
    give Proto-Quipper the ability to handle such ``lingering 
    arguments" automatically.
  \item[Non-linear controls:] Proto-Quipper handles qubits 
    in a strictly linear fashion. This ensures that qubits are 
    never discarded or duplicated and is therefore key in 
    guaranteeing that the type system enforces physical properties 
    such as no-cloning. However, this discipline is too strict since 
    certain operations, like controlling, can safely use a qubit in 
    non-linear fashion. We plan to add to Quipper the ability to 
   use qubits as controls in a non-linear fashion.
  \item[Dynamic lifting:] The reduction in Proto-Quipper 
    is non-probabilistic. Of course, the hypothetical quantum 
    device running the circuit produced by Proto-Quipper would 
    have to perform probabilistic operations, but the circuit 
    generation itself doesn't have to. This is justified by the 
    ``principle of deferred measurement" which states that any 
    quantum circuit is equivalent to one where all measurements 
    are performed as the very last operations (see, e.g., 
    \cite{NC02} p.186). We therefore don't need to rely on the 
    result of a measurement to construct circuits and, in theory, 
    no computational power is lost by making this assumption. In 
    practice, however, this delaying of measurement may 
    significantly increase the size of the circuit. Thus in terms 
    of computational resources it is advantageous to have circuit 
    generating functions that use measurement results. In fact, 
    several existing quantum algorithm, among which the USV 
    algorithm provided to us by the QCS project, rely on such 
    interactive circuit building. In Quipper, this property is 
    captured by the notion of \emph{dynamic lifting} wherein a 
    Bit (a circuit-execution time value) is lifted to a Bool (a 
    circuit-generation time value). Adding such a feature to 
    Proto-Quipper would make the reduction relation probabilistic 
    but at the time of writing, the way in which this extension 
    should be carried through it still unknown. 
\end{description}

\section{Proto-Quipper User Guide}
\label{sec-user-guide}

In this section, we provide a tutorial-style introduction to 
programming in Proto-Quipper. 

\input{tutorial}

\section*{Glossary of Acronyms}
\addcontentsline{toc}{section}{Glossary of Acronyms}

\begin{itemize}
  \item QP = Proto-Quipper.
  \item QP' = Type-inference version of Proto-Quipper.
  \item QFT = Quantum Fourier Transform.
  \item QFT3 = Quantum Fourier Transform on three qubits.
  \item QLC = Quantum Lambda Calculus.
  \item USV = Unique Shortest Vector.
\end{itemize}

\bibliography{biblio}{}
\bibliographystyle{plain}
\addcontentsline{toc}{section}{Bibliography}

\end{document}

