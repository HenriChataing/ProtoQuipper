-- This module provides general-purpose quantum functions.

import List
import Gates
import Core

-- ----------------------------------------------------------------------
-- Loops etc

-- The identity function. Sometimes it is more readable to write 
-- "return x" instead of "x".
-- 
-- return :: a -> a
let return x = x
;;

-- Iterate a function n times. Example:
-- 
-- loop 3 x f = f (f (f x)).
-- 
-- loop :: int -> a -> (a -> a) -> a
let rec loop n x f =
  if n <= 0 then x else f (loop (n-1) x f)
;;

-- A "for" loop. Counts from a to b in increments of s. Because of the
-- purely functional style of Proto-Quipper, this also threads a state
-- along the loop. 
-- 
-- Example:
-- 
-- x <- for a b s x (fun i -> fun x ->
--   x' <- commands x;
--   return x'
-- );
-- 
-- for :: int -> int -> int -> x -> (int -> x -> x) -> x
let rec for a b s x f = 
  if ((s >= 0) && (a > b)) || ((s <= 0) && (a < b)) then x else 
  let x = f a x in
  for (a+s) b s x f
;;

-- ----------------------------------------------------------------------
-- List operations

-- Map a function over a pair of lists. Example:
-- 
-- map2 f [x1,x2] [y1,y2] = ([a1,a2], [b1,b2])
--    where
-- f x1 y1 = (a1,b1)
-- f x2 y2 = (a2,b2)
-- 
-- It is an error if the lists are not of equal length.
-- 
-- map2 :: (a -> b -> c * d) -> list a -> list b -> list c * list d
let rec map2 f as bs = 
  match (as,bs) with
    ([],[]) -> ([],[])
  | (a:as, b:bs) ->
      let (c, d) = f a b in
      let (cs, ds) = map2 f as bs in
      (c:cs, d:ds)
  -- other cases are errors
;;

-- Like map2, but traverse the lists in right-to-left order.
-- It is an error if the lists are not of equal length.
-- 
-- map2r :: (a -> b -> c * d) -> list a -> list b -> list c * list d
let rec map2r f as bs =
  match (as,bs) with
    ([],[]) -> ([],[])
  | (a:as, b:bs) ->
      let (cs, ds) = map2r f as bs in
      let (c, d) = f a b in
      (c:cs, d:ds)
  -- other cases are errors
;;

-- Like map2, but also thread a state along the list. Example:
-- 
-- map2_foldl f s1 [x1,x2] [y1,y2] = (s3, [a1,a2], [b1,b2])
--    where
-- f s1 x1 y1 = (s2, a1, b1)
-- f s1 x2 y2 = (s3, a2, b2)
-- 
-- It is an error if the lists are not of equal length.
-- 
-- map2_foldl :: (s -> a -> b -> s * c * d) -> s -> list a -> list b -> s * list c * list d
let rec map2_foldl f s as bs = 
  match (s, as, bs) with
    (s, [], []) -> (s, [], [])
  | (s, a:as, b:bs) ->
      let (s1, c, d) = f s a b in
      let (s2, cs, ds) = map2_foldl f s1 as bs in
      (s2, c:cs, d:ds)
;;

-- Like map2_foldl, but traverse the lists in right-to-left order.
-- It is an error if the lists are not of equal length.
-- 
-- map2_foldr :: (s -> a -> b -> s * c * d) -> s -> list a -> list b -> s * list c * list d
let rec map2_foldr f s as bs = 
  match (s, as, bs) with
    (s, [], []) -> (s, [], [])
  | (s, a:as, b:bs) ->
      let (s1, cs, ds) = map2_foldr f s as bs in
      let (s2, c, d) = f s1 a b in
      (s2, c:cs, d:ds)
;;

-- Construct a list of length n, by repeatedly cycling the given list.
-- 
-- Example: cycle 8 [1,2,3] = [1,2,3,1,2,3,1,2].
-- 
-- cycle :: int -> list a -> list a
let cycle n l =
  let len = length l in
  if len == 0 then [] else
  let rec aux n =
    if n <= 0 then [] else
    take n l ++ aux (n-len)
  in
  aux n
;;

-- ----------------------------------------------------------------------
-- Quantum registers

-- Initialize a list of qubits from a list of boolean parameters.
-- 
-- qinit_register :: list bool -> list qubit
let qinit_register = 
  map qinit
;;

-- Terminate a list of qubits asserted to be in the state given by a
-- boolean list.
-- 
-- qterm_register :: list bool -> list qubit -> ()
let qterm_register bs qs = 
  map (fun (b,q) -> qterm b q) (reverse (zip bs qs))
;;

-- ----------------------------------------------------------------------
-- Ancillas

-- Execute a block of code with one additional ancilla initialized to
-- b. This should be used as follows:
-- 
-- r <- with_ancilla false (fun q ->
--    <<code block>>
--    return (r,q)   -- r is the result of the code block
-- )
-- 
-- Because of the current purely functional style of Proto-Quipper,
-- the code block must return the ancilla q along with its own result
-- r. This differs from Quipper's with_ancilla operator.
-- 
-- with_ancilla :: bool -> (qubit -> a * qubit) -> a
let with_ancilla b f =
  q <- qinit b;
  (res,q) <- f q;
  qterm b q;
  return res
;;

-- Execute a block of code with a list of ancillas, initialized to a
-- list of booleans.
-- 
-- with_ancilla_reg :: list bool -> (list qubit -> a * list qubit) -> a
let with_ancilla_reg bs f =
  qs <- qinit_register bs;
  (res,qs) <- f qs;
  x <- qterm_register bs qs;
  return res
;;

-- ----------------------------------------------------------------------
-- Specific gates used in the BWT algorithm

-- Uncurried version of gateW.
-- 
-- wGate :: qubit -> qubit -> qubit * qubit
let wGate x y = gateW (x,y);;

-- The inverse of wGate. Actually, wGate is self-inverse, so this is
-- just a synonym for wGate.
-- 
-- wGateInverse :: qubit -> qubit -> qubit * qubit
let wGateInverse x y = wGate x y;;

-- An exp(-itZ) gate with a signed control.
--
-- controlledExpGate_signed :: qubit -> qubit * bool -> qubit * qubit
let controlledExpGate_signed x (y, sign) = 
  (x,y) <- cexp_itZ_signed sign (x,y);
  return (x,y)
;;

-- A controlled-not gate with a signed control.
-- 
-- cnotGate_signed :: qubit -> qubit * bool -> qubit * qubit
let cnotGate_signed x (y, sign) =
  (x,y) <- cnot_signed sign (x,y);
  return (x,y)
;;

-- A Toffoli gate with signed controls. A sign of 'true' means the
-- control fires when the qubit is 1; a sign of 'false' means the
-- control fires when the qubit is 0.
-- 
-- toffoliGate_signed :: qubit -> qubit * bool -> qubit * bool -> qubit * qubit * qubit
let toffoliGate_signed x (y,s) (z,t) =
  toffoli_signed s t (x, y, z)
;;

-- A Toffoli gate specialized to one positive and one negative
-- control. The second argument is the positive control and the third
-- argument is the negative one.
-- 
-- toffoliGate_10 :: qubit -> qubit -> qubit -> qubit * qubit * qubit 
let toffoliGate_10 h a b = 
  toffoliGate_signed h (a, true) (b, false)
;;

-- ----------------------------------------------------------------------
-- Binary representation of integers

-- Check whether an integer is odd.
-- 
-- is_odd :: int -> bool
let is_odd x = x % 2 <> 0;;

-- Convert an integer to its binary representation. The representation
-- is little-endian, i.e., the least significant digit is at index 0
-- (the head) of the list.
-- 
-- boolreg_of_int_le :: int -> int -> list bool
let rec boolreg_of_int_le m x =
  if m <= 0 then [] else
  is_odd x : boolreg_of_int_le (m-1) (x/2)
;;
