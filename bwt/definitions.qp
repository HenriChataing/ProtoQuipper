-- This module provides general-purpose quantum functions.

import List
import Gates
import Core
import Function

-- ----------------------------------------------------------------------
-- Loops etc

-- The identity function. Sometimes it is more readable to write 
-- "return x" instead of "x".
-- 
-- return :: a -> a
let return x = x
;;

-- Iterate a function n times. Example:
-- 
-- loop 3 x f = f (f (f x)).
-- 
-- loop :: int -> a -> (a -> a) -> a
let rec loop n x f =
  if n <= 0 then x else f (loop (n-1) x f)
;;

-- A "for" loop. Counts from a to b in increments of s. Because of the
-- purely functional style of Proto-Quipper, this also threads a state
-- along the loop. 
-- 
-- Example:
-- 
-- x <- for a b s x (fun i -> fun x ->
--   x' <- commands x;
--   return x'
-- );
-- 
-- for :: int -> int -> int -> x -> (int -> x -> x) -> x
let rec for a b s x f = 
  if ((s >= 0) && (a > b)) || ((s <= 0) && (a < b)) then x else 
  let x = f a x in
  for (a+s) b s x f
;;

-- ----------------------------------------------------------------------
-- List operations

-- Number the elements of a list. Example:
-- 
-- number_elements [x,y,z] = [(x,0), (y,1), (z,2)].
-- 
-- number_elements :: list a -> list (a * int)
let number_elements l =
  snd (map_foldl (fun n x -> (n+1, (x,n))) 0 l)
;;

-- The inverse of number_elements.
-- 
-- unnumber_elements :: list (a * int) -> list a
let unnumber_elements l =
  map fst l
;;

-- ----------------------------------------------------------------------
-- Quantum registers

-- Initialize a list of qubits from a list of boolean parameters.
-- 
-- qinit_register :: list bool -> list qubit
let qinit_register = 
  map qinit
;;

-- Terminate a list of qubits asserted to be in the state given by a
-- boolean list.
-- 
-- qterm_register :: list bool -> list qubit -> ()
let qterm_register bs qs = 
  map (fun (b,q) -> qterm b q) (reverse (zip bs qs))
;;

-- ----------------------------------------------------------------------
-- Specific gates used in the BWT algorithm

-- Uncurried version of gateW.
-- 
-- wGate :: qubit -> qubit -> qubit * qubit
let wGate x y = gateW (x,y);;

-- The inverse of wGate. Actually, wGate is self-inverse, so this is
-- just a synonym for wGate.
-- 
-- wGateInverse :: qubit -> qubit -> qubit * qubit
let wGateInverse x y = wGate x y;;

-- An exp(-itZ) gate with a signed control.
--
-- controlledExpGate_signed :: qubit -> qubit * bool -> qubit * qubit
let controlledExpGate_signed x (y, sign) = 
  (x,y) <- cexp_itZ_signed sign (x,y);
  return (x,y)
;;

-- A controlled-not gate with a signed control.
-- 
-- cnotGate_signed :: qubit -> qubit * bool -> qubit * qubit
let cnotGate_signed x (y, sign) =
  (x,y) <- cnot_signed sign (x,y);
  return (x,y)
;;

-- A Toffoli gate with signed controls. A sign of 'true' means the
-- control fires when the qubit is 1; a sign of 'false' means the
-- control fires when the qubit is 0.
-- 
-- toffoliGate_signed :: qubit -> qubit * bool -> qubit * bool -> qubit * qubit * qubit
let toffoliGate_signed x (y,s) (z,t) =
  toffoli_signed s t (x, y, z)
;;

-- A Toffoli gate specialized to one positive and one negative
-- control. The second argument is the positive control and the third
-- argument is the negative one.
-- 
-- toffoliGate_10 :: qubit -> qubit -> qubit -> qubit * qubit * qubit 
let toffoliGate_10 h a b = 
  toffoliGate_signed h (a, true) (b, false)
;;

-- Like toffoliGate_signed, but also condition on a classical bit.
-- 
-- toffoliGate_signed_if :: bool -> qubit -> qubit * bool -> qubit * bool -> qubit * qubit * qubit
let toffoliGate_signed_if cond x (y,s) (z,t) =
  if cond then 
    toffoliGate_signed x (y,s) (z,t) 
  else
    (x, y, z)
;;

-- ----------------------------------------------------------------------
-- Ancillas

-- Execute a block of code with one additional ancilla initialized to
-- b. This should be used as follows:
-- 
-- r <- with_ancilla false (fun q ->
--    <<code block>>
--    return (r, q)   -- r is the result of the code block
-- )
-- 
-- Because of the current purely functional style of Proto-Quipper,
-- the code block must return the ancilla q along with its own result
-- r. This differs from Quipper's with_ancilla operator.
-- 
-- By using this function, the user asserts that the code block
-- returns the ancilla in the same state that it was initialized to.
-- 
-- with_ancilla :: bool -> (qubit -> a * qubit) -> a
let with_ancilla b f =
  q <- qinit b;
  (res,q) <- f q;
  qterm b q;
  return res
;;

-- Execute a block of code with a list of ancillas, initialized to a
-- list of booleans.
-- 
-- with_ancilla_reg :: list bool -> (list qubit -> a * list qubit) -> a
let with_ancilla_reg bs f =
  qs <- qinit_register bs;
  (res,qs) <- f qs;
  x <- qterm_register bs qs;
  return res
;;

-- Execute a block of code with an ancilla initialized to the
-- disjunction of the given list of qubits. This should be used as
-- follows:
-- 
-- (r, [q1,...,qn]) <- with_disjunction [q1,...,qn] (fun q ->
--    <<code block>>
--    return (r, q)   -- r is the result of the code block
-- )
-- 
-- By using this function, the user asserts that the code block
-- returns the ancilla in the same state that it was initialized to.
-- 
-- with_disjunction :: list qubit -> (qubit -> a * qubit) -> a * list qubit
let with_disjunction qs f = 
  -- with_disjunction_aux :: list qubit -> (qubit -> a * list qubit * qubit) -> a * list qubit * list qubit
  let rec with_disjunction_aux qs f =
    match qs with
      [] -> 
        (a, as) <- with_ancilla false (fun q ->
          (a, as, q) <- f q;
          return ((a, as), q)
        );
        return (a, as, [])
    | h:t ->
        (a, h:as, t) <- with_disjunction_aux t (fun p ->
          (a, h:as, p) <- with_ancilla false (fun q ->
  	    (q, p, h) <- toffoliGate_signed q (p, false) (h, true);
            (q, p) <- cnotGate_signed q (p, true);
            (a, as, q) <- f q;
            (q, p) <- cnotGate_signed q (p, true);
      	    (q, p, h) <- toffoliGate_signed q (p, false) (h, true);
            return ((a, h:as, p), q)
          );
          return (a, h:as, p)
        );
        return (a, as, h:t)
  in
  (a, [], qs) <- with_disjunction_aux qs (fun q ->
    (a, q) <- f q;
    return (a, [], q)
  );
  return (a, qs)
;;

-- A version of foldl with the arguments in a different order. The idea is
-- to use this as a block:
-- 
-- s <- for_each [x,y,z] s body
-- 
-- is equivalent to:
-- 
-- s <- body x s;
-- s <- body y s;
-- s <- body z s
-- 
-- for_each :: list a -> s -> (a -> s -> s) -> s
let for_each xs s body = foldl body xs s ;;

-- Like for_each, but traverse the list in right-to-left order. For
-- example:
-- 
-- s <- for_eachr [x,y,z] s body
-- 
-- is equivalent to:
-- 
-- s <- body z s;
-- s <- body y s;
-- s <- body x s
-- 
-- for_eachr :: list a -> s -> (a -> s -> s) -> s
let for_eachr xs s body = foldr body xs s ;;

-- A version of map_foldl with the arguments in a different order. The
-- idea is to use this as a block:
-- 
-- ([a,b,c], s) <- for_each_map [x,y,z] s body
-- 
-- is equivalent to:
-- 
-- (a,s) <- body x s;
-- (b,s) <- body y s;
-- (c,s) <- body z s
-- 
-- for_each_map :: list a -> s -> (a -> s -> b * s) -> (list b) * s
let for_each_map xs s body = 
  let f s a = swap (body a s) in
  let (s, ys) = map_foldl f s xs in
  (ys, s)
;;

-- Like for_each_map, but traverse the list in right-to-left order.
-- For example:
-- 
-- ([a,b,c], s) <- for_each_mapr [x,y,z] s body
-- 
-- is equivalent to:
-- 
-- (c,s) <- body z s;
-- (b,s) <- body y s;
-- (a,s) <- body x s
-- 
-- for_each_mapr :: list a -> s -> (a -> s -> b * s) -> (list b) * s
let for_each_mapr xs s body = 
  let f s a = swap (body a s) in
  let (s, ys) = map_foldr f s xs in
  (ys, s)
;;

-- ----------------------------------------------------------------------
-- Binary representation of integers

-- Check whether an integer is odd.
-- 
-- is_odd :: int -> bool
let is_odd x = x % 2 <> 0;;

-- Check whether an integer is even.
-- 
-- is_even :: int -> bool
let is_even x = x % 2 == 0;;

-- Convert an integer to its binary representation. The representation
-- is little-endian, i.e., the least significant digit is at index 0
-- (the head) of the list.
-- 
-- boolreg_of_int_le :: int -> int -> list bool
let rec boolreg_of_int_le m x =
  if m <= 0 then [] else
  is_odd x : boolreg_of_int_le (m-1) (x/2)
;;

