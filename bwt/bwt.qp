-- This module provides an implementation of the Binary Welded Tree
-- algorithm.

import Core
import List
import Definitions

-- ----------------------------------------------------------------------
-- Oracle abstraction

-- A data structure to hold an oracle. An oracle encodes a graph, and
-- provides the following information: the tree depth n, the label
-- length m (usually = n + 2), the number of edge colors k, the
-- entrance label, and for each color c in {0..k-1}, a reversible
-- circuit oracle_c(a,b,r).

type oracle = 
  Oracle of int                                 -- tree depth n
  	  * int        				-- label length m
	  * int        				-- number of colors k
	  * list bool  				-- entrance label
	  * (int ->    				-- color parameter c
	     list qubit * list qubit * qubit -> -- (a,b,r) inputs
	     list qubit * list qubit * qubit)   -- (a,b,r) outputs

-- ----------------------------------------------------------------------
-- The time step

-- Perform a single diffusion step of the quantum walk. Here, a and b
-- are m-qubit registers holding node labels to be diffused. r is a
-- control.
let timestep (a,b,r,m) = 
  (a,b,r) <- with_ancilla false (fun h ->
    (a,b) <- map2 wGate a b;
    (h,a,b) <- map2_foldl toffoliGate_10 h a b;
    (h,r) <- controlledExpGate_signed h (r, false);
    (h,a,b) <- map2_foldr toffoliGate_10 h a b;
    (a,b) <- map2r wGateInverse a b;
    return ((a,b,r),h)  
  );
  return (a,b,r)
;;

-- ----------------------------------------------------------------------
-- The top-level algorithm

-- The main loop of the binary welded tree algorithm. Because there is
-- currently no built-in real number type in Proto-Quipper, we leave
-- the timestep implicit. Also, since Proto-Quipper currently does not
-- include classical bits or measurements, we return the unmeasured
-- quantum register a.
-- 
-- qrwbwt :: oracle -> int -> list qubit
let qrwbwt oracle s =
  let Oracle (n,m,k,entrance,oraclefun) = oracle in
  a <- qinit_register entrance;
  a <- with_ancilla_reg (replicate m false) (fun b ->
    (a,b) <- with_ancilla false (fun r -> 
      (a,b,r) <- loop s (a,b,r) (fun (a,b,r) -> 
        (a,b,r) <- for 0 (k-1) 1 (a,b,r) (fun c -> fun (a,b,r) -> 
          (a,b,r) <- oraclefun c (a,b,r);
          (a,b,r) <- timestep (a,b,r,m);
          (a,b,r) <- oraclefun c (a,b,r);
          return (a,b,r)
        );
        return (a,b,r)
      );
      return ((a,b),r)
    );
    return (a,b)
  );
  return a
;;

-- ----------------------------------------------------------------------
-- The oracle implementation

-- The functions in this section implement a particular oracle for a
-- binary welded tree. The oracle is parametric on: 
-- 
-- * the tree depth n; 
-- 
-- * two "welding vectors" f and g, specifying how the leaves of the
-- two binary trees are connected to each other. Specifically, f and g
-- encode the permutations of leaves mapping a to (a xor f) and to 
-- (a + g), respectively, where "xor" denotes bitwise exclusive or,
-- and "+" denotes binary addition.

-- DUMMY FUNCTIONS: not yet implemented.
let parseNodeEven (a, even, n) = (a, even);;
let testIsParent (a, root, even, isparent, color, n, really, ismatch) = (a, root, even, isparent, ismatch);;
let testIsChild (even, ischild, direction, color, n) = (even, ischild, direction);;
let setParent (a, b, isparent, n) = (a, b, isparent);;
let setChild (a, b, ischild, direction, f, g, n) = (a, b, ischild, direction);;

-- Input a node label a of length at least n+1. Negate both root
-- and even if a is a root node.
-- 
-- parseNodeRoot :: list qubit * qubit * qubit * int -> list qubit * qubit * qubit
let parseNodeRoot (a, root, even, n) = 
  (a, root, even) <- with_ancilla_reg (replicate (n+1) false) (fun scratch -> 
    (a, scratch) <- for n 1 (0-1) (a, scratch) (fun index -> fun (a, scratch) ->
      -- The purely functional style means lots of stuff needs to be passed around.

      -- Extract the relevant qubits from the registers:
      (scratch_index, scratch) <- sf_list_index scratch index;
      (scratch_index_1, scratch) <- sf_list_index scratch (index-1);
      (a_index, a) <- sf_list_index a index;
      -- Operate on them:
      (scratch_index_1, scratch_index, a_index) <- toffoliGate_signed scratch_index_1 (scratch_index, false) (a_index, true);
      (scratch_index_1, scratch_index) <- cnotGate_signed scratch_index_1 (scratch_index, true);
      -- Re-insert qubits in their respective registers:
      a <- sf_list_unindex (a_index, a) index;
      scratch <- sf_list_unindex (scratch_index_1, scratch) (index-1);
      scratch <- sf_list_unindex (scratch_index, scratch) index;

      return (a, scratch)
    );
    
    (scratch_0, scratch) <- sf_list_index scratch 0;
    (root, scratch_0) <- cnotGate_signed root (scratch_0, false);
    (even, scratch_0) <- cnotGate_signed even (scratch_0, false);
    scratch <- sf_list_unindex (scratch_0, scratch) 0;

    (a, scratch) <- for 1 n 1 (a, scratch) (fun index -> fun (a, scratch) ->

      (scratch_index, scratch) <- sf_list_index scratch index;
      (scratch_index_1, scratch) <- sf_list_index scratch (index-1);
      (a_index, a) <- sf_list_index a index;

      (scratch_index_1, scratch_index) <- cnotGate_signed scratch_index_1 (scratch_index, true);
      (scratch_index_1, scratch_index, a_index) <- toffoliGate_signed scratch_index_1 (scratch_index, false) (a_index, true);

      a <- sf_list_unindex (a_index, a) index;
      scratch <- sf_list_unindex (scratch_index_1, scratch) (index-1);
      scratch <- sf_list_unindex (scratch_index, scratch) index;

      return (a, scratch)
    );
    return ((a, root, even), scratch)
  );
  return (a, root, even)
;;

-- The main oracle function. 
-- 
-- oraclefun :: int -> list bool -> list bool -> int -> (list qubit * list qubit * qubit -> list qubit * list qubit * qubit)
let oraclefun n f g c (a,b,r) = 
  let color = boolreg_of_int_le 2 c in
  (a,b,r) <- with_ancilla_reg [false, false, false, false, false, false] (fun [root, even, isparent, ischild, direction, ismatch] ->
    (a, root, even) <- parseNodeRoot (a, root, even, n);
    (a, even) <- parseNodeEven (a, even, n);
    (a, root, even, isparent, ismatch) <- testIsParent (a, root, even, isparent, color, n, 1, ismatch);
    (even, ischild, direction) <- testIsChild (even, ischild, direction, color, n);
    (a, b, isparent) <- setParent (a, b, isparent, n);
    (a, b, ischild, direction) <- setChild (a, b, ischild, direction, f, g, n);

    (r, isparent, ischild) <- toffoliGate_signed r (isparent, false) (ischild, false);

    (even, ischild, direction) <- testIsChild (even, ischild, direction, color, n);
    (a, root, even, isparent, ismatch) <- testIsParent (a, root, even, isparent, color, n, 0, ismatch);
    (a, even) <- parseNodeEven (a, even, n);
    (a, root, even) <- parseNodeRoot (a, root, even, n);

    return ((a,b,r), [root, even, isparent, ischild, direction, ismatch])
  );
  return (a,b,r)
;;

-- The orthodox oracle. The parameter n is the tree depth.
-- 
-- orthodox_oracle :: int -> list bool -> list bool -> Oracle
let oracle_orthodox n f g =
  Oracle (n, n+2, 4, replicate (n+1) false ++ [true], oraclefun n f g)
;;

-- ----------------------------------------------------------------------
-- The "main" program: display the circuit for size n.
-- 
-- main :: int -> circ((), list qubit)
let main n =
  let f = cycle n [true, false] in
  let g = cycle n [false, true] in
  box[] (fun () -> qrwbwt (oracle_orthodox n f g) 1)
;;

main 3;;

