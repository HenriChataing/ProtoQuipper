-- This module provides an implementation of the Binary Welded Tree
-- algorithm.

import Core
import List
import Function
import Gates
import Definitions

-- ----------------------------------------------------------------------
-- * Oracle abstraction

-- A data structure to hold an oracle. An oracle encodes a graph, and
-- provides the following information: the tree depth n, the label
-- length m (usually = n + 2), the number of edge colors k, the
-- entrance label, and for each color c in {0..k-1}, a reversible
-- circuit oracle_c(a,b,r).

type oracle =
  Oracle of int                                 -- tree depth n
  	  * int        				-- label length m
	  * int        				-- number of colors k
	  * list bool  				-- entrance label
	  * (int ->    				-- color parameter c
	     list qubit * list qubit * qubit -> -- (a,b,r) inputs
	     list qubit * list qubit * qubit)   -- (a,b,r) outputs

-- ----------------------------------------------------------------------
-- * The diffusion step

-- Perform a single diffusion step of the quantum walk. Here, a and b
-- are m-qubit registers holding node labels to be diffused. r is a
-- control.
let timestep (a,b,r,m) =
  (a,b,r) <- with_ancilla false (fun h ->
    (a,b) <- map2 wGate a b;
    (h,a,b) <- map2_foldl toffoliGate_10 h a b;
    (h,r) <- controlledExpGate_signed h (r, false);
    (h,a,b) <- map2_foldr toffoliGate_10 h a b;
    (a,b) <- map2r wGateInverse a b;
    return ((a,b,r),h)
  );
  return (a,b,r)
;;

-- ----------------------------------------------------------------------
-- * The top-level algorithm

-- The main loop of the binary welded tree algorithm. Because there is
-- currently no built-in real number type in Proto-Quipper, we leave
-- the timestep implicit. Also, since Proto-Quipper currently does not
-- include classical bits or measurements, we return the unmeasured
-- quantum register a.
--
-- qrwbwt :: oracle -> int -> list qubit
let qrwbwt oracle s =
  let Oracle (n,m,k,entrance,oraclefun) = oracle in
  a <- qinit_register entrance;
  a <- with_ancilla_reg (replicate m false) (fun b ->
    (a,b) <- with_ancilla false (fun r ->
      (a,b,r) <- loop s (a,b,r) (fun (a,b,r) ->
        (a,b,r) <- for 0 (k-1) 1 (a,b,r) (fun c -> fun (a,b,r) ->
          (a,b,r) <- oraclefun c (a,b,r);
          (a,b,r) <- timestep (a,b,r,m);
          (a,b,r) <- oraclefun c (a,b,r);
          return (a,b,r)
        );
        return (a,b,r)
      );
      return ((a,b),r)
    );
    return (a,b)
  );
  return a
;;

-- ----------------------------------------------------------------------
-- * The oracle implementation

-- ----------------------------------------------------------------------
-- ** Oracle subroutines

-- The functions in this section implement a particular oracle for a
-- binary welded tree. The oracle is parametric on:
--
-- * the tree depth n;
--
-- * two "welding vectors" f and g, specifying how the leaves of the
-- two binary trees are connected to each other. Specifically, f and g
-- encode the permutations of leaves mapping a to (a xor f) and to
-- (a + g), respectively, where "xor" denotes bitwise exclusive or,
-- and "+" denotes binary addition.

-- DUMMY FUNCTIONS: not yet implemented.
let setChild (a, b, ischild, direction, f, g, n) = (a, b, ischild, direction);;

-- Input a node label 'a' of length at least n+1. Negate both 'root'
-- and 'even' if 'a' is a root node.
--
-- parseNodeRoot :: list qubit * qubit * qubit * int -> list qubit * qubit * qubit
let parseNodeRoot (a, root, even, n) =
  (a, (root, even)) <- with_list_range 1 n a (root, even) (fun a (root, even) ->
    ((root, even), a) <- with_disjunction a (fun q ->

      (root, q) <- cnotGate_signed root (q, false);
      (even, q) <- cnotGate_signed even (q, false);

      return ((root, even), q)
    );
    return (a, (root, even))
  );
  return (a, root, even)
;;

-- Input a node label 'a' of length at least n+1. Negate 'even' if the
-- node 'a' occurs at an even height in the tree.
--
-- parseNodeEven :: list qubit * qubit * int -> list qubit * qubit
let parseNodeEven (as, even, n) =
  as <- number_elements as;
  (as, even) <- with_list_range 1 n as even (fun as even ->
    (as, even) <- with_ancilla false (fun flag ->

      (scratches, (flag, even)) <- for_each_mapr as (flag, even) (fun (a, index) (flag, even) ->
        scratch <- qinit false;
        (scratch, flag, a) <- toffoliGate_signed scratch (flag, false) (a, true);
        (even, flag, a) <- toffoliGate_signed_if (is_even index) even (flag, false) (a, true);
        (flag, scratch) <- cnotGate_signed flag (scratch, true);
        return ((a, index, scratch), (flag, even))
      );
      (as, flag) <- for_each_map scratches flag (fun (a, index, scratch) flag ->
        (flag, scratch) <- cnotGate_signed flag (scratch, true);
        (scratch, flag, a) <- toffoliGate_signed scratch (flag, false) (a, true);
        qterm false scratch;
        return ((a, index), flag)
      );
      return ((as, even), flag)
    );
    return (as, even)
  );
  as <- unnumber_elements as;
  return (as, even)
;;

-- Input a node label 'a' of length at least 1, and flags 'root'
-- and 'even' describing whether 'a' is a root and at an even level,
-- respectively. Negate 'isparent' if 'a' has a parent of color
-- 'color' in the tree.
--
-- The qubit 'ismatch' is an ancilla, and 'really' is either false or
-- true. They are jointly used to control uncomputation, so that the
-- following sequence will compute and then uncompute 'testIsParent':
--
-- > ismatch <- qinit false;
-- > (a, root, even, isparent, ismatch) <- testIsParent (a, root, even, isparent, color, n, true, ismatch);
-- > (a, root, even, isparent, ismatch) <- testIsParent (a, root, even, isparent, color, n, false, ismatch);
-- > qterm false ismatch;
--
-- testIsParent :: list qubit * qubit * qubit * qubit * list bool * int * bool * qubit -> list qubit * qubit * qubit * qubit * qubit
let testIsParent (a, root, even, isparent, color, n, really, ismatch) =
  (a0, as) <- sf_head a;
  (isparent, root, ismatch) <- toffoliGate_signed_if (not really) isparent (root, false) (ismatch, true);
  (ismatch, isparent, even, a0) <- (match color with
    [true, true] ->
      (ismatch, even, a0) <- toffoliGate_signed ismatch (even, true) (a0, true);
      return (ismatch, isparent, even, a0)
  | [false, true] ->
      (ismatch, even, a0) <- toffoliGate_signed ismatch (even, true) (a0, false);
      return (ismatch, isparent, even, a0)
  | [true, false] ->
      (isparent, even, a0) <- toffoliGate_signed isparent (even, false) (a0, true);
      return (ismatch, isparent, even, a0)
  | [false, false] ->
      (isparent, even, a0) <- toffoliGate_signed isparent (even, false) (a0, false);
      return (ismatch, isparent, even, a0)
  );
  (isparent, root, ismatch) <- toffoliGate_signed isparent (root, false) (ismatch, true);
  a <- a0 : as;
  return (a, root, even, isparent, ismatch)
;;

-- Consider a node 'a', and negate 'ischild' if 'a' has a child node
-- of color 'color'. Also set 'direction' to indicate whether it is a
-- "left" or "right" child. Here, 'color' is a boolean register of
-- length 2, representing a color. This function is self-inverse.
--
-- testIsChild :: qubit * qubit * qubit * list bool * int -> qubit * qubit * qubit
let testIsChild (even, ischild, direction, color, n) =
  (ischild, even) <- cnotGate_signed ischild (even, not (color @ 1));
  direction <- qnot_if (color @ 0) direction;
  return (even, ischild, direction)
;;

-- Input a node label 'a' of length at least n+2, and a flag
-- 'isparent' that has been initialized accordingly. Also input a
-- register 'b' of length at least n+2, initialized to 0.  If
-- 'isparent' is set, set 'b' to the node label of the parent of
-- 'a'. This is self-inverse.
-- 
-- setParent :: list qubit * list qubit * qubit * int -> list qubit * list qubit * qubit
let setParent (a, b, isparent, n) = 

  (a, (b, isparent)) <- with_list_range 1 n a (b, isparent) (fun as (b, isparent) ->
    (b, (as, isparent)) <- with_list_range 0 (n-1) b (as, isparent) (fun bs (as, isparent) ->
      (as, bs, isparent) <- for_each_map2 as bs isparent (fun a b isparent ->
        (b, isparent, a) <- toffoliGate_signed b (isparent, true) (a, true);
        return (a, b, isparent)
      ); 
      return (bs, (as, isparent))
    );
    return (as, (b, isparent))
  );

  (a, (b, isparent)) <- with_list_index (n+1) a (b, isparent) (fun a (b, isparent) ->
    (b, (a, isparent)) <- with_list_index (n+1) b (a, isparent) (fun b (a, isparent) ->
      (b, isparent, a) <- toffoliGate_signed b (isparent, true) (a, true);
      return (b, (a, isparent))
    );
    return (a, (b, isparent))
  );

  return (a, b, isparent)
;;

----------------------------------------------------------------------
-- ** The main oracle function

-- The main oracle function.
--
-- oraclefun :: int -> list bool -> list bool -> int -> (list qubit * list qubit * qubit -> list qubit * list qubit * qubit)
let oraclefun n f g c (a,b,r) =
  let color = boolreg_of_int_le 2 c in
  (a,b,r) <- with_ancilla_reg [false, false, false, false, false, false] (fun [root, even, isparent, ischild, direction, ismatch] ->
    (a, root, even) <- parseNodeRoot (a, root, even, n);
    (a, even) <- parseNodeEven (a, even, n);
    (a, root, even, isparent, ismatch) <- testIsParent (a, root, even, isparent, color, n, true, ismatch);
    (even, ischild, direction) <- testIsChild (even, ischild, direction, color, n);
    (a, b, isparent) <- setParent (a, b, isparent, n);
    (a, b, ischild, direction) <- setChild (a, b, ischild, direction, f, g, n);

    (r, isparent, ischild) <- toffoliGate_signed r (isparent, false) (ischild, false);

    (even, ischild, direction) <- testIsChild (even, ischild, direction, color, n);
    (a, root, even, isparent, ismatch) <- testIsParent (a, root, even, isparent, color, n, false, ismatch);
    (a, even) <- parseNodeEven (a, even, n);
    (a, root, even) <- parseNodeRoot (a, root, even, n);

    return ((a,b,r), [root, even, isparent, ischild, direction, ismatch])
  );
  return (a,b,r)
;;

-- The orthodox oracle. The parameter n is the tree depth.
--
-- orthodox_oracle :: int -> list bool -> list bool -> Oracle
let oracle_orthodox n f g =
  Oracle (n, n+2, 4, replicate (n+1) false ++ [true], oraclefun n f g)
;;

-- ----------------------------------------------------------------------
-- * The main program

-- Display the circuit for size n.
--
-- main :: int -> circ((), list qubit)
let main n =
  let f = cycle n [true, false] in
  let g = cycle n [false, true] in
  box[] (fun () -> qrwbwt (oracle_orthodox n f g) 1)
;;

main 3;;
