{
-- | Module auto-generated by Alex that performs the lexing of the input files.
-- It contains the definition of the data type Token of tokens, result of the lexing.
module Parsing.Lexer (Token(..), mylex) where

import Parsing.Location

import Monad.QuipperError
import Monad.QpState

import qualified Data.List as List
}

%wrapper "posn"

$low_alpha = [a-z]
$up_alpha = [A-Z]
$alpha = [$low_alpha $up_alpha]
$digit = [0-9]
$chars = [$alpha $digit _]
$infix0 = ['\<' '\>' '\|' '\&' '\$']
$infix1 = ['\@' '\^']
$infix2 = ['\+' '\-']
$infix3 = ['\*' '\/']
$symbolchar = [$infix0 $infix1 $infix2 $infix3 '\%' '\.' '\:']

tokens :-

  $white+                             ;
  "--".*                              ;

  "_"                                 { locate_token TkJoker }
  "<:"                                { locate_token TkSubType }
  "*"                                 { locate_token TkStar }
  "."                                 { locate_token TkDot }
  ","                                 { locate_token TkComma }
  ":"                                 { locate_token TkColon }
  ";"                                 { locate_token TkSemiColon }
  ";;"                                { locate_token TkDblSemiColon }
  "="                                 { locate_token TkEq }
  "!"                                 { locate_token TkBang }
  "|"                                 { locate_token TkBar }
  "->"                                { locate_token TkRArrow }
  "<-"                                { locate_token TkLArrow }
  "<-*"                               { locate_token TkLArrowStar }
  "("                                 { locate_token TkLParen } 
  ")"                                 { locate_token TkRParen }
  "["                                 { locate_token TkLBracket }
  "]"                                 { locate_token TkRBracket }
  "{"                                 { locate_token TkLCurlyBracket }
  "}"                                 { locate_token TkRCurlyBracket }

  and                                 { locate_token TkAnd }
  bool                                { locate_token TkBool }
  box                                 { locate_token TkBox }
  circ                                { locate_token TkCirc }
  else                                { locate_token TkElse }
  false                               { locate_token TkFalse }
  fun                                 { locate_token TkFun }
  if                                  { locate_token TkIf }
  import                              { locate_token TkImport }
  in                                  { locate_token TkIn }
  int                                 { locate_token TkInteger }
  let                                 { locate_token TkLet }
  match                               { locate_token TkMatch }
  of                                  { locate_token TkOf }
  qubit                               { locate_token TkQuBit }
  rec                                 { locate_token TkRec }
  rev                                 { locate_token TkRev }
  then                                { locate_token TkThen }
  type                                { locate_token TkType }
  true                                { locate_token TkTrue }
  unbox                               { locate_token TkUnbox }
  val                                 { locate_token TkVal }
  with                                { locate_token TkWith }
  "#builtin"                          { locate_token TkBuiltin }

  $digit+                             { locate_named_token TkInt }
  $up_alpha $chars* \. $low_alpha $chars* { locate_named_token TkQLId }
  $up_alpha $chars* \. $up_alpha $chars*  { locate_named_token TkQUId }
  $low_alpha $chars*                  { locate_named_token TkLId }
  $up_alpha $chars*                   { locate_named_token TkUId }

  $infix0 $symbolchar*                { locate_named_token TkInfix0 }
  $infix1 $symbolchar*                { locate_named_token TkInfix1 } 
  $infix2 $symbolchar*                { locate_named_token TkInfix2 } 
  $infix3 $symbolchar*                { locate_named_token TkInfix3 } 

  [^tokens]                           { locate_named_token TkError }

{

-- | Converts alex's positions to extents
posn_to_extent :: AlexPosn -> String -> Extent
posn_to_extent (AlexPn p l c) s =
  Ext { lbegin = Loc { line = l, column = c },
        lend = Loc { line = l, column = c+length s-1 }}

-- | Definition of the tokens. 
-- All the tokens are annotated by an extent corresponding to the location of the token
-- in the original file. This will later serve to locate the parsed expressions.
-- The tokens can be separated in four categories :name tokens (variables),
-- punctuation marks, reserved notations, and delimiters.
data Token =
  -- Name tokens : variables and data constructors
    TkLId (Extent, String)       -- ^ Variable names starting with a lower case character.
  | TkUId (Extent, String)       -- ^ Variable names starting with an upper case character.
  | TkQLId (Extent, String)      -- ^ Qualified lower-case identifiers.
  | TkQUId (Extent, String)      -- ^ Qualified upper-case identifiers.
  | TkInt (Extent, String)       -- ^ Integers. The value of the integer is left unparsed.
  | TkError (Extent, String)     -- ^ Error token.

  -- Reserved notations : list of reserved names
  | TkAnd Extent           -- ^ and.
  | TkBool Extent          -- ^ bool.
  | TkBox Extent           -- ^ box.
  | TkCirc Extent          -- ^ circ.
  | TkElse Extent          -- ^ else.
  | TkFalse Extent         -- ^ false.
  | TkFun Extent           -- ^ fun.
  | TkIf Extent            -- ^ if.
  | TkImport Extent        -- ^ import.
  | TkIn Extent            -- ^ in.
  | TkInteger Extent       -- ^ int.
  | TkLet Extent           -- ^ let.
  | TkMatch Extent         -- ^ match.
  | TkOf Extent            -- ^ of. 
  | TkQuBit Extent          -- ^ qubit.
  | TkRec Extent           -- ^ rec. 
  | TkRev Extent           -- ^ rev.
  | TkThen Extent          -- ^ then.
  | TkTrue Extent          -- ^ true.
  | TkType Extent          -- ^ type.
  | TkUnbox Extent         -- ^ unbox.
  | TkVal Extent           -- ^ val.
  | TkWith Extent          -- ^ with. 
  | TkBuiltin Extent       -- ^ \#builtin.

  -- Punctuation marks, and other symbols
  | TkJoker Extent         -- ^ _
  | TkStar Extent          -- ^ \*
  | TkBar Extent           -- ^ |
  | TkComma Extent         -- ^ ,
  | TkColon Extent         -- ^ :
  | TkSemiColon Extent     -- ^ ;
  | TkEq Extent            -- ^ =
  | TkBang Extent          -- ^ !
  | TkRArrow Extent        -- ^ \->
  | TkLArrow Extent        -- ^ <\-
  | TkSubType Extent       -- ^ <:
  | TkDblSemiColon Extent  -- ^ ;;
  | TkDot Extent           -- ^ .
  | TkLArrowStar Extent    -- ^ <-*

  -- Delimiters
  | TkLParen Extent        -- ^ (
  | TkRParen Extent        -- ^ )
  | TkLBracket Extent      -- ^ \[
  | TkRBracket Extent      -- ^ ]
  | TkLCurlyBracket Extent -- ^ {
  | TkRCurlyBracket Extent -- ^ }

  -- Operators
  | TkInfix0 (Extent, String)   -- ^ All operators starting with ['<' '>' | '&' '$'], and ending with any sequence of special characters
  | TkInfix1 (Extent, String)   -- ^ All operators starting with [\@ '^']
  | TkInfix2 (Extent, String)   -- ^ All operators starting with ['+' '-']
  | TkInfix3 (Extent, String)   -- ^ All operators starting with ['*' '/']


instance Show Token where
  show (TkLId (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkUId (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkQLId (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkQUId (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkInt (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkError (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"

  show (TkAnd ex) = "'and' (" ++ show ex ++ ")"
  show (TkBool ex) = "'bool' (" ++ show ex ++ ")"
  show (TkBox ex) = "'box' (" ++ show ex ++ ")"
  show (TkCirc ex) = "'circ' (" ++ show ex ++ ")"
  show (TkElse ex) = "'else' (" ++ show ex ++ ")"
  show (TkFalse ex) = "'false' (" ++ show ex ++ ")"
  show (TkFun ex) = "'fun' (" ++ show ex ++ ")"
  show (TkIf ex) = "'if' (" ++ show ex ++ ")"
  show (TkImport ex) = "'import' (" ++ show ex ++ ")"
  show (TkIn ex) = "'in' (" ++ show ex ++ ")"
  show (TkInteger ex) = "'int' (" ++ show ex ++ ")"
  show (TkLet ex) = "'let' (" ++ show ex ++ ")"
  show (TkMatch ex) = "'match' (" ++ show ex ++ ")"
  show (TkOf ex) = "'of' (" ++ show ex ++ ")"
  show (TkQuBit ex) = "'qubit' (" ++ show ex ++ ")"
  show (TkRec ex) = "'rec' (" ++ show ex ++ ")"
  show (TkRev ex) = "'rev' (" ++ show ex ++ ")"
  show (TkThen ex) = "'then' (" ++ show ex ++ ")"
  show (TkTrue ex) = "'true' (" ++ show ex ++ ")"
  show (TkType ex) = "'type' (" ++ show ex ++ ")"
  show (TkUnbox ex) = "'unbox' (" ++ show ex ++ ")"
  show (TkVal ex) = "'val' (" ++ show ex ++ ")"
  show (TkWith ex) = "'with' (" ++ show ex ++ ")" 
  show (TkBuiltin ex) = "'#builtin' (" ++ show ex ++ ")"

  show (TkJoker ex) = "'_' (" ++ show ex ++ ")"
  show (TkStar ex) = "'*' (" ++ show ex ++ ")"
  show (TkBar ex) = "'|' (" ++ show ex ++ ")"
  show (TkComma ex) = "',' (" ++ show ex ++ ")"
  show (TkColon ex) = "':' (" ++ show ex ++ ")"
  show (TkSemiColon ex) = "';' (" ++ show ex ++ ")"
  show (TkEq ex) = "'=' (" ++ show ex ++ ")"
  show (TkBang ex) = "'!' (" ++ show ex ++ ")"
  show (TkRArrow ex) = "'->' (" ++ show ex ++ ")"
  show (TkLArrow ex) = "'<-' (" ++ show ex ++ ")"
  show (TkSubType ex) = "'<:' (" ++ show ex ++ ")"
  show (TkDblSemiColon ex) = "';;' (" ++ show ex ++ ")"
  show (TkDot ex) = "'^' (" ++ show ex ++ ")"
  show (TkLArrowStar ex) = "'<-*' (" ++ show ex ++ ")"

  -- Delimiters
  show (TkLParen ex) = "'(' (" ++ show ex ++ ")"
  show (TkRParen ex) = "')' (" ++ show ex ++ ")"
  show (TkLBracket ex) = "'[' (" ++ show ex ++ ")"
  show (TkRBracket ex) = "']' (" ++ show ex ++ ")"
  show (TkLCurlyBracket ex) = "'{' (" ++ show ex ++ ")"
  show (TkRCurlyBracket ex) = "'}' (" ++ show ex ++ ")"

  -- Operators
  show (TkInfix0 (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkInfix1 (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkInfix2 (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"
  show (TkInfix3 (ex, s)) = "'" ++ s ++ "' (" ++ show ex ++ ")"



-- | Locate a token. The type signatures matches the one expected of lexing actions.
locate_token :: (Extent -> Token) -> AlexPosn -> String -> Token
locate_token tk p s = tk (posn_to_extent p s)

-- | Same as locate_token, except that the string of the token is also included in the object.
locate_named_token :: ((Extent, String) -> Token) -> AlexPosn -> String -> Token
locate_named_token tk p s = tk (posn_to_extent p s, s)

-- | Lexing function. Inputs an unparsed string, and returns the corresponding list of tokens.
-- The lexer can fail if an recognized token is encountered, in which case it throws a LexicalError exception.
mylex :: String -> QpState [Token]
mylex contents = do
  tokens <- return $ alexScanTokens contents
  case List.find (\tk -> case tk of
                           TkError _ -> True
                           _ -> False) tokens of
    Just (TkError (ex, s)) -> throwQ $ LexicalError s ex
    Nothing -> return tokens 
}
