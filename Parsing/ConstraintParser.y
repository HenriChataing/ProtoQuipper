{
-- | This module is auto-generated by Happy. It provides a function to parse constraint sets.
-- This function is used exclusively to parse the argument of the unification tester.
module Parsing.ConstraintParser (parseError, parse_constraints) where

import Classes

import Parsing.Localizing
import Parsing.Lexer
import Parsing.Syntax

import Data.Char
import Data.List as List
}

%name parse_constraints
%tokentype { Token }
%error { parseError }

%token
  '*' { TkStar $$ }
  ',' { TkComma $$ }
  '!' { TkBang $$ }
  '(' { TkLParen $$ }
  ')' { TkRParen $$ }
  "<:" { TkSubType $$ }
  
  ARROW { TkRArrow $$ }
  VAR { TkLId $$ }
  CIRC { TkCirc $$ }
  BOOL { TkBool $$ }
  QUBIT { TkQuBit $$ }

%left ARROW
%left '*'
%nonassoc '!'

%%

Constraint_set : '(' Constraint_list ')'           { $2 }

Constraint_list : Constraint ',' Constraint_list   { $1:$3 }
                | Constraint                       { [$1] }

Constraint : Type "<:" Type              { ($1, $3) }

Atom_type : VAR                          { locate (TVar $ snd $1) $ fst $1 }
          | BOOL                         { locate TBool $1 }
          | QUBIT                         { locate TQubit $1 }
          | CIRC '(' Type ',' Type ')'   { locate (TCirc $3 $5) (fromto $1 $6) }
          | '(' Type ')'                 { $2 }
          | '(' ')'                      { locate TUnit (fromto $1 $2) }

Type : Atom_type                         { $1 }
     | Type '*' Type                     { locate_opt (TTensor [$1, $3]) (fromto_opt (location $1) (location $3)) }
     | Type ARROW Type                   { locate_opt (TArrow $1 $3) (fromto_opt (location $1) (location $3)) }
     | '!' Type                          { locate_opt (TBang $2) (fromto_opt (Just $1) (location $2)) }

{
-- | Main function. Takes a list of tokens, and returns the parsed list of constraints.
parse_constraints :: [Token] -> [(Type, Type)]

-- | Function called by the parser when coming upon an unexpected sequence of tokens.
-- The argument corresponds to the list of remaining tokens. If this list is empty, the error
-- is 'Unexpected end of file', and appears on uncomplete expression. If not, the head corresponds to the location where
-- the parsing failed.
parseError :: [Token] -> a
parseError [] = error "Parse error : unknown token"
parseError tokens = error ("Parse error : on token " ++ (show $ head tokens))
} 
