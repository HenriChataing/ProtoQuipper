-- | This module defines all that is needed to work with sub-typing and flag constraints

module Subtyping (
  -- Constraints definition
  TypeConstraint(..),
  FlagConstraint(..),
  ConstraintSet(..),
  -- Operation on constraints
  (<:),
  (<>),
  is_trivial, is_atomic, is_composite, is_semi_composite,
  is_one_sided,
  constraint_unifier,
  chain_constraints) where


import Classes
import Utils

import CoreSyntax
import CorePrinter

import Data.List as List


-- | The subtyping relation <: operates on both linear types and types
-- However, only constraints on types are kept, since it is the kind of constraints generated by the
-- constraint typing algorithm
data TypeConstraint =
    Subtype Type Type


-- | Flag constraints, of the form n <= m, to be interpreted as
--    n <= 0  ==  n :=: 0
--    1 <= n  ==  n :=: 1
--    m <= n  ==  m = 1 => n = 1
-- However, the constraints n <= 0 and 1 <= m are immediately applied to the reference, or eliminated
type FlagConstraint =
  (RefFlag, RefFlag)


-- | A constraint set contains both subtyping and flag constraints
type ConstraintSet =
  ([TypeConstraint], [FlagConstraint])


-- | Shortcut operator for writing sub-typing constraints
(<:) :: Type -> Type -> TypeConstraint
t <: u = Subtype t u


-- | Concatenation of two constraint sets
(<>) :: ConstraintSet -> ConstraintSet -> ConstraintSet
(lc, fc) <> (lc', fc') = (lc ++ lc', fc ++ fc')



{-
  Constraint properties
    - Atomicity : a constraint is atomic if of the form a <: b
      where a, b are type variables
  
    - Trivial : apply to constraints of the form T <: T or A <: A
      which are solved by reflexivity
 
    - Composite : apply to constraints of the form T <: U
      for any composite types T, U

    - Semi-composite : apply to constraints of the form a <: T or T <: a
      with a a type variable and T a composite type
-}

is_trivial :: TypeConstraint -> Bool
is_atomic :: TypeConstraint -> Bool
is_composite :: TypeConstraint -> Bool
is_semi_composite :: TypeConstraint -> Bool
-------------------------------------------
is_trivial (Subtype a b) = a == b

is_atomic (Subtype (TBang _ (TVar _)) (TBang _ (TVar _))) = True
is_atomic _ = False

is_composite c = (not $ is_atomic c) && (not $ is_semi_composite c)

is_semi_composite (Subtype t u) =
  case (t, u) of
    (TBang _ (TVar _), TBang _ (TVar _)) -> False
    (TBang _ (TVar _), _) -> True
    (_, TBang _ (TVar _)) -> True
    _ -> False


{-
  Check whether all the constraints of a list have the same property of being right / left sided, ie :
    - of the form a <: T : left-sided
    - of the from T <: a : right-sided

  The function is_right_sided returns true if all the constraints are right sided
               is_left_sided returns true if all the constraints are left sided
               is_one_sided returns true if either is_left_sided or is_right_sided is true
-}

is_one_sided :: [TypeConstraint] -> Bool
is_left_sided :: [TypeConstraint] -> Bool
is_right_sided :: [TypeConstraint] -> Bool
---------------------------------------
is_one_sided [] = True
is_one_sided ((Subtype t u):cset) =
  case (t, u) of
    (TBang _ (TVar _), _) -> is_left_sided cset
    (_, TBang _ (TVar _)) -> is_right_sided cset
    _ -> False

is_left_sided [] = True
is_left_sided ((Subtype (TBang _ (TVar _)) _):cset) =
  is_left_sided cset

is_right_sided [] = True
is_right_sided ((Subtype _ (TBang _ (TVar _))):cset) =
  is_right_sided cset


{-
  Finds the 'most general unifier' (not in the sense of unification) of a list of type constraints.
  The unifier is a type chosen to carry the most information about the structure of the types of the constraints
  (which has to be the same for each type). For example, the chosen unifier of ((a -> b) -> c) and (d -> (e -> f)) is
  ((a -> b) -> (e -> f))

  The list given as argument is assumed to form a 'class' of semi-composite constraints :
    - all the constraints must be semi-composite
    - all the variable of the semi-composite constraints are of the same age class (ie linked together by atomic constraints)
-}
constraint_unifier :: [TypeConstraint] -> Type
-------------------------------------------------
constraint_unifier constraints =
  let comptypes = List.map (\c -> case c of
                                    Subtype (TBang _ (TVar _)) t -> t
                                    Subtype t (TBang _ (TVar _)) -> t) constraints
  in
  list_unifier comptypes

{-
  Attempts to link together the input constraints, for example the set { b <: U, a <: b, T <: a } can
  be rearranged as { T <: a <: b <: U }

  The result is used in the unfication algorithm : if the constraints can be linked, the approximation
    { T <: a <: b <: U }  <=>  a :=: b :=: T, { T <: U } can be made
  (Since if a solution of the approximation can be found, it is also a solution of the initial set, and conversely)
-}
chain_constraints :: [TypeConstraint] -> (Bool, [TypeConstraint])
chain_left_to_right :: [TypeConstraint] -> Int -> [TypeConstraint] -> (Bool, [TypeConstraint])
chain_right_to_left :: [TypeConstraint] -> Int -> [TypeConstraint] -> (Bool, [TypeConstraint])
----------------------------------------------------------------------------------------------
chain_left_to_right chain endvar [] = (True, List.reverse chain)
chain_left_to_right chain endvar l =
  case List.find (\c -> case c of
                          Subtype (TBang _ (TVar y)) _ -> y == endvar
                          _ -> False) l of
    Just c -> case c of
                Subtype (TBang _ (TVar _)) (TBang _ (TVar y)) -> chain_left_to_right (c:chain) y (List.delete c l)
                _ -> if List.length l == 1 then
                       (True, List.reverse (c:chain))
                     else
                       (False, [])
    Nothing -> (False, [])

chain_right_to_left chain endvar [] = (True, chain)
chain_right_to_left chain endvar l =
  case List.find (\c -> case c of
                          Subtype _ (TBang _ (TVar y)) -> y == endvar
                          _ -> False) l of
    Just c -> case c of
                Subtype (TBang _ (TVar y)) (TBang _ (TVar _)) -> chain_right_to_left (c:chain) y (List.delete c l)
                _ -> if List.length l == 1 then
                       (True, c:chain)
                     else
                       (False, [])
    Nothing -> (False, [])

chain_constraints l =
  case List.find (\c -> case c of
                          Subtype (TBang _ (TVar _)) _ -> False
                          _ -> True) l of
    Just c -> case c of
                Subtype _ (TBang _ (TVar y)) -> chain_left_to_right [c] y (List.delete c l)
                _ -> error "Unreduced composite constraint"
  
    Nothing -> case List.find (\c -> case c of
                                       Subtype _ (TBang _ (TVar _)) -> False
                                       _ -> True) l of
                 Just c -> case c of
                             Subtype (TBang _ (TVar y)) _ -> chain_right_to_left [c] y (List.delete c l)
                             _ -> error "Unreduced composite constraint"
                 Nothing -> error "Only atomic constraints"

{-
  Instance declaration

  TypeConstraint is instance of
    - PPrint
    - Param
    - Eq

  FlagConstraint is instance of
    - PPrint

  ConstraintSet is instance of
    - PPrint
-}

instance Param TypeConstraint where
  free_var (Subtype t u) = free_var t ++ free_var u

  subs_var a b (Subtype t u) = Subtype (subs_var a b t) (subs_var a b u)

instance PPrint TypeConstraint where
  pprint (Subtype t u) = pprint t ++ " <: " ++ pprint u
  sprintn _ c = pprint c
  sprint c = pprint c

instance Eq TypeConstraint where
  (==) (Subtype t u) (Subtype t' u') = t == t' && u == u'

instance PPrint FlagConstraint where
  pprint (m, n) =
    (if m < 2 then
       show m
     else
       subvar 'f' m) ++ " <= " ++
    (if n < 2 then
       show n
     else
       subvar 'f' n)

  sprintn _ c = pprint c
  sprint c = pprint c

instance PPrint ConstraintSet where
  pprint (lcs, fcs) =
    let screenw = 120 in
    let plcs = List.map pprint lcs in
    let maxw = List.maximum $ List.map List.length plcs in
    let nline = screenw `quot` (maxw + 5) in 

    let slcons = fst $ List.foldl (\(s, nth) pc ->
                        let padding = List.take (maxw - List.length pc + 5) $ List.repeat ' ' in

                        if nth == 0 then
                          (s ++ "\n" ++ pc ++ padding, nline)
                        else
                          (s ++ pc ++ padding, nth-1)) ("", nline+1) plcs
    in

    let pfcs = List.map pprint fcs in
    let maxw = List.maximum $ List.map List.length pfcs in
    let nline = screenw `quot` (maxw + 5) in

    let sfcons = fst $ List.foldl (\(s, nth) pc ->
                        let padding = List.take (maxw - List.length pc + 5) $ List.repeat ' ' in

                        if nth == 0 then
                          (s ++ "\n" ++ pc ++ padding, nline)
                        else
                          (s ++ pc ++ padding, nth-1)) ("", nline+1) pfcs
    in

    slcons ++ "\n" ++ sfcons

  sprintn _ cs = pprint cs
  sprint cs = pprint cs
